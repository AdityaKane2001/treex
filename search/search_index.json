{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Treex A Pytree Module system for Deep Learning in JAX Intuitive : Modules are simple Python objects that respect Object-Oriented semantics and should make PyTorch users feel at home, with no need for separate dictionary structures or complex apply methods. Pytree-based : Modules are registered as JAX PyTrees, enabling their use with any JAX function. No need for specialized versions of jit , grad , vmap , etc. Expressive : In Treex you use type annotations to define what the different parts of your module represent (submodules, parameters, batch statistics, etc), this leads to a very flexible and powerful state management solution. Flax-based Implementations : Writing high-quality, battle-tested code for common layers is hard. For this reason Modules in treex.nn are wrappers over their Flax counterparts. We keep identical signatures, enabling Flax users to feel at home but still benefiting from the simpler Pytorch-like experience Treex brings. Treex is implemented on top of Treeo , Treex vendors all of Treeo's public API for ease of usage. Documentation | User Guide Why Treex? Despite all JAX benefits, current Module systems are not intuitive to new users and add additional complexity not present in frameworks like PyTorch or Keras. Treex takes inspiration from S4TF and delivers an intuitive experience using JAX Pytree infrastructure. Current Alternative's Drawbacks and Solutions Currently we have many alternatives like Flax, Haiku, Objax, that have one or more of the following drawbacks: * Module structure and parameter structure are separate, and parameters have to be manipulated around by the end-user, which is not intuitive. In Treex, parameters are stored in the modules themselves and can be accessed directly. * Monadic architecture adds complexity. Flax and Haiku use an `apply` method to call modules that set a context with parameters, rng, and different metadata, which adds additional overhead to the API and creates an asymmetry in how Modules are being used inside and outside a context. In Treex, modules can be called directly. * Among different frameworks, parameter surgery requires special consideration and is challenging to implement. Consider a standard workflow such as transfer learning, transferring parameters and state from a pre-trained module or submodule as part of a new module; in different frameworks, we have to know precisely how to extract their parameters and how to insert them into the new parameter structure/dictionaries such that it is in agreement with the new module structure. In Treex, just as in PyTorch / Keras, we enable to pass the (sub)module to the new module, and parameters are automatically added to the new structure. * Multiple frameworks deviate from JAX semantics and require particular versions of `jit`, `grad`, `vmap`, etc., which makes it harder to integrate with other JAX libraries. Treex's Modules are plain old JAX PyTrees and are compatible with any JAX library that supports them. * Other Pytree-based approaches like Parallax and Equinox do not have a total state management solution to handle complex states as encountered in Flax. Treex has the Filter and Update API, which is very expressive and can effectively handle systems with a complex state. Installation Install using pip: pip install treex Status Treex is in an early stage, things might brake between versions but we will respect semanting versioning. While more testing is needed, since Treex layers are numerically equivalent to Flax this borrows some maturity and yields more confidence over its results. Feedback is much appreciated. Roadmap : [x] Finish prototyping core API [ ] Wrap all Flax Linen Modules [x] Document public API [x] Create documentation site Getting Started This is a small appetizer to give you a feel for how using Treex looks like, be sure to checkout the Guide section below for details on more advanced usage. from typing import Sequence , List import jax import jax.numpy as jnp import numpy as np import treex as tx # you can use tx.MLP but we will create our own as an example class MLP ( tx . Module ): layers : List [ tx . Linear ] = tx . node () def __init__ ( self , features : Sequence [ int ]): self . layers = [ tx . Linear ( din , dout ) for din , dout in zip ( features [: - 1 ], features [ 1 :]) ] def __call__ ( self , x ): for linear in self . layers [: - 1 ]: x = jax . nn . relu ( linear ( x )) return self . layers [ - 1 ]( x ) @jax . jit @jax . grad def loss_fn ( model , x , y ): y_pred = model ( x ) return jnp . mean (( y_pred - y ) ** 2 ) # in reality use optax def sdg ( param , grad ): return param - 0.01 * grad model = MLP ([ 1 , 12 , 8 , 1 ]) . init ( 42 ) x = np . random . uniform ( - 1 , 1 , size = ( 100 , 1 )) y = 1.4 * x ** 2 - 0.3 + np . random . normal ( scale = 0.1 , size = ( 100 , 1 )) # training loop for step in range ( 10_000 ): grads = loss_fn ( model , x , y ) model = jax . tree_map ( sdg , model , grads ) model = model . eval () y_pred = model ( x ) Stateful Module example Here is an example of creating a stateful module of a RollingMean metric and using them with jax.jit : class RollingMean ( tx . Module ): count : jnp . ndarray = tx . State . node () total : jnp . ndarray = tx . State . node () def __init__ ( self ): self . count = jnp . array ( 0 ) self . total = jnp . array ( 0.0 ) def __call__ ( self , x : jnp . ndarray ) -> jnp . ndarray : self . count += np . prod ( x . shape ) self . total += x . sum () return self . total / self . count @jax . jit def update ( x : jnp . ndarray , metric : RollingMean ) -> Tuple [ jnp . ndarray , RollingMean ]: mean = metric ( x ) return mean , metric # return mean value and updated metric metric = RollingMean () for i in range ( 10 ): x = np . random . uniform ( - 1 , 1 , size = ( 100 , 1 )) mean , metric = update ( x , metric ) print ( mean ) Linear Regression from scratch example from functools import partial from typing import Union import jax import jax.numpy as jnp import matplotlib.pyplot as plt import numpy as np import optax import treex as tx x = np . random . uniform ( size = ( 500 , 1 )) y = 1.4 * x - 0.3 + np . random . normal ( scale = 0.1 , size = ( 500 , 1 )) class Linear ( tx . Module ): w : Union [ tx . Initializer , jnp . ndarray ] = tx . Parameter . node () b : jnp . ndarray = tx . Parameter . node () def __init__ ( self , din , dout ): self . w = tx . Initializer ( lambda key : jax . random . uniform ( key , shape = ( din , dout ))) self . b = jnp . zeros ( shape = ( dout ,)) def __call__ ( self , x ): return jnp . dot ( x , self . w ) + self . b @partial ( jax . value_and_grad , has_aux = True ) def loss_fn ( params , model , x , y ): model = model . merge ( params ) y_pred = model ( x ) loss = jnp . mean (( y_pred - y ) ** 2 ) return loss , model @jax . jit def train_step ( model , x , y , optimizer ): params = model . filter ( tx . Parameter ) ( loss , model ), grads = loss_fn ( params , model , x , y ) # here model == params model = optimizer . update ( grads , model ) return loss , model , optimizer model = Linear ( 1 , 1 ) . init ( 42 ) optimizer = tx . Optimizer ( optax . adam ( 0.01 )) optimizer = optimizer . init ( model ) for step in range ( 1000 ): loss , model , optimizer = train_step ( model , x , y , optimizer ) if step % 100 == 0 : print ( f \"loss: { loss : .4f } \" ) model = model . eval () X_test = np . linspace ( x . min (), x . max (), 100 )[:, None ] y_pred = model ( X_test ) plt . scatter ( x , y , c = \"k\" , label = \"data\" ) plt . plot ( X_test , y_pred , c = \"b\" , linewidth = 2 , label = \"prediction\" ) plt . legend () plt . show ()","title":"Treex"},{"location":"#treex","text":"A Pytree Module system for Deep Learning in JAX Intuitive : Modules are simple Python objects that respect Object-Oriented semantics and should make PyTorch users feel at home, with no need for separate dictionary structures or complex apply methods. Pytree-based : Modules are registered as JAX PyTrees, enabling their use with any JAX function. No need for specialized versions of jit , grad , vmap , etc. Expressive : In Treex you use type annotations to define what the different parts of your module represent (submodules, parameters, batch statistics, etc), this leads to a very flexible and powerful state management solution. Flax-based Implementations : Writing high-quality, battle-tested code for common layers is hard. For this reason Modules in treex.nn are wrappers over their Flax counterparts. We keep identical signatures, enabling Flax users to feel at home but still benefiting from the simpler Pytorch-like experience Treex brings. Treex is implemented on top of Treeo , Treex vendors all of Treeo's public API for ease of usage. Documentation | User Guide","title":"Treex"},{"location":"#why-treex","text":"Despite all JAX benefits, current Module systems are not intuitive to new users and add additional complexity not present in frameworks like PyTorch or Keras. Treex takes inspiration from S4TF and delivers an intuitive experience using JAX Pytree infrastructure. Current Alternative's Drawbacks and Solutions Currently we have many alternatives like Flax, Haiku, Objax, that have one or more of the following drawbacks: * Module structure and parameter structure are separate, and parameters have to be manipulated around by the end-user, which is not intuitive. In Treex, parameters are stored in the modules themselves and can be accessed directly. * Monadic architecture adds complexity. Flax and Haiku use an `apply` method to call modules that set a context with parameters, rng, and different metadata, which adds additional overhead to the API and creates an asymmetry in how Modules are being used inside and outside a context. In Treex, modules can be called directly. * Among different frameworks, parameter surgery requires special consideration and is challenging to implement. Consider a standard workflow such as transfer learning, transferring parameters and state from a pre-trained module or submodule as part of a new module; in different frameworks, we have to know precisely how to extract their parameters and how to insert them into the new parameter structure/dictionaries such that it is in agreement with the new module structure. In Treex, just as in PyTorch / Keras, we enable to pass the (sub)module to the new module, and parameters are automatically added to the new structure. * Multiple frameworks deviate from JAX semantics and require particular versions of `jit`, `grad`, `vmap`, etc., which makes it harder to integrate with other JAX libraries. Treex's Modules are plain old JAX PyTrees and are compatible with any JAX library that supports them. * Other Pytree-based approaches like Parallax and Equinox do not have a total state management solution to handle complex states as encountered in Flax. Treex has the Filter and Update API, which is very expressive and can effectively handle systems with a complex state.","title":"Why Treex?"},{"location":"#installation","text":"Install using pip: pip install treex","title":"Installation"},{"location":"#status","text":"Treex is in an early stage, things might brake between versions but we will respect semanting versioning. While more testing is needed, since Treex layers are numerically equivalent to Flax this borrows some maturity and yields more confidence over its results. Feedback is much appreciated. Roadmap : [x] Finish prototyping core API [ ] Wrap all Flax Linen Modules [x] Document public API [x] Create documentation site","title":"Status"},{"location":"#getting-started","text":"This is a small appetizer to give you a feel for how using Treex looks like, be sure to checkout the Guide section below for details on more advanced usage. from typing import Sequence , List import jax import jax.numpy as jnp import numpy as np import treex as tx # you can use tx.MLP but we will create our own as an example class MLP ( tx . Module ): layers : List [ tx . Linear ] = tx . node () def __init__ ( self , features : Sequence [ int ]): self . layers = [ tx . Linear ( din , dout ) for din , dout in zip ( features [: - 1 ], features [ 1 :]) ] def __call__ ( self , x ): for linear in self . layers [: - 1 ]: x = jax . nn . relu ( linear ( x )) return self . layers [ - 1 ]( x ) @jax . jit @jax . grad def loss_fn ( model , x , y ): y_pred = model ( x ) return jnp . mean (( y_pred - y ) ** 2 ) # in reality use optax def sdg ( param , grad ): return param - 0.01 * grad model = MLP ([ 1 , 12 , 8 , 1 ]) . init ( 42 ) x = np . random . uniform ( - 1 , 1 , size = ( 100 , 1 )) y = 1.4 * x ** 2 - 0.3 + np . random . normal ( scale = 0.1 , size = ( 100 , 1 )) # training loop for step in range ( 10_000 ): grads = loss_fn ( model , x , y ) model = jax . tree_map ( sdg , model , grads ) model = model . eval () y_pred = model ( x )","title":"Getting Started"},{"location":"#stateful-module-example","text":"Here is an example of creating a stateful module of a RollingMean metric and using them with jax.jit : class RollingMean ( tx . Module ): count : jnp . ndarray = tx . State . node () total : jnp . ndarray = tx . State . node () def __init__ ( self ): self . count = jnp . array ( 0 ) self . total = jnp . array ( 0.0 ) def __call__ ( self , x : jnp . ndarray ) -> jnp . ndarray : self . count += np . prod ( x . shape ) self . total += x . sum () return self . total / self . count @jax . jit def update ( x : jnp . ndarray , metric : RollingMean ) -> Tuple [ jnp . ndarray , RollingMean ]: mean = metric ( x ) return mean , metric # return mean value and updated metric metric = RollingMean () for i in range ( 10 ): x = np . random . uniform ( - 1 , 1 , size = ( 100 , 1 )) mean , metric = update ( x , metric ) print ( mean )","title":"Stateful Module example"},{"location":"#linear-regression-from-scratch-example","text":"from functools import partial from typing import Union import jax import jax.numpy as jnp import matplotlib.pyplot as plt import numpy as np import optax import treex as tx x = np . random . uniform ( size = ( 500 , 1 )) y = 1.4 * x - 0.3 + np . random . normal ( scale = 0.1 , size = ( 500 , 1 )) class Linear ( tx . Module ): w : Union [ tx . Initializer , jnp . ndarray ] = tx . Parameter . node () b : jnp . ndarray = tx . Parameter . node () def __init__ ( self , din , dout ): self . w = tx . Initializer ( lambda key : jax . random . uniform ( key , shape = ( din , dout ))) self . b = jnp . zeros ( shape = ( dout ,)) def __call__ ( self , x ): return jnp . dot ( x , self . w ) + self . b @partial ( jax . value_and_grad , has_aux = True ) def loss_fn ( params , model , x , y ): model = model . merge ( params ) y_pred = model ( x ) loss = jnp . mean (( y_pred - y ) ** 2 ) return loss , model @jax . jit def train_step ( model , x , y , optimizer ): params = model . filter ( tx . Parameter ) ( loss , model ), grads = loss_fn ( params , model , x , y ) # here model == params model = optimizer . update ( grads , model ) return loss , model , optimizer model = Linear ( 1 , 1 ) . init ( 42 ) optimizer = tx . Optimizer ( optax . adam ( 0.01 )) optimizer = optimizer . init ( model ) for step in range ( 1000 ): loss , model , optimizer = train_step ( model , x , y , optimizer ) if step % 100 == 0 : print ( f \"loss: { loss : .4f } \" ) model = model . eval () X_test = np . linspace ( x . min (), x . max (), 100 )[:, None ] y_pred = model ( X_test ) plt . scatter ( x , y , c = \"k\" , label = \"data\" ) plt . plot ( X_test , y_pred , c = \"b\" , linewidth = 2 , label = \"prediction\" ) plt . legend () plt . show ()","title":"Linear Regression from scratch example"},{"location":"api/Apply/","text":"treex.Apply Mixin that adds a .apply() method to the class. apply ( self , f , * rest , * , inplace = False ) apply is a wrapper over treeo.apply that passes self as the second argument. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treeo/mixins.py def apply ( self : A , f : tp . Callable [ ... , None ], * rest : A , inplace : bool = False ) -> A : \"\"\" `apply` is a wrapper over `treeo.apply` that passes `self` as the second argument. Arguments: f: The function to apply. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" return api . apply ( f , self , * rest , inplace = inplace )","title":"Apply"},{"location":"api/Apply/#treexapply","text":"Mixin that adds a .apply() method to the class.","title":"treex.Apply"},{"location":"api/Apply/#treeo.mixins.Apply.apply","text":"apply is a wrapper over treeo.apply that passes self as the second argument. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treeo/mixins.py def apply ( self : A , f : tp . Callable [ ... , None ], * rest : A , inplace : bool = False ) -> A : \"\"\" `apply` is a wrapper over `treeo.apply` that passes `self` as the second argument. Arguments: f: The function to apply. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" return api . apply ( f , self , * rest , inplace = inplace )","title":"apply()"},{"location":"api/BatchNorm/","text":"treex.BatchNorm BatchNorm Module. BatchNorm is implemented as a wrapper over flax.linen.BatchNorm , its constructor arguments accept almost the same arguments including any Flax artifacts such as initializers. Main differences: use_running_average is not a constructor argument, but remains a __call__ argument. self.training state is used to indicate how BatchNorm should behave, interally use_running_average = not self.training or self.frozen is used unless use_running_average is explicitly passed via __call__ . first_run : bool inherited property readonly Returns: Type Description bool True if its currently the first run of a compact method. __class__ inherited __base__ inherited Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()). __instancecheck__ ( cls , instance ) special Override for isinstance(instance, cls). Source code in treex/nn/batch_norm.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance ) __new__ ( mcls , name , bases , namespace , ** kwargs ) special staticmethod Create and return a new object. See help(type) for accurate signature. Source code in treex/nn/batch_norm.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls __subclasscheck__ ( cls , subclass ) special Override for issubclass(subclass, cls). Source code in treex/nn/batch_norm.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass ) register ( cls , subclass ) Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/batch_norm.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) register ( cls , subclass ) inherited Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/batch_norm.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) __call__ ( self , x , use_running_average = None ) special Normalizes the input using batch statistics. Parameters: Name Type Description Default x ndarray the input to be normalized. required use_running_average Optional[bool] if true, the statistics stored in batch_stats will be used instead of computing the batch statistics on the input. None Returns: Type Description ndarray Normalized inputs (the same shape as inputs). Source code in treex/nn/batch_norm.py def __call__ ( self , x : np . ndarray , use_running_average : tp . Optional [ bool ] = None ) -> jnp . ndarray : \"\"\"Normalizes the input using batch statistics. Arguments: x: the input to be normalized. use_running_average: if true, the statistics stored in batch_stats will be used instead of computing the batch statistics on the input. Returns: Normalized inputs (the same shape as inputs). \"\"\" assert self . initialized , \"Module not initialized\" params = {} if self . use_bias : params [ \"bias\" ] = self . bias if self . use_scale : params [ \"scale\" ] = self . scale variables = dict ( batch_stats = dict ( mean = self . mean , var = self . var , ), params = params , ) # use_running_average = True means batch_stats will not be mutated # self.training = True means batch_stats will be mutated training = ( not use_running_average if use_running_average is not None else self . training and not self . frozen ) # call apply output , variables = self . module . apply ( variables , x , mutable = [ \"batch_stats\" ] if training else [], use_running_average = not training , ) variables = variables . unfreeze () # update batch_stats if \"batch_stats\" in variables : self . mean = variables [ \"batch_stats\" ][ \"mean\" ] self . var = variables [ \"batch_stats\" ][ \"var\" ] return tp . cast ( jnp . ndarray , output ) __init__ ( self , features_in , axis =- 1 , momentum = 0.99 , epsilon = 1e-05 , dtype =< class ' jax . _src . numpy . lax_numpy . float32 '>, use_bias=True, use_scale=True, bias_init=<function zeros at 0x7fc07ed80ca0>, scale_init=<function ones at 0x7fc07ed80dc0>, axis_name=None, axis_index_groups=None) special Parameters: Name Type Description Default features_in int the number of input features. required axis int the feature or non-batch axis of the input. -1 momentum Union[float, jax._src.numpy.lax_numpy.ndarray] decay rate for the exponential moving average of the batch statistics. 0.99 epsilon float a small float added to variance to avoid dividing by zero. 1e-05 dtype Any the dtype of the computation (default: float32). <class 'jax._src.numpy.lax_numpy.float32'> use_bias bool if True, bias (beta) is added. True use_scale bool if True, multiply by scale (gamma). When the next layer is linear (also e.g. nn.relu), this can be disabled since the scaling will be done by the next layer. True bias_init Callable[[Any, Tuple[int], Any], Any] initializer for bias, by default, zero. <function zeros at 0x7fc07ed80ca0> scale_init Callable[[Any, Tuple[int], Any], Any] initializer for scale, by default, one. <function ones at 0x7fc07ed80dc0> axis_name Optional[str] the axis name used to combine batch statistics from multiple devices. See jax.pmap for a description of axis names (default: None). None axis_index_groups Any groups of axis indices within that named axis representing subsets of devices to reduce over (default: None). For example, [[0, 1], [2, 3]] would independently batch-normalize over the examples on the first two and last two devices. See jax.lax.psum for more details. None Source code in treex/nn/batch_norm.py def __init__ ( self , features_in : int , axis : int = - 1 , momentum : tp . Union [ float , jnp . ndarray ] = 0.99 , epsilon : float = 1e-5 , dtype : flax_module . Dtype = jnp . float32 , use_bias : bool = True , use_scale : bool = True , bias_init : tp . Callable [ [ flax_module . PRNGKey , flax_module . Shape , flax_module . Dtype ], flax_module . Array , ] = flax_module . initializers . zeros , scale_init : tp . Callable [ [ flax_module . PRNGKey , flax_module . Shape , flax_module . Dtype ], flax_module . Array , ] = flax_module . initializers . ones , axis_name : tp . Optional [ str ] = None , axis_index_groups : tp . Any = None , ): \"\"\" Arguments: features_in: the number of input features. axis: the feature or non-batch axis of the input. momentum: decay rate for the exponential moving average of the batch statistics. epsilon: a small float added to variance to avoid dividing by zero. dtype: the dtype of the computation (default: float32). use_bias: if True, bias (beta) is added. use_scale: if True, multiply by scale (gamma). When the next layer is linear (also e.g. nn.relu), this can be disabled since the scaling will be done by the next layer. bias_init: initializer for bias, by default, zero. scale_init: initializer for scale, by default, one. axis_name: the axis name used to combine batch statistics from multiple devices. See `jax.pmap` for a description of axis names (default: None). axis_index_groups: groups of axis indices within that named axis representing subsets of devices to reduce over (default: None). For example, `[[0, 1], [2, 3]]` would independently batch-normalize over the examples on the first two and last two devices. See `jax.lax.psum` for more details. \"\"\" self . features_in = features_in self . axis = axis self . momentum = jnp . asarray ( momentum ) self . epsilon = epsilon self . dtype = dtype self . use_bias = use_bias self . use_scale = use_scale self . bias_init = bias_init self . scale_init = scale_init self . axis_name = axis_name self . axis_index_groups = axis_index_groups self . mean = None self . var = None self . scale = None self . bias = None apply ( self , f , * rest , * , inplace = False ) inherited apply is a wrapper over treeo.apply that passes self as the second argument. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treex/nn/batch_norm.py def apply ( self : A , f : tp . Callable [ ... , None ], * rest : A , inplace : bool = False ) -> A : \"\"\" `apply` is a wrapper over `treeo.apply` that passes `self` as the second argument. Arguments: f: The function to apply. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" return api . apply ( f , self , * rest , inplace = inplace ) batch_stats ( self , * filters ) inherited Returns a copy of the Module with only tx.BatchStat TreeParts, alias for filter(tx.BatchStat) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/batch_norm.py def batch_stats ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.BatchStat TreeParts, alias for `filter(tx.BatchStat)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . BatchStat , * filters ) check_metadata_updates ( self ) inherited Checks for new fields, if found, adds them to the metadata. Source code in treex/nn/batch_norm.py def check_metadata_updates ( self ): \"\"\" Checks for new fields, if found, adds them to the metadata. \"\"\" with _CONTEXT . update ( flatten_mode = FlattenMode . all_fields ): jax . tree_flatten ( self ) copy ( self ) inherited copy is a wrapper over treeo.copy that passes self as the first argument. Source code in treex/nn/batch_norm.py def copy ( self : A ) -> A : \"\"\" `copy` is a wrapper over `treeo.copy` that passes `self` as the first argument. \"\"\" return tree_m . copy ( self ) eval ( self , inplace = False ) inherited Creates a new module with the training mode set to False, equivalent to calling train(False) . Returns: Type Description ~M The new module with the training mode set to False. Source code in treex/nn/batch_norm.py def eval ( self : M , inplace : bool = False ) -> M : \"\"\" Creates a new module with the training mode set to False, equivalent to calling `train(False)`. Returns: The new module with the training mode set to False. \"\"\" return self . train ( False , inplace = inplace ) filter ( self , * filters , * , inplace = False , flatten_mode = None ) inherited filter is a wrapper over treeo.filter that passes self as the first argument. Parameters: Name Type Description Default *filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treex/nn/batch_norm.py def filter ( self : A , * filters : api . Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ) -> A : \"\"\" `filter` is a wrapper over `treeo.filter` that passes `self` as the first argument. Arguments: *filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" return api . filter ( self , * filters , inplace = inplace , flatten_mode = flatten_mode ) freeze ( self , mode = True , inplace = False ) inherited Creates a new module with the same structure, but with Module.frozen set to the given value. Parameters: Name Type Description Default mode bool The new frozen mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~M The new module in with the frozen mode is set to the given value, if inplace is True then self is returned. Source code in treex/nn/batch_norm.py def freeze ( self : M , mode : bool = True , inplace : bool = False ) -> M : \"\"\" Creates a new module with the same structure, but with `Module.frozen` set to the given value. Arguments: mode: The new `frozen` mode. inplace: Whether to update the module inplace. Returns: The new module in with the `frozen` mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_frozen ( module : Module ): if isinstance ( module , Module ): module . _frozen = mode return to . apply ( set_frozen , self , inplace = inplace ) get_field ( self , field_name , initializer ) inherited A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: The field must be declared in the class definition. The method can only be called inside a compact context. Parameters: Name Type Description Default field_name str The name of the field to get. required initializer Callable[[], ~A] The function to initialize the field if it does not exist. required Returns: Type Description ~A The field value. Source code in treex/nn/batch_norm.py def get_field ( self , field_name : str , initializer : tp . Callable [[], A ], ) -> A : \"\"\" A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: * The field must be declared in the class definition. * The method can only be called inside a `compact` context. Arguments: field_name: The name of the field to get. initializer: The function to initialize the field if it does not exist. Returns: The field value. \"\"\" value : A if field_name not in self . _field_metadata : raise ValueError ( f \"Metadata for field ' { field_name } ' does not exist.\" ) if tree_m . _COMPACT_CONTEXT . current_tree is not self : raise RuntimeError ( f \"Object ' { type ( self ) . __name__ } ' is not the current tree, found ' { type ( tree_m . _COMPACT_CONTEXT . current_tree ) . __name__ } ', did you forget the @compact decorator?\" ) if field_name in vars ( self ): value = getattr ( self , field_name ) else : if tree_m . _COMPACT_CONTEXT . in_compact and not self . first_run : raise RuntimeError ( f \"Trying to initialize field ' { field_name } ' after the first run of `compact`.\" ) value = initializer () setattr ( self , field_name , value ) return value init ( self , key , inplace = False ) inherited Method version of tx.init , it applies self as first argument. init creates a new module with the same structure, but with its fields initialized given a seed key . The following procedure is used: The input key is split and iteratively updated before passing a derived value to any process that requires initialization. Initializer s are called and applied to the module first. Module.rng_init methods are called last. Parameters: Name Type Description Default key Union[int, jax._src.numpy.lax_numpy.ndarray] The seed to use for initialization. required Returns: Type Description ~M The new module with the fields initialized. Source code in treex/nn/batch_norm.py def init ( self : M , key : tp . Union [ int , jnp . ndarray ], inplace : bool = False ) -> M : \"\"\" Method version of `tx.init`, it applies `self` as first argument. `init` creates a new module with the same structure, but with its fields initialized given a seed `key`. The following procedure is used: 1. The input `key` is split and iteratively updated before passing a derived value to any process that requires initialization. 2. `Initializer`s are called and applied to the module first. 3. `Module.rng_init` methods are called last. Arguments: key: The seed to use for initialization. Returns: The new module with the fields initialized. \"\"\" if isinstance ( key , int ): key = jax . random . PRNGKey ( key ) def next_key () -> jnp . ndarray : nonlocal key assert isinstance ( key , ( np . ndarray , jnp . ndarray )) next_key , key = utils . iter_split ( key ) return next_key tree_out : M = jax . tree_map ( lambda initializer : ( initializer ( next_key ()) if isinstance ( initializer , types . Initializer ) else initializer ), self , is_leaf = lambda x : isinstance ( x , types . Initializer ), ) if inplace : # here we update initialized fields by the above tree_map tree_out = to . merge ( self , tree_out , inplace = True ) def call_module_init ( module : Module ): if isinstance ( module , Module ) and not module . _initialized : module . rng_init ( next_key ()) module . _initialized = True return to . apply ( call_module_init , tree_out , inplace = inplace ) logs ( self , * filters ) inherited Returns a copy of the Module with only tx.Log TreeParts, alias for filter(tx.Log) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/batch_norm.py def logs ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Log TreeParts, alias for `filter(tx.Log)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . Log , * filters ) losses ( self , * filters ) inherited Returns a copy of the Module with only tx.Loss TreeParts, alias for filter(tx.Loss) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/batch_norm.py def losses ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Loss TreeParts, alias for `filter(tx.Loss)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . LossLog , * filters ) map ( self , f , * filters , * , inplace = False , flatten_mode = None , is_leaf = None ) inherited map is a wrapper over treeo.map that passes self as the second argument. Parameters: Name Type Description Default f Callable The function to apply to the leaves. required *filters Filter The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treex/nn/batch_norm.py def map ( self : A , f : tp . Callable , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , is_leaf : tp . Callable [[ tp . Any ], bool ] = None , ) -> A : \"\"\" `map` is a wrapper over `treeo.map` that passes `self` as the second argument. Arguments: f: The function to apply to the leaves. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" return api . map ( f , self , * filters , inplace = inplace , flatten_mode = flatten_mode , is_leaf = is_leaf , ) merge ( self , other , * rest , * , inplace = False , flatten_mode = None , ignore_static = False ) inherited merge is a wrapper over treeo.merge that passes self as the first argument. Parameters: Name Type Description Default other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the merged values. If inplace is True , obj is returned. Source code in treex/nn/batch_norm.py def merge ( self : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" `merge` is a wrapper over `treeo.merge` that passes `self` as the first argument. Arguments: other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the merged values. If `inplace` is `True`, `obj` is returned. \"\"\" return api . merge ( self , other , * rest , inplace = inplace , flatten_mode = flatten_mode , ignore_static = ignore_static , ) metrics ( self , * filters ) inherited Returns a copy of the Module with only tx.Metric TreeParts, alias for filter(tx.Metric) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/batch_norm.py def metrics ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Metric TreeParts, alias for `filter(tx.Metric)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . MetricLog , * filters ) model_states ( self , * filters ) inherited Returns a copy of the Module with only tx.ModelState TreeParts, alias for filter(tx.ModelState) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/batch_norm.py def model_states ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.ModelState TreeParts, alias for `filter(tx.ModelState)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . ModelState , * filters ) parameters ( self , * filters ) inherited Returns a copy of the Module with only tx.Parameter TreeParts, alias for filter(tx.Parameter) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/batch_norm.py def parameters ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Parameter TreeParts, alias for `filter(tx.Parameter)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . Parameter , * filters ) rngs ( self , * filters ) inherited Returns a copy of the Module with only tx.Rng TreeParts, alias for filter(tx.Rng) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/batch_norm.py def rngs ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Rng TreeParts, alias for `filter(tx.Rng)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . Rng , * filters ) states ( self , * filters ) inherited Returns a copy of the Module with only tx.State TreeParts, alias for filter(tx.State) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/batch_norm.py def states ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.State TreeParts, alias for `filter(tx.State)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . State , * filters ) tabulate ( self , inputs = None , depth =- 1 , signature = False , param_types = True ) inherited Returns a tabular representation of the module. Parameters: Name Type Description Default depth int The maximum depth of the representation in terms of nested Modules, -1 means no limit. -1 signature bool Whether to show the signature of the Module. False param_types bool Whether to show the types of the parameters. True Returns: Type Description str A string containing the tabular representation. Source code in treex/nn/batch_norm.py def tabulate ( self , inputs : tp . Union [ tp . Any , types . Inputs , None ] = None , depth : int = - 1 , signature : bool = False , param_types : bool = True , ) -> str : \"\"\" Returns a tabular representation of the module. Arguments: depth: The maximum depth of the representation in terms of nested Modules, -1 means no limit. signature: Whether to show the signature of the Module. param_types: Whether to show the types of the parameters. Returns: A string containing the tabular representation. \"\"\" self = to . copy ( self ) if inputs is not None : if not isinstance ( inputs , types . Inputs ): inputs = types . Inputs ( inputs ) inputs = tp . cast ( types . Inputs , inputs ) if not isinstance ( self , tp . Callable ): raise TypeError ( \"`inputs` can only be specified if the module is a callable.\" ) with _Context ( call_info = {}): # call using self to preserve references def eval_call ( args , kwargs ): assert isinstance ( self , tp . Callable ) return self ( * args , ** kwargs ) jax . eval_shape ( eval_call , inputs . args , inputs . kwargs , ) call_info = _CONTEXT . call_info else : call_info = None with to . add_field_info (): flat : tp . List [ to . FieldInfo ] flat , _ = jax . tree_flatten ( self ) tree_part_types : tp . Tuple [ tp . Type [ types . TreePart ], ... ] = tuple ( { field_info . kind for field_info in flat if utils . _generic_issubclass ( field_info . kind , types . TreePart ) } ) path = () rows = list ( utils . _get_tabulate_rows ( path , self , depth , tree_part_types , signature , param_types ) ) modules = [ row [ 0 ] for row in rows ] rows = [ row [ 1 :] for row in rows ] if call_info is not None : for module , row in zip ( modules , rows ): if module in call_info : inputs , outputs = call_info [ module ] simplified_inputs = ( inputs . args [ 0 ] if len ( inputs . kwargs ) == 0 and len ( inputs . args ) == 1 else inputs . kwargs if len ( inputs . kwargs ) == 0 else inputs . kwargs if len ( inputs . args ) == 0 else ( inputs . args , inputs . kwargs ) ) inputs_repr = utils . _format_param_tree ( simplified_inputs ) outputs_repr = utils . _format_param_tree ( outputs ) else : inputs_repr = \"\" outputs_repr = \"\" row . insert ( 3 , outputs_repr ) row . insert ( 3 , inputs_repr ) n_non_treepart_cols = 2 if call_info is None else 4 rows [ 0 ][ 0 ] = \"*\" rows . append ( [ \"\" ] * n_non_treepart_cols + [ \"Total:\" ] + [ utils . _format_obj_size ( self . filter ( kind ), add_padding = True ) for kind in tree_part_types ] ) utils . _add_padding ( rows ) table = Table ( show_header = True , show_lines = True , show_footer = True , # box=rich.box.HORIZONTALS, ) table . add_column ( \"path\" ) table . add_column ( \"module\" ) table . add_column ( \"params\" ) if call_info is not None : table . add_column ( \"inputs\" ) table . add_column ( \"outputs\" ) for tree_part_type in tree_part_types : type_name = tree_part_type . __name__ if type_name . startswith ( \"_\" ): type_name = type_name [ 1 :] table . add_column ( type_name ) for row in rows [: - 1 ]: table . add_row ( * row ) table . columns [ n_non_treepart_cols ] . footer = Text . from_markup ( rows [ - 1 ][ n_non_treepart_cols ], justify = \"right\" ) for i in range ( len ( tree_part_types )): table . columns [ n_non_treepart_cols + 1 + i ] . footer = rows [ - 1 ][ n_non_treepart_cols + 1 + i ] table . caption_style = \"bold\" table . caption = \" \\n Total Parameters: \" + utils . _format_obj_size ( self , add_padding = False ) return utils . _get_rich_repr ( table ) to_dict ( self , * , private_fields = False , static_fields = True , type_info = False , field_info = False ) inherited to_dict is a wrapper over treeo.to_dict that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True type_info bool If True , type information is included. False field_info bool If True , field information is included. False Returns: Type Description Any A dict representation of the object. Source code in treex/nn/batch_norm.py def to_dict ( self , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : \"\"\" `to_dict` is a wrapper over `treeo.to_dict` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. type_info: If `True`, type information is included. field_info: If `True`, field information is included. Returns: A dict representation of the object. \"\"\" return api . to_dict ( self , private_fields = private_fields , static_fields = static_fields , type_info = type_info , field_info = field_info , ) to_string ( self , * , private_fields = False , static_fields = True , color = False ) inherited to_string is a wrapper over treeo.to_string that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True color bool If True , color is included. False Returns: Type Description str A string representation of the object. Source code in treex/nn/batch_norm.py def to_string ( self : A , * , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" `to_string` is a wrapper over `treeo.to_string` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. color: If `True`, color is included. Returns: A string representation of the object. \"\"\" return api . to_string ( self , private_fields = private_fields , static_fields = static_fields , color = color , ) train ( self , mode = True , inplace = False ) inherited Creates a new module with the same structure, but with Module.training set to the given value. Parameters: Name Type Description Default mode bool The new training mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~M The new module in with the training mode is set to the given value, if inplace is True then self is returned. Source code in treex/nn/batch_norm.py def train ( self : M , mode : bool = True , inplace : bool = False ) -> M : \"\"\" Creates a new module with the same structure, but with `Module.training` set to the given value. Arguments: mode: The new training mode. inplace: Whether to update the module inplace. Returns: The new module in with the training mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_training ( module : Module ): if isinstance ( module , Module ): module . _training = mode return to . apply ( set_training , self , inplace = inplace ) unfreeze ( self , inplace = False ) inherited Creates a new module with .frozen set to False, equivalent to calling freeze(False) . Parameters: Name Type Description Default inplace bool Whether to update the module inplace. False Returns: Type Description ~M The new module with .frozen set to False, if inplace is True then self is returned. Source code in treex/nn/batch_norm.py def unfreeze ( self : M , inplace : bool = False ) -> M : \"\"\" Creates a new module with `.frozen` set to False, equivalent to calling `freeze(False)`. Arguments: inplace: Whether to update the module inplace. Returns: The new module with `.frozen` set to False, if `inplace` is `True` then `self` is returned. \"\"\" return self . freeze ( False , inplace = inplace )","title":"BatchNorm"},{"location":"api/BatchNorm/#treexbatchnorm","text":"BatchNorm Module. BatchNorm is implemented as a wrapper over flax.linen.BatchNorm , its constructor arguments accept almost the same arguments including any Flax artifacts such as initializers. Main differences: use_running_average is not a constructor argument, but remains a __call__ argument. self.training state is used to indicate how BatchNorm should behave, interally use_running_average = not self.training or self.frozen is used unless use_running_average is explicitly passed via __call__ .","title":"treex.BatchNorm"},{"location":"api/BatchNorm/#treex.nn.batch_norm.BatchNorm.first_run","text":"Returns: Type Description bool True if its currently the first run of a compact method.","title":"first_run"},{"location":"api/BatchNorm/#treex.nn.batch_norm.BatchNorm.__class__","text":"","title":"__class__"},{"location":"api/BatchNorm/#treex.nn.batch_norm.BatchNorm.__class__.__base__","text":"Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()).","title":"__base__"},{"location":"api/BatchNorm/#treex.nn.batch_norm.BatchNorm.__class__.__base__.__instancecheck__","text":"Override for isinstance(instance, cls). Source code in treex/nn/batch_norm.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance )","title":"__instancecheck__()"},{"location":"api/BatchNorm/#treex.nn.batch_norm.BatchNorm.__class__.__base__.__new__","text":"Create and return a new object. See help(type) for accurate signature. Source code in treex/nn/batch_norm.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls","title":"__new__()"},{"location":"api/BatchNorm/#treex.nn.batch_norm.BatchNorm.__class__.__base__.__subclasscheck__","text":"Override for issubclass(subclass, cls). Source code in treex/nn/batch_norm.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass )","title":"__subclasscheck__()"},{"location":"api/BatchNorm/#treex.nn.batch_norm.BatchNorm.__class__.__base__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/batch_norm.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/BatchNorm/#treex.nn.batch_norm.BatchNorm.__class__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/batch_norm.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/BatchNorm/#treex.nn.batch_norm.BatchNorm.__call__","text":"Normalizes the input using batch statistics. Parameters: Name Type Description Default x ndarray the input to be normalized. required use_running_average Optional[bool] if true, the statistics stored in batch_stats will be used instead of computing the batch statistics on the input. None Returns: Type Description ndarray Normalized inputs (the same shape as inputs). Source code in treex/nn/batch_norm.py def __call__ ( self , x : np . ndarray , use_running_average : tp . Optional [ bool ] = None ) -> jnp . ndarray : \"\"\"Normalizes the input using batch statistics. Arguments: x: the input to be normalized. use_running_average: if true, the statistics stored in batch_stats will be used instead of computing the batch statistics on the input. Returns: Normalized inputs (the same shape as inputs). \"\"\" assert self . initialized , \"Module not initialized\" params = {} if self . use_bias : params [ \"bias\" ] = self . bias if self . use_scale : params [ \"scale\" ] = self . scale variables = dict ( batch_stats = dict ( mean = self . mean , var = self . var , ), params = params , ) # use_running_average = True means batch_stats will not be mutated # self.training = True means batch_stats will be mutated training = ( not use_running_average if use_running_average is not None else self . training and not self . frozen ) # call apply output , variables = self . module . apply ( variables , x , mutable = [ \"batch_stats\" ] if training else [], use_running_average = not training , ) variables = variables . unfreeze () # update batch_stats if \"batch_stats\" in variables : self . mean = variables [ \"batch_stats\" ][ \"mean\" ] self . var = variables [ \"batch_stats\" ][ \"var\" ] return tp . cast ( jnp . ndarray , output )","title":"__call__()"},{"location":"api/BatchNorm/#treex.nn.batch_norm.BatchNorm.__init__","text":"Parameters: Name Type Description Default features_in int the number of input features. required axis int the feature or non-batch axis of the input. -1 momentum Union[float, jax._src.numpy.lax_numpy.ndarray] decay rate for the exponential moving average of the batch statistics. 0.99 epsilon float a small float added to variance to avoid dividing by zero. 1e-05 dtype Any the dtype of the computation (default: float32). <class 'jax._src.numpy.lax_numpy.float32'> use_bias bool if True, bias (beta) is added. True use_scale bool if True, multiply by scale (gamma). When the next layer is linear (also e.g. nn.relu), this can be disabled since the scaling will be done by the next layer. True bias_init Callable[[Any, Tuple[int], Any], Any] initializer for bias, by default, zero. <function zeros at 0x7fc07ed80ca0> scale_init Callable[[Any, Tuple[int], Any], Any] initializer for scale, by default, one. <function ones at 0x7fc07ed80dc0> axis_name Optional[str] the axis name used to combine batch statistics from multiple devices. See jax.pmap for a description of axis names (default: None). None axis_index_groups Any groups of axis indices within that named axis representing subsets of devices to reduce over (default: None). For example, [[0, 1], [2, 3]] would independently batch-normalize over the examples on the first two and last two devices. See jax.lax.psum for more details. None Source code in treex/nn/batch_norm.py def __init__ ( self , features_in : int , axis : int = - 1 , momentum : tp . Union [ float , jnp . ndarray ] = 0.99 , epsilon : float = 1e-5 , dtype : flax_module . Dtype = jnp . float32 , use_bias : bool = True , use_scale : bool = True , bias_init : tp . Callable [ [ flax_module . PRNGKey , flax_module . Shape , flax_module . Dtype ], flax_module . Array , ] = flax_module . initializers . zeros , scale_init : tp . Callable [ [ flax_module . PRNGKey , flax_module . Shape , flax_module . Dtype ], flax_module . Array , ] = flax_module . initializers . ones , axis_name : tp . Optional [ str ] = None , axis_index_groups : tp . Any = None , ): \"\"\" Arguments: features_in: the number of input features. axis: the feature or non-batch axis of the input. momentum: decay rate for the exponential moving average of the batch statistics. epsilon: a small float added to variance to avoid dividing by zero. dtype: the dtype of the computation (default: float32). use_bias: if True, bias (beta) is added. use_scale: if True, multiply by scale (gamma). When the next layer is linear (also e.g. nn.relu), this can be disabled since the scaling will be done by the next layer. bias_init: initializer for bias, by default, zero. scale_init: initializer for scale, by default, one. axis_name: the axis name used to combine batch statistics from multiple devices. See `jax.pmap` for a description of axis names (default: None). axis_index_groups: groups of axis indices within that named axis representing subsets of devices to reduce over (default: None). For example, `[[0, 1], [2, 3]]` would independently batch-normalize over the examples on the first two and last two devices. See `jax.lax.psum` for more details. \"\"\" self . features_in = features_in self . axis = axis self . momentum = jnp . asarray ( momentum ) self . epsilon = epsilon self . dtype = dtype self . use_bias = use_bias self . use_scale = use_scale self . bias_init = bias_init self . scale_init = scale_init self . axis_name = axis_name self . axis_index_groups = axis_index_groups self . mean = None self . var = None self . scale = None self . bias = None","title":"__init__()"},{"location":"api/BatchNorm/#treex.nn.batch_norm.BatchNorm.apply","text":"apply is a wrapper over treeo.apply that passes self as the second argument. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treex/nn/batch_norm.py def apply ( self : A , f : tp . Callable [ ... , None ], * rest : A , inplace : bool = False ) -> A : \"\"\" `apply` is a wrapper over `treeo.apply` that passes `self` as the second argument. Arguments: f: The function to apply. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" return api . apply ( f , self , * rest , inplace = inplace )","title":"apply()"},{"location":"api/BatchNorm/#treex.nn.batch_norm.BatchNorm.batch_stats","text":"Returns a copy of the Module with only tx.BatchStat TreeParts, alias for filter(tx.BatchStat) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/batch_norm.py def batch_stats ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.BatchStat TreeParts, alias for `filter(tx.BatchStat)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . BatchStat , * filters )","title":"batch_stats()"},{"location":"api/BatchNorm/#treex.nn.batch_norm.BatchNorm.check_metadata_updates","text":"Checks for new fields, if found, adds them to the metadata. Source code in treex/nn/batch_norm.py def check_metadata_updates ( self ): \"\"\" Checks for new fields, if found, adds them to the metadata. \"\"\" with _CONTEXT . update ( flatten_mode = FlattenMode . all_fields ): jax . tree_flatten ( self )","title":"check_metadata_updates()"},{"location":"api/BatchNorm/#treex.nn.batch_norm.BatchNorm.copy","text":"copy is a wrapper over treeo.copy that passes self as the first argument. Source code in treex/nn/batch_norm.py def copy ( self : A ) -> A : \"\"\" `copy` is a wrapper over `treeo.copy` that passes `self` as the first argument. \"\"\" return tree_m . copy ( self )","title":"copy()"},{"location":"api/BatchNorm/#treex.nn.batch_norm.BatchNorm.eval","text":"Creates a new module with the training mode set to False, equivalent to calling train(False) . Returns: Type Description ~M The new module with the training mode set to False. Source code in treex/nn/batch_norm.py def eval ( self : M , inplace : bool = False ) -> M : \"\"\" Creates a new module with the training mode set to False, equivalent to calling `train(False)`. Returns: The new module with the training mode set to False. \"\"\" return self . train ( False , inplace = inplace )","title":"eval()"},{"location":"api/BatchNorm/#treex.nn.batch_norm.BatchNorm.filter","text":"filter is a wrapper over treeo.filter that passes self as the first argument. Parameters: Name Type Description Default *filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treex/nn/batch_norm.py def filter ( self : A , * filters : api . Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ) -> A : \"\"\" `filter` is a wrapper over `treeo.filter` that passes `self` as the first argument. Arguments: *filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" return api . filter ( self , * filters , inplace = inplace , flatten_mode = flatten_mode )","title":"filter()"},{"location":"api/BatchNorm/#treex.nn.batch_norm.BatchNorm.freeze","text":"Creates a new module with the same structure, but with Module.frozen set to the given value. Parameters: Name Type Description Default mode bool The new frozen mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~M The new module in with the frozen mode is set to the given value, if inplace is True then self is returned. Source code in treex/nn/batch_norm.py def freeze ( self : M , mode : bool = True , inplace : bool = False ) -> M : \"\"\" Creates a new module with the same structure, but with `Module.frozen` set to the given value. Arguments: mode: The new `frozen` mode. inplace: Whether to update the module inplace. Returns: The new module in with the `frozen` mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_frozen ( module : Module ): if isinstance ( module , Module ): module . _frozen = mode return to . apply ( set_frozen , self , inplace = inplace )","title":"freeze()"},{"location":"api/BatchNorm/#treex.nn.batch_norm.BatchNorm.get_field","text":"A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: The field must be declared in the class definition. The method can only be called inside a compact context. Parameters: Name Type Description Default field_name str The name of the field to get. required initializer Callable[[], ~A] The function to initialize the field if it does not exist. required Returns: Type Description ~A The field value. Source code in treex/nn/batch_norm.py def get_field ( self , field_name : str , initializer : tp . Callable [[], A ], ) -> A : \"\"\" A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: * The field must be declared in the class definition. * The method can only be called inside a `compact` context. Arguments: field_name: The name of the field to get. initializer: The function to initialize the field if it does not exist. Returns: The field value. \"\"\" value : A if field_name not in self . _field_metadata : raise ValueError ( f \"Metadata for field ' { field_name } ' does not exist.\" ) if tree_m . _COMPACT_CONTEXT . current_tree is not self : raise RuntimeError ( f \"Object ' { type ( self ) . __name__ } ' is not the current tree, found ' { type ( tree_m . _COMPACT_CONTEXT . current_tree ) . __name__ } ', did you forget the @compact decorator?\" ) if field_name in vars ( self ): value = getattr ( self , field_name ) else : if tree_m . _COMPACT_CONTEXT . in_compact and not self . first_run : raise RuntimeError ( f \"Trying to initialize field ' { field_name } ' after the first run of `compact`.\" ) value = initializer () setattr ( self , field_name , value ) return value","title":"get_field()"},{"location":"api/BatchNorm/#treex.nn.batch_norm.BatchNorm.init","text":"Method version of tx.init , it applies self as first argument. init creates a new module with the same structure, but with its fields initialized given a seed key . The following procedure is used: The input key is split and iteratively updated before passing a derived value to any process that requires initialization. Initializer s are called and applied to the module first. Module.rng_init methods are called last. Parameters: Name Type Description Default key Union[int, jax._src.numpy.lax_numpy.ndarray] The seed to use for initialization. required Returns: Type Description ~M The new module with the fields initialized. Source code in treex/nn/batch_norm.py def init ( self : M , key : tp . Union [ int , jnp . ndarray ], inplace : bool = False ) -> M : \"\"\" Method version of `tx.init`, it applies `self` as first argument. `init` creates a new module with the same structure, but with its fields initialized given a seed `key`. The following procedure is used: 1. The input `key` is split and iteratively updated before passing a derived value to any process that requires initialization. 2. `Initializer`s are called and applied to the module first. 3. `Module.rng_init` methods are called last. Arguments: key: The seed to use for initialization. Returns: The new module with the fields initialized. \"\"\" if isinstance ( key , int ): key = jax . random . PRNGKey ( key ) def next_key () -> jnp . ndarray : nonlocal key assert isinstance ( key , ( np . ndarray , jnp . ndarray )) next_key , key = utils . iter_split ( key ) return next_key tree_out : M = jax . tree_map ( lambda initializer : ( initializer ( next_key ()) if isinstance ( initializer , types . Initializer ) else initializer ), self , is_leaf = lambda x : isinstance ( x , types . Initializer ), ) if inplace : # here we update initialized fields by the above tree_map tree_out = to . merge ( self , tree_out , inplace = True ) def call_module_init ( module : Module ): if isinstance ( module , Module ) and not module . _initialized : module . rng_init ( next_key ()) module . _initialized = True return to . apply ( call_module_init , tree_out , inplace = inplace )","title":"init()"},{"location":"api/BatchNorm/#treex.nn.batch_norm.BatchNorm.logs","text":"Returns a copy of the Module with only tx.Log TreeParts, alias for filter(tx.Log) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/batch_norm.py def logs ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Log TreeParts, alias for `filter(tx.Log)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . Log , * filters )","title":"logs()"},{"location":"api/BatchNorm/#treex.nn.batch_norm.BatchNorm.losses","text":"Returns a copy of the Module with only tx.Loss TreeParts, alias for filter(tx.Loss) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/batch_norm.py def losses ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Loss TreeParts, alias for `filter(tx.Loss)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . LossLog , * filters )","title":"losses()"},{"location":"api/BatchNorm/#treex.nn.batch_norm.BatchNorm.map","text":"map is a wrapper over treeo.map that passes self as the second argument. Parameters: Name Type Description Default f Callable The function to apply to the leaves. required *filters Filter The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treex/nn/batch_norm.py def map ( self : A , f : tp . Callable , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , is_leaf : tp . Callable [[ tp . Any ], bool ] = None , ) -> A : \"\"\" `map` is a wrapper over `treeo.map` that passes `self` as the second argument. Arguments: f: The function to apply to the leaves. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" return api . map ( f , self , * filters , inplace = inplace , flatten_mode = flatten_mode , is_leaf = is_leaf , )","title":"map()"},{"location":"api/BatchNorm/#treex.nn.batch_norm.BatchNorm.merge","text":"merge is a wrapper over treeo.merge that passes self as the first argument. Parameters: Name Type Description Default other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the merged values. If inplace is True , obj is returned. Source code in treex/nn/batch_norm.py def merge ( self : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" `merge` is a wrapper over `treeo.merge` that passes `self` as the first argument. Arguments: other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the merged values. If `inplace` is `True`, `obj` is returned. \"\"\" return api . merge ( self , other , * rest , inplace = inplace , flatten_mode = flatten_mode , ignore_static = ignore_static , )","title":"merge()"},{"location":"api/BatchNorm/#treex.nn.batch_norm.BatchNorm.metrics","text":"Returns a copy of the Module with only tx.Metric TreeParts, alias for filter(tx.Metric) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/batch_norm.py def metrics ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Metric TreeParts, alias for `filter(tx.Metric)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . MetricLog , * filters )","title":"metrics()"},{"location":"api/BatchNorm/#treex.nn.batch_norm.BatchNorm.model_states","text":"Returns a copy of the Module with only tx.ModelState TreeParts, alias for filter(tx.ModelState) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/batch_norm.py def model_states ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.ModelState TreeParts, alias for `filter(tx.ModelState)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . ModelState , * filters )","title":"model_states()"},{"location":"api/BatchNorm/#treex.nn.batch_norm.BatchNorm.parameters","text":"Returns a copy of the Module with only tx.Parameter TreeParts, alias for filter(tx.Parameter) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/batch_norm.py def parameters ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Parameter TreeParts, alias for `filter(tx.Parameter)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . Parameter , * filters )","title":"parameters()"},{"location":"api/BatchNorm/#treex.nn.batch_norm.BatchNorm.rngs","text":"Returns a copy of the Module with only tx.Rng TreeParts, alias for filter(tx.Rng) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/batch_norm.py def rngs ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Rng TreeParts, alias for `filter(tx.Rng)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . Rng , * filters )","title":"rngs()"},{"location":"api/BatchNorm/#treex.nn.batch_norm.BatchNorm.states","text":"Returns a copy of the Module with only tx.State TreeParts, alias for filter(tx.State) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/batch_norm.py def states ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.State TreeParts, alias for `filter(tx.State)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . State , * filters )","title":"states()"},{"location":"api/BatchNorm/#treex.nn.batch_norm.BatchNorm.tabulate","text":"Returns a tabular representation of the module. Parameters: Name Type Description Default depth int The maximum depth of the representation in terms of nested Modules, -1 means no limit. -1 signature bool Whether to show the signature of the Module. False param_types bool Whether to show the types of the parameters. True Returns: Type Description str A string containing the tabular representation. Source code in treex/nn/batch_norm.py def tabulate ( self , inputs : tp . Union [ tp . Any , types . Inputs , None ] = None , depth : int = - 1 , signature : bool = False , param_types : bool = True , ) -> str : \"\"\" Returns a tabular representation of the module. Arguments: depth: The maximum depth of the representation in terms of nested Modules, -1 means no limit. signature: Whether to show the signature of the Module. param_types: Whether to show the types of the parameters. Returns: A string containing the tabular representation. \"\"\" self = to . copy ( self ) if inputs is not None : if not isinstance ( inputs , types . Inputs ): inputs = types . Inputs ( inputs ) inputs = tp . cast ( types . Inputs , inputs ) if not isinstance ( self , tp . Callable ): raise TypeError ( \"`inputs` can only be specified if the module is a callable.\" ) with _Context ( call_info = {}): # call using self to preserve references def eval_call ( args , kwargs ): assert isinstance ( self , tp . Callable ) return self ( * args , ** kwargs ) jax . eval_shape ( eval_call , inputs . args , inputs . kwargs , ) call_info = _CONTEXT . call_info else : call_info = None with to . add_field_info (): flat : tp . List [ to . FieldInfo ] flat , _ = jax . tree_flatten ( self ) tree_part_types : tp . Tuple [ tp . Type [ types . TreePart ], ... ] = tuple ( { field_info . kind for field_info in flat if utils . _generic_issubclass ( field_info . kind , types . TreePart ) } ) path = () rows = list ( utils . _get_tabulate_rows ( path , self , depth , tree_part_types , signature , param_types ) ) modules = [ row [ 0 ] for row in rows ] rows = [ row [ 1 :] for row in rows ] if call_info is not None : for module , row in zip ( modules , rows ): if module in call_info : inputs , outputs = call_info [ module ] simplified_inputs = ( inputs . args [ 0 ] if len ( inputs . kwargs ) == 0 and len ( inputs . args ) == 1 else inputs . kwargs if len ( inputs . kwargs ) == 0 else inputs . kwargs if len ( inputs . args ) == 0 else ( inputs . args , inputs . kwargs ) ) inputs_repr = utils . _format_param_tree ( simplified_inputs ) outputs_repr = utils . _format_param_tree ( outputs ) else : inputs_repr = \"\" outputs_repr = \"\" row . insert ( 3 , outputs_repr ) row . insert ( 3 , inputs_repr ) n_non_treepart_cols = 2 if call_info is None else 4 rows [ 0 ][ 0 ] = \"*\" rows . append ( [ \"\" ] * n_non_treepart_cols + [ \"Total:\" ] + [ utils . _format_obj_size ( self . filter ( kind ), add_padding = True ) for kind in tree_part_types ] ) utils . _add_padding ( rows ) table = Table ( show_header = True , show_lines = True , show_footer = True , # box=rich.box.HORIZONTALS, ) table . add_column ( \"path\" ) table . add_column ( \"module\" ) table . add_column ( \"params\" ) if call_info is not None : table . add_column ( \"inputs\" ) table . add_column ( \"outputs\" ) for tree_part_type in tree_part_types : type_name = tree_part_type . __name__ if type_name . startswith ( \"_\" ): type_name = type_name [ 1 :] table . add_column ( type_name ) for row in rows [: - 1 ]: table . add_row ( * row ) table . columns [ n_non_treepart_cols ] . footer = Text . from_markup ( rows [ - 1 ][ n_non_treepart_cols ], justify = \"right\" ) for i in range ( len ( tree_part_types )): table . columns [ n_non_treepart_cols + 1 + i ] . footer = rows [ - 1 ][ n_non_treepart_cols + 1 + i ] table . caption_style = \"bold\" table . caption = \" \\n Total Parameters: \" + utils . _format_obj_size ( self , add_padding = False ) return utils . _get_rich_repr ( table )","title":"tabulate()"},{"location":"api/BatchNorm/#treex.nn.batch_norm.BatchNorm.to_dict","text":"to_dict is a wrapper over treeo.to_dict that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True type_info bool If True , type information is included. False field_info bool If True , field information is included. False Returns: Type Description Any A dict representation of the object. Source code in treex/nn/batch_norm.py def to_dict ( self , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : \"\"\" `to_dict` is a wrapper over `treeo.to_dict` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. type_info: If `True`, type information is included. field_info: If `True`, field information is included. Returns: A dict representation of the object. \"\"\" return api . to_dict ( self , private_fields = private_fields , static_fields = static_fields , type_info = type_info , field_info = field_info , )","title":"to_dict()"},{"location":"api/BatchNorm/#treex.nn.batch_norm.BatchNorm.to_string","text":"to_string is a wrapper over treeo.to_string that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True color bool If True , color is included. False Returns: Type Description str A string representation of the object. Source code in treex/nn/batch_norm.py def to_string ( self : A , * , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" `to_string` is a wrapper over `treeo.to_string` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. color: If `True`, color is included. Returns: A string representation of the object. \"\"\" return api . to_string ( self , private_fields = private_fields , static_fields = static_fields , color = color , )","title":"to_string()"},{"location":"api/BatchNorm/#treex.nn.batch_norm.BatchNorm.train","text":"Creates a new module with the same structure, but with Module.training set to the given value. Parameters: Name Type Description Default mode bool The new training mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~M The new module in with the training mode is set to the given value, if inplace is True then self is returned. Source code in treex/nn/batch_norm.py def train ( self : M , mode : bool = True , inplace : bool = False ) -> M : \"\"\" Creates a new module with the same structure, but with `Module.training` set to the given value. Arguments: mode: The new training mode. inplace: Whether to update the module inplace. Returns: The new module in with the training mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_training ( module : Module ): if isinstance ( module , Module ): module . _training = mode return to . apply ( set_training , self , inplace = inplace )","title":"train()"},{"location":"api/BatchNorm/#treex.nn.batch_norm.BatchNorm.unfreeze","text":"Creates a new module with .frozen set to False, equivalent to calling freeze(False) . Parameters: Name Type Description Default inplace bool Whether to update the module inplace. False Returns: Type Description ~M The new module with .frozen set to False, if inplace is True then self is returned. Source code in treex/nn/batch_norm.py def unfreeze ( self : M , inplace : bool = False ) -> M : \"\"\" Creates a new module with `.frozen` set to False, equivalent to calling `freeze(False)`. Arguments: inplace: Whether to update the module inplace. Returns: The new module with `.frozen` set to False, if `inplace` is `True` then `self` is returned. \"\"\" return self . freeze ( False , inplace = inplace )","title":"unfreeze()"},{"location":"api/BatchStat/","text":"treex.BatchStat","title":"BatchStat"},{"location":"api/BatchStat/#treexbatchstat","text":"","title":"treex.BatchStat"},{"location":"api/Cache/","text":"treex.Cache","title":"Cache"},{"location":"api/Cache/#treexcache","text":"","title":"treex.Cache"},{"location":"api/Compact/","text":"treex.Compact first_run : bool property readonly Returns: Type Description bool True if its currently the first run of a compact method. get_field ( self , field_name , initializer ) A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: The field must be declared in the class definition. The method can only be called inside a compact context. Parameters: Name Type Description Default field_name str The name of the field to get. required initializer Callable[[], ~A] The function to initialize the field if it does not exist. required Returns: Type Description ~A The field value. Source code in treeo/mixins.py def get_field ( self , field_name : str , initializer : tp . Callable [[], A ], ) -> A : \"\"\" A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: * The field must be declared in the class definition. * The method can only be called inside a `compact` context. Arguments: field_name: The name of the field to get. initializer: The function to initialize the field if it does not exist. Returns: The field value. \"\"\" value : A if field_name not in self . _field_metadata : raise ValueError ( f \"Metadata for field ' { field_name } ' does not exist.\" ) if tree_m . _COMPACT_CONTEXT . current_tree is not self : raise RuntimeError ( f \"Object ' { type ( self ) . __name__ } ' is not the current tree, found ' { type ( tree_m . _COMPACT_CONTEXT . current_tree ) . __name__ } ', did you forget the @compact decorator?\" ) if field_name in vars ( self ): value = getattr ( self , field_name ) else : if tree_m . _COMPACT_CONTEXT . in_compact and not self . first_run : raise RuntimeError ( f \"Trying to initialize field ' { field_name } ' after the first run of `compact`.\" ) value = initializer () setattr ( self , field_name , value ) return value","title":"Compact"},{"location":"api/Compact/#treexcompact","text":"","title":"treex.Compact"},{"location":"api/Compact/#treeo.mixins.Compact.first_run","text":"Returns: Type Description bool True if its currently the first run of a compact method.","title":"first_run"},{"location":"api/Compact/#treeo.mixins.Compact.get_field","text":"A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: The field must be declared in the class definition. The method can only be called inside a compact context. Parameters: Name Type Description Default field_name str The name of the field to get. required initializer Callable[[], ~A] The function to initialize the field if it does not exist. required Returns: Type Description ~A The field value. Source code in treeo/mixins.py def get_field ( self , field_name : str , initializer : tp . Callable [[], A ], ) -> A : \"\"\" A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: * The field must be declared in the class definition. * The method can only be called inside a `compact` context. Arguments: field_name: The name of the field to get. initializer: The function to initialize the field if it does not exist. Returns: The field value. \"\"\" value : A if field_name not in self . _field_metadata : raise ValueError ( f \"Metadata for field ' { field_name } ' does not exist.\" ) if tree_m . _COMPACT_CONTEXT . current_tree is not self : raise RuntimeError ( f \"Object ' { type ( self ) . __name__ } ' is not the current tree, found ' { type ( tree_m . _COMPACT_CONTEXT . current_tree ) . __name__ } ', did you forget the @compact decorator?\" ) if field_name in vars ( self ): value = getattr ( self , field_name ) else : if tree_m . _COMPACT_CONTEXT . in_compact and not self . first_run : raise RuntimeError ( f \"Trying to initialize field ' { field_name } ' after the first run of `compact`.\" ) value = initializer () setattr ( self , field_name , value ) return value","title":"get_field()"},{"location":"api/Conv/","text":"treex.Conv Convolution Module wrapping lax.conv_general_dilated. Conv is implemented as a wrapper over flax.linen.Conv , its constructor arguments accept almost the same arguments including any Flax artifacts such as initializers. Main differences: receives features_in as a first argument since shapes must be statically known. features argument is renamed to features_out . first_run : bool inherited property readonly Returns: Type Description bool True if its currently the first run of a compact method. __class__ inherited __base__ inherited Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()). __instancecheck__ ( cls , instance ) special Override for isinstance(instance, cls). Source code in treex/nn/conv.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance ) __new__ ( mcls , name , bases , namespace , ** kwargs ) special staticmethod Create and return a new object. See help(type) for accurate signature. Source code in treex/nn/conv.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls __subclasscheck__ ( cls , subclass ) special Override for issubclass(subclass, cls). Source code in treex/nn/conv.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass ) register ( cls , subclass ) Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/conv.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) register ( cls , subclass ) inherited Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/conv.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) __call__ ( self , x ) special Applies a convolution to the inputs. Parameters: Name Type Description Default x ndarray input data with dimensions (batch, spatial_dims..., features). required Returns: Type Description ndarray The convolved data. Source code in treex/nn/conv.py def __call__ ( self , x : np . ndarray ) -> jnp . ndarray : \"\"\"Applies a convolution to the inputs. Arguments: x: input data with dimensions (batch, spatial_dims..., features). Returns: The convolved data. \"\"\" assert self . initialized , \"Module not initialized\" params = dict ( kernel = self . kernel ) if self . use_bias : params [ \"bias\" ] = self . bias output = self . module . apply ( dict ( params = params ), x ) return tp . cast ( jnp . ndarray , output ) __init__ ( self , features_in , features_out , kernel_size , strides = None , padding = 'SAME' , input_dilation = None , kernel_dilation = None , feature_group_count = 1 , use_bias = True , dtype =< class ' jax . _src . numpy . lax_numpy . float32 '>, precision=None, kernel_init=<function variance_scaling.<locals>.init at 0x7fc075c2ed30>, bias_init=<function zeros at 0x7fc07ed80ca0>) special Parameters: Name Type Description Default features_in int the number of input features. required features_out int number of convolution filters. required kernel_size Union[int, Iterable[int]] shape of the convolutional kernel. For 1D convolution, the kernel size can be passed as an integer. For all other cases, it must be a sequence of integers. required strides Optional[Iterable[int]] a sequence of n integers, representing the inter-window strides. None padding Union[str, Iterable[Tuple[int, int]]] either the string 'SAME' , the string 'VALID' , or a sequence of n (low, high) integer pairs that give the padding to apply before and after each spatial dimension. 'SAME' input_dilation Optional[Iterable[int]] None , or a sequence of n integers, giving the dilation factor to apply in each spatial dimension of inputs . Convolution with input dilation d is equivalent to transposed convolution with stride d . None kernel_dilation Optional[Iterable[int]] None , or a sequence of n integers, giving the dilation factor to apply in each spatial dimension of the convolution kernel. Convolution with kernel dilation is also known as 'atrous convolution'. None feature_group_count int integer, default 1. If specified divides the input features into groups. 1 use_bias bool whether to add a bias to the output (default: True). True dtype Any the dtype of the computation (default: float32). <class 'jax._src.numpy.lax_numpy.float32'> precision Any numerical precision of the computation see jax.lax.Precision for details. None kernel_init Callable[[Any, Iterable[int], Any], Any] initializer for the convolutional kernel. <function variance_scaling.<locals>.init at 0x7fc075c2ed30> bias_init Callable[[Any, Iterable[int], Any], Any] initializer for the bias. <function zeros at 0x7fc07ed80ca0> Source code in treex/nn/conv.py def __init__ ( self , features_in : int , features_out : int , kernel_size : tp . Union [ int , tp . Iterable [ int ]], strides : tp . Optional [ tp . Iterable [ int ]] = None , padding : tp . Union [ str , tp . Iterable [ tp . Tuple [ int , int ]]] = \"SAME\" , input_dilation : tp . Optional [ tp . Iterable [ int ]] = None , kernel_dilation : tp . Optional [ tp . Iterable [ int ]] = None , feature_group_count : int = 1 , use_bias : bool = True , dtype : flax_module . Dtype = jnp . float32 , precision : tp . Any = None , kernel_init : tp . Callable [ [ flax_module . PRNGKey , flax_module . Shape , flax_module . Dtype ], flax_module . Array , ] = flax_module . default_kernel_init , bias_init : tp . Callable [ [ flax_module . PRNGKey , flax_module . Shape , flax_module . Dtype ], flax_module . Array , ] = flax_module . zeros , ): \"\"\" Arguments: features_in: the number of input features. features_out: number of convolution filters. kernel_size: shape of the convolutional kernel. For 1D convolution, the kernel size can be passed as an integer. For all other cases, it must be a sequence of integers. strides: a sequence of `n` integers, representing the inter-window strides. padding: either the string `'SAME'`, the string `'VALID'`, or a sequence of `n` `(low, high)` integer pairs that give the padding to apply before and after each spatial dimension. input_dilation: `None`, or a sequence of `n` integers, giving the dilation factor to apply in each spatial dimension of `inputs`. Convolution with input dilation `d` is equivalent to transposed convolution with stride `d`. kernel_dilation: `None`, or a sequence of `n` integers, giving the dilation factor to apply in each spatial dimension of the convolution kernel. Convolution with kernel dilation is also known as 'atrous convolution'. feature_group_count: integer, default 1. If specified divides the input features into groups. use_bias: whether to add a bias to the output (default: True). dtype: the dtype of the computation (default: float32). precision: numerical precision of the computation see `jax.lax.Precision` for details. kernel_init: initializer for the convolutional kernel. bias_init: initializer for the bias. \"\"\" self . features_in = features_in self . features_out = features_out self . kernel_size = kernel_size self . strides = strides self . padding = padding self . input_dilation = input_dilation self . kernel_dilation = kernel_dilation self . feature_group_count = feature_group_count self . use_bias = use_bias self . dtype = dtype self . precision = precision self . kernel_init = kernel_init self . bias_init = bias_init self . kernel = None self . bias = None apply ( self , f , * rest , * , inplace = False ) inherited apply is a wrapper over treeo.apply that passes self as the second argument. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treex/nn/conv.py def apply ( self : A , f : tp . Callable [ ... , None ], * rest : A , inplace : bool = False ) -> A : \"\"\" `apply` is a wrapper over `treeo.apply` that passes `self` as the second argument. Arguments: f: The function to apply. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" return api . apply ( f , self , * rest , inplace = inplace ) batch_stats ( self , * filters ) inherited Returns a copy of the Module with only tx.BatchStat TreeParts, alias for filter(tx.BatchStat) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/conv.py def batch_stats ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.BatchStat TreeParts, alias for `filter(tx.BatchStat)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . BatchStat , * filters ) check_metadata_updates ( self ) inherited Checks for new fields, if found, adds them to the metadata. Source code in treex/nn/conv.py def check_metadata_updates ( self ): \"\"\" Checks for new fields, if found, adds them to the metadata. \"\"\" with _CONTEXT . update ( flatten_mode = FlattenMode . all_fields ): jax . tree_flatten ( self ) copy ( self ) inherited copy is a wrapper over treeo.copy that passes self as the first argument. Source code in treex/nn/conv.py def copy ( self : A ) -> A : \"\"\" `copy` is a wrapper over `treeo.copy` that passes `self` as the first argument. \"\"\" return tree_m . copy ( self ) eval ( self , inplace = False ) inherited Creates a new module with the training mode set to False, equivalent to calling train(False) . Returns: Type Description ~M The new module with the training mode set to False. Source code in treex/nn/conv.py def eval ( self : M , inplace : bool = False ) -> M : \"\"\" Creates a new module with the training mode set to False, equivalent to calling `train(False)`. Returns: The new module with the training mode set to False. \"\"\" return self . train ( False , inplace = inplace ) filter ( self , * filters , * , inplace = False , flatten_mode = None ) inherited filter is a wrapper over treeo.filter that passes self as the first argument. Parameters: Name Type Description Default *filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treex/nn/conv.py def filter ( self : A , * filters : api . Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ) -> A : \"\"\" `filter` is a wrapper over `treeo.filter` that passes `self` as the first argument. Arguments: *filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" return api . filter ( self , * filters , inplace = inplace , flatten_mode = flatten_mode ) freeze ( self , mode = True , inplace = False ) inherited Creates a new module with the same structure, but with Module.frozen set to the given value. Parameters: Name Type Description Default mode bool The new frozen mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~M The new module in with the frozen mode is set to the given value, if inplace is True then self is returned. Source code in treex/nn/conv.py def freeze ( self : M , mode : bool = True , inplace : bool = False ) -> M : \"\"\" Creates a new module with the same structure, but with `Module.frozen` set to the given value. Arguments: mode: The new `frozen` mode. inplace: Whether to update the module inplace. Returns: The new module in with the `frozen` mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_frozen ( module : Module ): if isinstance ( module , Module ): module . _frozen = mode return to . apply ( set_frozen , self , inplace = inplace ) get_field ( self , field_name , initializer ) inherited A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: The field must be declared in the class definition. The method can only be called inside a compact context. Parameters: Name Type Description Default field_name str The name of the field to get. required initializer Callable[[], ~A] The function to initialize the field if it does not exist. required Returns: Type Description ~A The field value. Source code in treex/nn/conv.py def get_field ( self , field_name : str , initializer : tp . Callable [[], A ], ) -> A : \"\"\" A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: * The field must be declared in the class definition. * The method can only be called inside a `compact` context. Arguments: field_name: The name of the field to get. initializer: The function to initialize the field if it does not exist. Returns: The field value. \"\"\" value : A if field_name not in self . _field_metadata : raise ValueError ( f \"Metadata for field ' { field_name } ' does not exist.\" ) if tree_m . _COMPACT_CONTEXT . current_tree is not self : raise RuntimeError ( f \"Object ' { type ( self ) . __name__ } ' is not the current tree, found ' { type ( tree_m . _COMPACT_CONTEXT . current_tree ) . __name__ } ', did you forget the @compact decorator?\" ) if field_name in vars ( self ): value = getattr ( self , field_name ) else : if tree_m . _COMPACT_CONTEXT . in_compact and not self . first_run : raise RuntimeError ( f \"Trying to initialize field ' { field_name } ' after the first run of `compact`.\" ) value = initializer () setattr ( self , field_name , value ) return value init ( self , key , inplace = False ) inherited Method version of tx.init , it applies self as first argument. init creates a new module with the same structure, but with its fields initialized given a seed key . The following procedure is used: The input key is split and iteratively updated before passing a derived value to any process that requires initialization. Initializer s are called and applied to the module first. Module.rng_init methods are called last. Parameters: Name Type Description Default key Union[int, jax._src.numpy.lax_numpy.ndarray] The seed to use for initialization. required Returns: Type Description ~M The new module with the fields initialized. Source code in treex/nn/conv.py def init ( self : M , key : tp . Union [ int , jnp . ndarray ], inplace : bool = False ) -> M : \"\"\" Method version of `tx.init`, it applies `self` as first argument. `init` creates a new module with the same structure, but with its fields initialized given a seed `key`. The following procedure is used: 1. The input `key` is split and iteratively updated before passing a derived value to any process that requires initialization. 2. `Initializer`s are called and applied to the module first. 3. `Module.rng_init` methods are called last. Arguments: key: The seed to use for initialization. Returns: The new module with the fields initialized. \"\"\" if isinstance ( key , int ): key = jax . random . PRNGKey ( key ) def next_key () -> jnp . ndarray : nonlocal key assert isinstance ( key , ( np . ndarray , jnp . ndarray )) next_key , key = utils . iter_split ( key ) return next_key tree_out : M = jax . tree_map ( lambda initializer : ( initializer ( next_key ()) if isinstance ( initializer , types . Initializer ) else initializer ), self , is_leaf = lambda x : isinstance ( x , types . Initializer ), ) if inplace : # here we update initialized fields by the above tree_map tree_out = to . merge ( self , tree_out , inplace = True ) def call_module_init ( module : Module ): if isinstance ( module , Module ) and not module . _initialized : module . rng_init ( next_key ()) module . _initialized = True return to . apply ( call_module_init , tree_out , inplace = inplace ) logs ( self , * filters ) inherited Returns a copy of the Module with only tx.Log TreeParts, alias for filter(tx.Log) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/conv.py def logs ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Log TreeParts, alias for `filter(tx.Log)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . Log , * filters ) losses ( self , * filters ) inherited Returns a copy of the Module with only tx.Loss TreeParts, alias for filter(tx.Loss) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/conv.py def losses ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Loss TreeParts, alias for `filter(tx.Loss)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . LossLog , * filters ) map ( self , f , * filters , * , inplace = False , flatten_mode = None , is_leaf = None ) inherited map is a wrapper over treeo.map that passes self as the second argument. Parameters: Name Type Description Default f Callable The function to apply to the leaves. required *filters Filter The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treex/nn/conv.py def map ( self : A , f : tp . Callable , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , is_leaf : tp . Callable [[ tp . Any ], bool ] = None , ) -> A : \"\"\" `map` is a wrapper over `treeo.map` that passes `self` as the second argument. Arguments: f: The function to apply to the leaves. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" return api . map ( f , self , * filters , inplace = inplace , flatten_mode = flatten_mode , is_leaf = is_leaf , ) merge ( self , other , * rest , * , inplace = False , flatten_mode = None , ignore_static = False ) inherited merge is a wrapper over treeo.merge that passes self as the first argument. Parameters: Name Type Description Default other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the merged values. If inplace is True , obj is returned. Source code in treex/nn/conv.py def merge ( self : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" `merge` is a wrapper over `treeo.merge` that passes `self` as the first argument. Arguments: other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the merged values. If `inplace` is `True`, `obj` is returned. \"\"\" return api . merge ( self , other , * rest , inplace = inplace , flatten_mode = flatten_mode , ignore_static = ignore_static , ) metrics ( self , * filters ) inherited Returns a copy of the Module with only tx.Metric TreeParts, alias for filter(tx.Metric) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/conv.py def metrics ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Metric TreeParts, alias for `filter(tx.Metric)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . MetricLog , * filters ) model_states ( self , * filters ) inherited Returns a copy of the Module with only tx.ModelState TreeParts, alias for filter(tx.ModelState) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/conv.py def model_states ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.ModelState TreeParts, alias for `filter(tx.ModelState)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . ModelState , * filters ) parameters ( self , * filters ) inherited Returns a copy of the Module with only tx.Parameter TreeParts, alias for filter(tx.Parameter) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/conv.py def parameters ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Parameter TreeParts, alias for `filter(tx.Parameter)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . Parameter , * filters ) rngs ( self , * filters ) inherited Returns a copy of the Module with only tx.Rng TreeParts, alias for filter(tx.Rng) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/conv.py def rngs ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Rng TreeParts, alias for `filter(tx.Rng)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . Rng , * filters ) states ( self , * filters ) inherited Returns a copy of the Module with only tx.State TreeParts, alias for filter(tx.State) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/conv.py def states ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.State TreeParts, alias for `filter(tx.State)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . State , * filters ) tabulate ( self , inputs = None , depth =- 1 , signature = False , param_types = True ) inherited Returns a tabular representation of the module. Parameters: Name Type Description Default depth int The maximum depth of the representation in terms of nested Modules, -1 means no limit. -1 signature bool Whether to show the signature of the Module. False param_types bool Whether to show the types of the parameters. True Returns: Type Description str A string containing the tabular representation. Source code in treex/nn/conv.py def tabulate ( self , inputs : tp . Union [ tp . Any , types . Inputs , None ] = None , depth : int = - 1 , signature : bool = False , param_types : bool = True , ) -> str : \"\"\" Returns a tabular representation of the module. Arguments: depth: The maximum depth of the representation in terms of nested Modules, -1 means no limit. signature: Whether to show the signature of the Module. param_types: Whether to show the types of the parameters. Returns: A string containing the tabular representation. \"\"\" self = to . copy ( self ) if inputs is not None : if not isinstance ( inputs , types . Inputs ): inputs = types . Inputs ( inputs ) inputs = tp . cast ( types . Inputs , inputs ) if not isinstance ( self , tp . Callable ): raise TypeError ( \"`inputs` can only be specified if the module is a callable.\" ) with _Context ( call_info = {}): # call using self to preserve references def eval_call ( args , kwargs ): assert isinstance ( self , tp . Callable ) return self ( * args , ** kwargs ) jax . eval_shape ( eval_call , inputs . args , inputs . kwargs , ) call_info = _CONTEXT . call_info else : call_info = None with to . add_field_info (): flat : tp . List [ to . FieldInfo ] flat , _ = jax . tree_flatten ( self ) tree_part_types : tp . Tuple [ tp . Type [ types . TreePart ], ... ] = tuple ( { field_info . kind for field_info in flat if utils . _generic_issubclass ( field_info . kind , types . TreePart ) } ) path = () rows = list ( utils . _get_tabulate_rows ( path , self , depth , tree_part_types , signature , param_types ) ) modules = [ row [ 0 ] for row in rows ] rows = [ row [ 1 :] for row in rows ] if call_info is not None : for module , row in zip ( modules , rows ): if module in call_info : inputs , outputs = call_info [ module ] simplified_inputs = ( inputs . args [ 0 ] if len ( inputs . kwargs ) == 0 and len ( inputs . args ) == 1 else inputs . kwargs if len ( inputs . kwargs ) == 0 else inputs . kwargs if len ( inputs . args ) == 0 else ( inputs . args , inputs . kwargs ) ) inputs_repr = utils . _format_param_tree ( simplified_inputs ) outputs_repr = utils . _format_param_tree ( outputs ) else : inputs_repr = \"\" outputs_repr = \"\" row . insert ( 3 , outputs_repr ) row . insert ( 3 , inputs_repr ) n_non_treepart_cols = 2 if call_info is None else 4 rows [ 0 ][ 0 ] = \"*\" rows . append ( [ \"\" ] * n_non_treepart_cols + [ \"Total:\" ] + [ utils . _format_obj_size ( self . filter ( kind ), add_padding = True ) for kind in tree_part_types ] ) utils . _add_padding ( rows ) table = Table ( show_header = True , show_lines = True , show_footer = True , # box=rich.box.HORIZONTALS, ) table . add_column ( \"path\" ) table . add_column ( \"module\" ) table . add_column ( \"params\" ) if call_info is not None : table . add_column ( \"inputs\" ) table . add_column ( \"outputs\" ) for tree_part_type in tree_part_types : type_name = tree_part_type . __name__ if type_name . startswith ( \"_\" ): type_name = type_name [ 1 :] table . add_column ( type_name ) for row in rows [: - 1 ]: table . add_row ( * row ) table . columns [ n_non_treepart_cols ] . footer = Text . from_markup ( rows [ - 1 ][ n_non_treepart_cols ], justify = \"right\" ) for i in range ( len ( tree_part_types )): table . columns [ n_non_treepart_cols + 1 + i ] . footer = rows [ - 1 ][ n_non_treepart_cols + 1 + i ] table . caption_style = \"bold\" table . caption = \" \\n Total Parameters: \" + utils . _format_obj_size ( self , add_padding = False ) return utils . _get_rich_repr ( table ) to_dict ( self , * , private_fields = False , static_fields = True , type_info = False , field_info = False ) inherited to_dict is a wrapper over treeo.to_dict that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True type_info bool If True , type information is included. False field_info bool If True , field information is included. False Returns: Type Description Any A dict representation of the object. Source code in treex/nn/conv.py def to_dict ( self , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : \"\"\" `to_dict` is a wrapper over `treeo.to_dict` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. type_info: If `True`, type information is included. field_info: If `True`, field information is included. Returns: A dict representation of the object. \"\"\" return api . to_dict ( self , private_fields = private_fields , static_fields = static_fields , type_info = type_info , field_info = field_info , ) to_string ( self , * , private_fields = False , static_fields = True , color = False ) inherited to_string is a wrapper over treeo.to_string that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True color bool If True , color is included. False Returns: Type Description str A string representation of the object. Source code in treex/nn/conv.py def to_string ( self : A , * , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" `to_string` is a wrapper over `treeo.to_string` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. color: If `True`, color is included. Returns: A string representation of the object. \"\"\" return api . to_string ( self , private_fields = private_fields , static_fields = static_fields , color = color , ) train ( self , mode = True , inplace = False ) inherited Creates a new module with the same structure, but with Module.training set to the given value. Parameters: Name Type Description Default mode bool The new training mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~M The new module in with the training mode is set to the given value, if inplace is True then self is returned. Source code in treex/nn/conv.py def train ( self : M , mode : bool = True , inplace : bool = False ) -> M : \"\"\" Creates a new module with the same structure, but with `Module.training` set to the given value. Arguments: mode: The new training mode. inplace: Whether to update the module inplace. Returns: The new module in with the training mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_training ( module : Module ): if isinstance ( module , Module ): module . _training = mode return to . apply ( set_training , self , inplace = inplace ) unfreeze ( self , inplace = False ) inherited Creates a new module with .frozen set to False, equivalent to calling freeze(False) . Parameters: Name Type Description Default inplace bool Whether to update the module inplace. False Returns: Type Description ~M The new module with .frozen set to False, if inplace is True then self is returned. Source code in treex/nn/conv.py def unfreeze ( self : M , inplace : bool = False ) -> M : \"\"\" Creates a new module with `.frozen` set to False, equivalent to calling `freeze(False)`. Arguments: inplace: Whether to update the module inplace. Returns: The new module with `.frozen` set to False, if `inplace` is `True` then `self` is returned. \"\"\" return self . freeze ( False , inplace = inplace )","title":"Conv"},{"location":"api/Conv/#treexconv","text":"Convolution Module wrapping lax.conv_general_dilated. Conv is implemented as a wrapper over flax.linen.Conv , its constructor arguments accept almost the same arguments including any Flax artifacts such as initializers. Main differences: receives features_in as a first argument since shapes must be statically known. features argument is renamed to features_out .","title":"treex.Conv"},{"location":"api/Conv/#treex.nn.conv.Conv.first_run","text":"Returns: Type Description bool True if its currently the first run of a compact method.","title":"first_run"},{"location":"api/Conv/#treex.nn.conv.Conv.__class__","text":"","title":"__class__"},{"location":"api/Conv/#treex.nn.conv.Conv.__class__.__base__","text":"Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()).","title":"__base__"},{"location":"api/Conv/#treex.nn.conv.Conv.__class__.__base__.__instancecheck__","text":"Override for isinstance(instance, cls). Source code in treex/nn/conv.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance )","title":"__instancecheck__()"},{"location":"api/Conv/#treex.nn.conv.Conv.__class__.__base__.__new__","text":"Create and return a new object. See help(type) for accurate signature. Source code in treex/nn/conv.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls","title":"__new__()"},{"location":"api/Conv/#treex.nn.conv.Conv.__class__.__base__.__subclasscheck__","text":"Override for issubclass(subclass, cls). Source code in treex/nn/conv.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass )","title":"__subclasscheck__()"},{"location":"api/Conv/#treex.nn.conv.Conv.__class__.__base__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/conv.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/Conv/#treex.nn.conv.Conv.__class__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/conv.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/Conv/#treex.nn.conv.Conv.__call__","text":"Applies a convolution to the inputs. Parameters: Name Type Description Default x ndarray input data with dimensions (batch, spatial_dims..., features). required Returns: Type Description ndarray The convolved data. Source code in treex/nn/conv.py def __call__ ( self , x : np . ndarray ) -> jnp . ndarray : \"\"\"Applies a convolution to the inputs. Arguments: x: input data with dimensions (batch, spatial_dims..., features). Returns: The convolved data. \"\"\" assert self . initialized , \"Module not initialized\" params = dict ( kernel = self . kernel ) if self . use_bias : params [ \"bias\" ] = self . bias output = self . module . apply ( dict ( params = params ), x ) return tp . cast ( jnp . ndarray , output )","title":"__call__()"},{"location":"api/Conv/#treex.nn.conv.Conv.__init__","text":"Parameters: Name Type Description Default features_in int the number of input features. required features_out int number of convolution filters. required kernel_size Union[int, Iterable[int]] shape of the convolutional kernel. For 1D convolution, the kernel size can be passed as an integer. For all other cases, it must be a sequence of integers. required strides Optional[Iterable[int]] a sequence of n integers, representing the inter-window strides. None padding Union[str, Iterable[Tuple[int, int]]] either the string 'SAME' , the string 'VALID' , or a sequence of n (low, high) integer pairs that give the padding to apply before and after each spatial dimension. 'SAME' input_dilation Optional[Iterable[int]] None , or a sequence of n integers, giving the dilation factor to apply in each spatial dimension of inputs . Convolution with input dilation d is equivalent to transposed convolution with stride d . None kernel_dilation Optional[Iterable[int]] None , or a sequence of n integers, giving the dilation factor to apply in each spatial dimension of the convolution kernel. Convolution with kernel dilation is also known as 'atrous convolution'. None feature_group_count int integer, default 1. If specified divides the input features into groups. 1 use_bias bool whether to add a bias to the output (default: True). True dtype Any the dtype of the computation (default: float32). <class 'jax._src.numpy.lax_numpy.float32'> precision Any numerical precision of the computation see jax.lax.Precision for details. None kernel_init Callable[[Any, Iterable[int], Any], Any] initializer for the convolutional kernel. <function variance_scaling.<locals>.init at 0x7fc075c2ed30> bias_init Callable[[Any, Iterable[int], Any], Any] initializer for the bias. <function zeros at 0x7fc07ed80ca0> Source code in treex/nn/conv.py def __init__ ( self , features_in : int , features_out : int , kernel_size : tp . Union [ int , tp . Iterable [ int ]], strides : tp . Optional [ tp . Iterable [ int ]] = None , padding : tp . Union [ str , tp . Iterable [ tp . Tuple [ int , int ]]] = \"SAME\" , input_dilation : tp . Optional [ tp . Iterable [ int ]] = None , kernel_dilation : tp . Optional [ tp . Iterable [ int ]] = None , feature_group_count : int = 1 , use_bias : bool = True , dtype : flax_module . Dtype = jnp . float32 , precision : tp . Any = None , kernel_init : tp . Callable [ [ flax_module . PRNGKey , flax_module . Shape , flax_module . Dtype ], flax_module . Array , ] = flax_module . default_kernel_init , bias_init : tp . Callable [ [ flax_module . PRNGKey , flax_module . Shape , flax_module . Dtype ], flax_module . Array , ] = flax_module . zeros , ): \"\"\" Arguments: features_in: the number of input features. features_out: number of convolution filters. kernel_size: shape of the convolutional kernel. For 1D convolution, the kernel size can be passed as an integer. For all other cases, it must be a sequence of integers. strides: a sequence of `n` integers, representing the inter-window strides. padding: either the string `'SAME'`, the string `'VALID'`, or a sequence of `n` `(low, high)` integer pairs that give the padding to apply before and after each spatial dimension. input_dilation: `None`, or a sequence of `n` integers, giving the dilation factor to apply in each spatial dimension of `inputs`. Convolution with input dilation `d` is equivalent to transposed convolution with stride `d`. kernel_dilation: `None`, or a sequence of `n` integers, giving the dilation factor to apply in each spatial dimension of the convolution kernel. Convolution with kernel dilation is also known as 'atrous convolution'. feature_group_count: integer, default 1. If specified divides the input features into groups. use_bias: whether to add a bias to the output (default: True). dtype: the dtype of the computation (default: float32). precision: numerical precision of the computation see `jax.lax.Precision` for details. kernel_init: initializer for the convolutional kernel. bias_init: initializer for the bias. \"\"\" self . features_in = features_in self . features_out = features_out self . kernel_size = kernel_size self . strides = strides self . padding = padding self . input_dilation = input_dilation self . kernel_dilation = kernel_dilation self . feature_group_count = feature_group_count self . use_bias = use_bias self . dtype = dtype self . precision = precision self . kernel_init = kernel_init self . bias_init = bias_init self . kernel = None self . bias = None","title":"__init__()"},{"location":"api/Conv/#treex.nn.conv.Conv.apply","text":"apply is a wrapper over treeo.apply that passes self as the second argument. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treex/nn/conv.py def apply ( self : A , f : tp . Callable [ ... , None ], * rest : A , inplace : bool = False ) -> A : \"\"\" `apply` is a wrapper over `treeo.apply` that passes `self` as the second argument. Arguments: f: The function to apply. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" return api . apply ( f , self , * rest , inplace = inplace )","title":"apply()"},{"location":"api/Conv/#treex.nn.conv.Conv.batch_stats","text":"Returns a copy of the Module with only tx.BatchStat TreeParts, alias for filter(tx.BatchStat) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/conv.py def batch_stats ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.BatchStat TreeParts, alias for `filter(tx.BatchStat)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . BatchStat , * filters )","title":"batch_stats()"},{"location":"api/Conv/#treex.nn.conv.Conv.check_metadata_updates","text":"Checks for new fields, if found, adds them to the metadata. Source code in treex/nn/conv.py def check_metadata_updates ( self ): \"\"\" Checks for new fields, if found, adds them to the metadata. \"\"\" with _CONTEXT . update ( flatten_mode = FlattenMode . all_fields ): jax . tree_flatten ( self )","title":"check_metadata_updates()"},{"location":"api/Conv/#treex.nn.conv.Conv.copy","text":"copy is a wrapper over treeo.copy that passes self as the first argument. Source code in treex/nn/conv.py def copy ( self : A ) -> A : \"\"\" `copy` is a wrapper over `treeo.copy` that passes `self` as the first argument. \"\"\" return tree_m . copy ( self )","title":"copy()"},{"location":"api/Conv/#treex.nn.conv.Conv.eval","text":"Creates a new module with the training mode set to False, equivalent to calling train(False) . Returns: Type Description ~M The new module with the training mode set to False. Source code in treex/nn/conv.py def eval ( self : M , inplace : bool = False ) -> M : \"\"\" Creates a new module with the training mode set to False, equivalent to calling `train(False)`. Returns: The new module with the training mode set to False. \"\"\" return self . train ( False , inplace = inplace )","title":"eval()"},{"location":"api/Conv/#treex.nn.conv.Conv.filter","text":"filter is a wrapper over treeo.filter that passes self as the first argument. Parameters: Name Type Description Default *filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treex/nn/conv.py def filter ( self : A , * filters : api . Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ) -> A : \"\"\" `filter` is a wrapper over `treeo.filter` that passes `self` as the first argument. Arguments: *filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" return api . filter ( self , * filters , inplace = inplace , flatten_mode = flatten_mode )","title":"filter()"},{"location":"api/Conv/#treex.nn.conv.Conv.freeze","text":"Creates a new module with the same structure, but with Module.frozen set to the given value. Parameters: Name Type Description Default mode bool The new frozen mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~M The new module in with the frozen mode is set to the given value, if inplace is True then self is returned. Source code in treex/nn/conv.py def freeze ( self : M , mode : bool = True , inplace : bool = False ) -> M : \"\"\" Creates a new module with the same structure, but with `Module.frozen` set to the given value. Arguments: mode: The new `frozen` mode. inplace: Whether to update the module inplace. Returns: The new module in with the `frozen` mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_frozen ( module : Module ): if isinstance ( module , Module ): module . _frozen = mode return to . apply ( set_frozen , self , inplace = inplace )","title":"freeze()"},{"location":"api/Conv/#treex.nn.conv.Conv.get_field","text":"A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: The field must be declared in the class definition. The method can only be called inside a compact context. Parameters: Name Type Description Default field_name str The name of the field to get. required initializer Callable[[], ~A] The function to initialize the field if it does not exist. required Returns: Type Description ~A The field value. Source code in treex/nn/conv.py def get_field ( self , field_name : str , initializer : tp . Callable [[], A ], ) -> A : \"\"\" A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: * The field must be declared in the class definition. * The method can only be called inside a `compact` context. Arguments: field_name: The name of the field to get. initializer: The function to initialize the field if it does not exist. Returns: The field value. \"\"\" value : A if field_name not in self . _field_metadata : raise ValueError ( f \"Metadata for field ' { field_name } ' does not exist.\" ) if tree_m . _COMPACT_CONTEXT . current_tree is not self : raise RuntimeError ( f \"Object ' { type ( self ) . __name__ } ' is not the current tree, found ' { type ( tree_m . _COMPACT_CONTEXT . current_tree ) . __name__ } ', did you forget the @compact decorator?\" ) if field_name in vars ( self ): value = getattr ( self , field_name ) else : if tree_m . _COMPACT_CONTEXT . in_compact and not self . first_run : raise RuntimeError ( f \"Trying to initialize field ' { field_name } ' after the first run of `compact`.\" ) value = initializer () setattr ( self , field_name , value ) return value","title":"get_field()"},{"location":"api/Conv/#treex.nn.conv.Conv.init","text":"Method version of tx.init , it applies self as first argument. init creates a new module with the same structure, but with its fields initialized given a seed key . The following procedure is used: The input key is split and iteratively updated before passing a derived value to any process that requires initialization. Initializer s are called and applied to the module first. Module.rng_init methods are called last. Parameters: Name Type Description Default key Union[int, jax._src.numpy.lax_numpy.ndarray] The seed to use for initialization. required Returns: Type Description ~M The new module with the fields initialized. Source code in treex/nn/conv.py def init ( self : M , key : tp . Union [ int , jnp . ndarray ], inplace : bool = False ) -> M : \"\"\" Method version of `tx.init`, it applies `self` as first argument. `init` creates a new module with the same structure, but with its fields initialized given a seed `key`. The following procedure is used: 1. The input `key` is split and iteratively updated before passing a derived value to any process that requires initialization. 2. `Initializer`s are called and applied to the module first. 3. `Module.rng_init` methods are called last. Arguments: key: The seed to use for initialization. Returns: The new module with the fields initialized. \"\"\" if isinstance ( key , int ): key = jax . random . PRNGKey ( key ) def next_key () -> jnp . ndarray : nonlocal key assert isinstance ( key , ( np . ndarray , jnp . ndarray )) next_key , key = utils . iter_split ( key ) return next_key tree_out : M = jax . tree_map ( lambda initializer : ( initializer ( next_key ()) if isinstance ( initializer , types . Initializer ) else initializer ), self , is_leaf = lambda x : isinstance ( x , types . Initializer ), ) if inplace : # here we update initialized fields by the above tree_map tree_out = to . merge ( self , tree_out , inplace = True ) def call_module_init ( module : Module ): if isinstance ( module , Module ) and not module . _initialized : module . rng_init ( next_key ()) module . _initialized = True return to . apply ( call_module_init , tree_out , inplace = inplace )","title":"init()"},{"location":"api/Conv/#treex.nn.conv.Conv.logs","text":"Returns a copy of the Module with only tx.Log TreeParts, alias for filter(tx.Log) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/conv.py def logs ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Log TreeParts, alias for `filter(tx.Log)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . Log , * filters )","title":"logs()"},{"location":"api/Conv/#treex.nn.conv.Conv.losses","text":"Returns a copy of the Module with only tx.Loss TreeParts, alias for filter(tx.Loss) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/conv.py def losses ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Loss TreeParts, alias for `filter(tx.Loss)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . LossLog , * filters )","title":"losses()"},{"location":"api/Conv/#treex.nn.conv.Conv.map","text":"map is a wrapper over treeo.map that passes self as the second argument. Parameters: Name Type Description Default f Callable The function to apply to the leaves. required *filters Filter The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treex/nn/conv.py def map ( self : A , f : tp . Callable , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , is_leaf : tp . Callable [[ tp . Any ], bool ] = None , ) -> A : \"\"\" `map` is a wrapper over `treeo.map` that passes `self` as the second argument. Arguments: f: The function to apply to the leaves. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" return api . map ( f , self , * filters , inplace = inplace , flatten_mode = flatten_mode , is_leaf = is_leaf , )","title":"map()"},{"location":"api/Conv/#treex.nn.conv.Conv.merge","text":"merge is a wrapper over treeo.merge that passes self as the first argument. Parameters: Name Type Description Default other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the merged values. If inplace is True , obj is returned. Source code in treex/nn/conv.py def merge ( self : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" `merge` is a wrapper over `treeo.merge` that passes `self` as the first argument. Arguments: other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the merged values. If `inplace` is `True`, `obj` is returned. \"\"\" return api . merge ( self , other , * rest , inplace = inplace , flatten_mode = flatten_mode , ignore_static = ignore_static , )","title":"merge()"},{"location":"api/Conv/#treex.nn.conv.Conv.metrics","text":"Returns a copy of the Module with only tx.Metric TreeParts, alias for filter(tx.Metric) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/conv.py def metrics ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Metric TreeParts, alias for `filter(tx.Metric)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . MetricLog , * filters )","title":"metrics()"},{"location":"api/Conv/#treex.nn.conv.Conv.model_states","text":"Returns a copy of the Module with only tx.ModelState TreeParts, alias for filter(tx.ModelState) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/conv.py def model_states ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.ModelState TreeParts, alias for `filter(tx.ModelState)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . ModelState , * filters )","title":"model_states()"},{"location":"api/Conv/#treex.nn.conv.Conv.parameters","text":"Returns a copy of the Module with only tx.Parameter TreeParts, alias for filter(tx.Parameter) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/conv.py def parameters ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Parameter TreeParts, alias for `filter(tx.Parameter)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . Parameter , * filters )","title":"parameters()"},{"location":"api/Conv/#treex.nn.conv.Conv.rngs","text":"Returns a copy of the Module with only tx.Rng TreeParts, alias for filter(tx.Rng) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/conv.py def rngs ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Rng TreeParts, alias for `filter(tx.Rng)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . Rng , * filters )","title":"rngs()"},{"location":"api/Conv/#treex.nn.conv.Conv.states","text":"Returns a copy of the Module with only tx.State TreeParts, alias for filter(tx.State) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/conv.py def states ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.State TreeParts, alias for `filter(tx.State)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . State , * filters )","title":"states()"},{"location":"api/Conv/#treex.nn.conv.Conv.tabulate","text":"Returns a tabular representation of the module. Parameters: Name Type Description Default depth int The maximum depth of the representation in terms of nested Modules, -1 means no limit. -1 signature bool Whether to show the signature of the Module. False param_types bool Whether to show the types of the parameters. True Returns: Type Description str A string containing the tabular representation. Source code in treex/nn/conv.py def tabulate ( self , inputs : tp . Union [ tp . Any , types . Inputs , None ] = None , depth : int = - 1 , signature : bool = False , param_types : bool = True , ) -> str : \"\"\" Returns a tabular representation of the module. Arguments: depth: The maximum depth of the representation in terms of nested Modules, -1 means no limit. signature: Whether to show the signature of the Module. param_types: Whether to show the types of the parameters. Returns: A string containing the tabular representation. \"\"\" self = to . copy ( self ) if inputs is not None : if not isinstance ( inputs , types . Inputs ): inputs = types . Inputs ( inputs ) inputs = tp . cast ( types . Inputs , inputs ) if not isinstance ( self , tp . Callable ): raise TypeError ( \"`inputs` can only be specified if the module is a callable.\" ) with _Context ( call_info = {}): # call using self to preserve references def eval_call ( args , kwargs ): assert isinstance ( self , tp . Callable ) return self ( * args , ** kwargs ) jax . eval_shape ( eval_call , inputs . args , inputs . kwargs , ) call_info = _CONTEXT . call_info else : call_info = None with to . add_field_info (): flat : tp . List [ to . FieldInfo ] flat , _ = jax . tree_flatten ( self ) tree_part_types : tp . Tuple [ tp . Type [ types . TreePart ], ... ] = tuple ( { field_info . kind for field_info in flat if utils . _generic_issubclass ( field_info . kind , types . TreePart ) } ) path = () rows = list ( utils . _get_tabulate_rows ( path , self , depth , tree_part_types , signature , param_types ) ) modules = [ row [ 0 ] for row in rows ] rows = [ row [ 1 :] for row in rows ] if call_info is not None : for module , row in zip ( modules , rows ): if module in call_info : inputs , outputs = call_info [ module ] simplified_inputs = ( inputs . args [ 0 ] if len ( inputs . kwargs ) == 0 and len ( inputs . args ) == 1 else inputs . kwargs if len ( inputs . kwargs ) == 0 else inputs . kwargs if len ( inputs . args ) == 0 else ( inputs . args , inputs . kwargs ) ) inputs_repr = utils . _format_param_tree ( simplified_inputs ) outputs_repr = utils . _format_param_tree ( outputs ) else : inputs_repr = \"\" outputs_repr = \"\" row . insert ( 3 , outputs_repr ) row . insert ( 3 , inputs_repr ) n_non_treepart_cols = 2 if call_info is None else 4 rows [ 0 ][ 0 ] = \"*\" rows . append ( [ \"\" ] * n_non_treepart_cols + [ \"Total:\" ] + [ utils . _format_obj_size ( self . filter ( kind ), add_padding = True ) for kind in tree_part_types ] ) utils . _add_padding ( rows ) table = Table ( show_header = True , show_lines = True , show_footer = True , # box=rich.box.HORIZONTALS, ) table . add_column ( \"path\" ) table . add_column ( \"module\" ) table . add_column ( \"params\" ) if call_info is not None : table . add_column ( \"inputs\" ) table . add_column ( \"outputs\" ) for tree_part_type in tree_part_types : type_name = tree_part_type . __name__ if type_name . startswith ( \"_\" ): type_name = type_name [ 1 :] table . add_column ( type_name ) for row in rows [: - 1 ]: table . add_row ( * row ) table . columns [ n_non_treepart_cols ] . footer = Text . from_markup ( rows [ - 1 ][ n_non_treepart_cols ], justify = \"right\" ) for i in range ( len ( tree_part_types )): table . columns [ n_non_treepart_cols + 1 + i ] . footer = rows [ - 1 ][ n_non_treepart_cols + 1 + i ] table . caption_style = \"bold\" table . caption = \" \\n Total Parameters: \" + utils . _format_obj_size ( self , add_padding = False ) return utils . _get_rich_repr ( table )","title":"tabulate()"},{"location":"api/Conv/#treex.nn.conv.Conv.to_dict","text":"to_dict is a wrapper over treeo.to_dict that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True type_info bool If True , type information is included. False field_info bool If True , field information is included. False Returns: Type Description Any A dict representation of the object. Source code in treex/nn/conv.py def to_dict ( self , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : \"\"\" `to_dict` is a wrapper over `treeo.to_dict` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. type_info: If `True`, type information is included. field_info: If `True`, field information is included. Returns: A dict representation of the object. \"\"\" return api . to_dict ( self , private_fields = private_fields , static_fields = static_fields , type_info = type_info , field_info = field_info , )","title":"to_dict()"},{"location":"api/Conv/#treex.nn.conv.Conv.to_string","text":"to_string is a wrapper over treeo.to_string that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True color bool If True , color is included. False Returns: Type Description str A string representation of the object. Source code in treex/nn/conv.py def to_string ( self : A , * , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" `to_string` is a wrapper over `treeo.to_string` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. color: If `True`, color is included. Returns: A string representation of the object. \"\"\" return api . to_string ( self , private_fields = private_fields , static_fields = static_fields , color = color , )","title":"to_string()"},{"location":"api/Conv/#treex.nn.conv.Conv.train","text":"Creates a new module with the same structure, but with Module.training set to the given value. Parameters: Name Type Description Default mode bool The new training mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~M The new module in with the training mode is set to the given value, if inplace is True then self is returned. Source code in treex/nn/conv.py def train ( self : M , mode : bool = True , inplace : bool = False ) -> M : \"\"\" Creates a new module with the same structure, but with `Module.training` set to the given value. Arguments: mode: The new training mode. inplace: Whether to update the module inplace. Returns: The new module in with the training mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_training ( module : Module ): if isinstance ( module , Module ): module . _training = mode return to . apply ( set_training , self , inplace = inplace )","title":"train()"},{"location":"api/Conv/#treex.nn.conv.Conv.unfreeze","text":"Creates a new module with .frozen set to False, equivalent to calling freeze(False) . Parameters: Name Type Description Default inplace bool Whether to update the module inplace. False Returns: Type Description ~M The new module with .frozen set to False, if inplace is True then self is returned. Source code in treex/nn/conv.py def unfreeze ( self : M , inplace : bool = False ) -> M : \"\"\" Creates a new module with `.frozen` set to False, equivalent to calling `freeze(False)`. Arguments: inplace: Whether to update the module inplace. Returns: The new module with `.frozen` set to False, if `inplace` is `True` then `self` is returned. \"\"\" return self . freeze ( False , inplace = inplace )","title":"unfreeze()"},{"location":"api/Copy/","text":"treex.Copy Mixin that adds a .copy() method to the class. copy ( self ) copy is a wrapper over treeo.copy that passes self as the first argument. Source code in treeo/mixins.py def copy ( self : A ) -> A : \"\"\" `copy` is a wrapper over `treeo.copy` that passes `self` as the first argument. \"\"\" return tree_m . copy ( self )","title":"Copy"},{"location":"api/Copy/#treexcopy","text":"Mixin that adds a .copy() method to the class.","title":"treex.Copy"},{"location":"api/Copy/#treeo.mixins.Copy.copy","text":"copy is a wrapper over treeo.copy that passes self as the first argument. Source code in treeo/mixins.py def copy ( self : A ) -> A : \"\"\" `copy` is a wrapper over `treeo.copy` that passes `self` as the first argument. \"\"\" return tree_m . copy ( self )","title":"copy()"},{"location":"api/Dropout/","text":"treex.Dropout Create a dropout layer. Dropout is implemented as a wrapper over flax.linen.Dropout , its constructor arguments accept almost the same arguments including any Flax artifacts such as initializers. Main differences: deterministic is not a constructor argument, but remains a __call__ argument. self.training state is used to indicate how Dropout should behave, interally deterministic = not self.training or self.frozen is used unless deterministic is explicitly passed via __call__ . Dropout maintains an rng: Rng state which is used to generate random masks unless rng is passed via __call__ . first_run : bool inherited property readonly Returns: Type Description bool True if its currently the first run of a compact method. __class__ inherited __base__ inherited Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()). __instancecheck__ ( cls , instance ) special Override for isinstance(instance, cls). Source code in treex/nn/dropout.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance ) __new__ ( mcls , name , bases , namespace , ** kwargs ) special staticmethod Create and return a new object. See help(type) for accurate signature. Source code in treex/nn/dropout.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls __subclasscheck__ ( cls , subclass ) special Override for issubclass(subclass, cls). Source code in treex/nn/dropout.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass ) register ( cls , subclass ) Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/dropout.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) register ( cls , subclass ) inherited Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/dropout.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) __call__ ( self , x , deterministic = None , rng = None ) special Applies a random dropout mask to the input. Parameters: Name Type Description Default x ndarray the inputs that should be randomly masked. required deterministic Optional[bool] if false the inputs are scaled by 1 / (1 - rate) and masked, whereas if true, no mask is applied and the inputs are returned as is. None rng an optional jax.random.PRNGKey . By default self.rng will be used. None Returns: Type Description ndarray The masked inputs reweighted to preserve mean. Source code in treex/nn/dropout.py def __call__ ( self , x : np . ndarray , deterministic : tp . Optional [ bool ] = None , rng = None ) -> jnp . ndarray : \"\"\"Applies a random dropout mask to the input. Arguments: x: the inputs that should be randomly masked. deterministic: if false the inputs are scaled by `1 / (1 - rate)` and masked, whereas if true, no mask is applied and the inputs are returned as is. rng: an optional `jax.random.PRNGKey`. By default `self.rng` will be used. Returns: The masked inputs reweighted to preserve mean. \"\"\" variables = dict () training = ( not deterministic if deterministic is not None else self . training and not self . frozen ) if rng is None : rng = self . next_key () if training else self . next_key . key # call apply output = self . module . apply ( variables , x , deterministic = not training , rng = rng , ) return tp . cast ( jnp . ndarray , output ) __init__ ( self , rate , broadcast_dims = ()) special Create a dropout layer. Parameters: Name Type Description Default rate float the dropout probability. ( not the keep rate!) required broadcast_dims Iterable[int] dimensions that will share the same dropout mask () Source code in treex/nn/dropout.py def __init__ ( self , rate : float , broadcast_dims : tp . Iterable [ int ] = (), ): \"\"\" Create a dropout layer. Arguments: rate: the dropout probability. (_not_ the keep rate!) broadcast_dims: dimensions that will share the same dropout mask \"\"\" self . rate = rate self . broadcast_dims = broadcast_dims self . next_key = KeySeq () apply ( self , f , * rest , * , inplace = False ) inherited apply is a wrapper over treeo.apply that passes self as the second argument. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treex/nn/dropout.py def apply ( self : A , f : tp . Callable [ ... , None ], * rest : A , inplace : bool = False ) -> A : \"\"\" `apply` is a wrapper over `treeo.apply` that passes `self` as the second argument. Arguments: f: The function to apply. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" return api . apply ( f , self , * rest , inplace = inplace ) batch_stats ( self , * filters ) inherited Returns a copy of the Module with only tx.BatchStat TreeParts, alias for filter(tx.BatchStat) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/dropout.py def batch_stats ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.BatchStat TreeParts, alias for `filter(tx.BatchStat)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . BatchStat , * filters ) check_metadata_updates ( self ) inherited Checks for new fields, if found, adds them to the metadata. Source code in treex/nn/dropout.py def check_metadata_updates ( self ): \"\"\" Checks for new fields, if found, adds them to the metadata. \"\"\" with _CONTEXT . update ( flatten_mode = FlattenMode . all_fields ): jax . tree_flatten ( self ) copy ( self ) inherited copy is a wrapper over treeo.copy that passes self as the first argument. Source code in treex/nn/dropout.py def copy ( self : A ) -> A : \"\"\" `copy` is a wrapper over `treeo.copy` that passes `self` as the first argument. \"\"\" return tree_m . copy ( self ) eval ( self , inplace = False ) inherited Creates a new module with the training mode set to False, equivalent to calling train(False) . Returns: Type Description ~M The new module with the training mode set to False. Source code in treex/nn/dropout.py def eval ( self : M , inplace : bool = False ) -> M : \"\"\" Creates a new module with the training mode set to False, equivalent to calling `train(False)`. Returns: The new module with the training mode set to False. \"\"\" return self . train ( False , inplace = inplace ) filter ( self , * filters , * , inplace = False , flatten_mode = None ) inherited filter is a wrapper over treeo.filter that passes self as the first argument. Parameters: Name Type Description Default *filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treex/nn/dropout.py def filter ( self : A , * filters : api . Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ) -> A : \"\"\" `filter` is a wrapper over `treeo.filter` that passes `self` as the first argument. Arguments: *filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" return api . filter ( self , * filters , inplace = inplace , flatten_mode = flatten_mode ) freeze ( self , mode = True , inplace = False ) inherited Creates a new module with the same structure, but with Module.frozen set to the given value. Parameters: Name Type Description Default mode bool The new frozen mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~M The new module in with the frozen mode is set to the given value, if inplace is True then self is returned. Source code in treex/nn/dropout.py def freeze ( self : M , mode : bool = True , inplace : bool = False ) -> M : \"\"\" Creates a new module with the same structure, but with `Module.frozen` set to the given value. Arguments: mode: The new `frozen` mode. inplace: Whether to update the module inplace. Returns: The new module in with the `frozen` mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_frozen ( module : Module ): if isinstance ( module , Module ): module . _frozen = mode return to . apply ( set_frozen , self , inplace = inplace ) get_field ( self , field_name , initializer ) inherited A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: The field must be declared in the class definition. The method can only be called inside a compact context. Parameters: Name Type Description Default field_name str The name of the field to get. required initializer Callable[[], ~A] The function to initialize the field if it does not exist. required Returns: Type Description ~A The field value. Source code in treex/nn/dropout.py def get_field ( self , field_name : str , initializer : tp . Callable [[], A ], ) -> A : \"\"\" A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: * The field must be declared in the class definition. * The method can only be called inside a `compact` context. Arguments: field_name: The name of the field to get. initializer: The function to initialize the field if it does not exist. Returns: The field value. \"\"\" value : A if field_name not in self . _field_metadata : raise ValueError ( f \"Metadata for field ' { field_name } ' does not exist.\" ) if tree_m . _COMPACT_CONTEXT . current_tree is not self : raise RuntimeError ( f \"Object ' { type ( self ) . __name__ } ' is not the current tree, found ' { type ( tree_m . _COMPACT_CONTEXT . current_tree ) . __name__ } ', did you forget the @compact decorator?\" ) if field_name in vars ( self ): value = getattr ( self , field_name ) else : if tree_m . _COMPACT_CONTEXT . in_compact and not self . first_run : raise RuntimeError ( f \"Trying to initialize field ' { field_name } ' after the first run of `compact`.\" ) value = initializer () setattr ( self , field_name , value ) return value init ( self , key , inplace = False ) inherited Method version of tx.init , it applies self as first argument. init creates a new module with the same structure, but with its fields initialized given a seed key . The following procedure is used: The input key is split and iteratively updated before passing a derived value to any process that requires initialization. Initializer s are called and applied to the module first. Module.rng_init methods are called last. Parameters: Name Type Description Default key Union[int, jax._src.numpy.lax_numpy.ndarray] The seed to use for initialization. required Returns: Type Description ~M The new module with the fields initialized. Source code in treex/nn/dropout.py def init ( self : M , key : tp . Union [ int , jnp . ndarray ], inplace : bool = False ) -> M : \"\"\" Method version of `tx.init`, it applies `self` as first argument. `init` creates a new module with the same structure, but with its fields initialized given a seed `key`. The following procedure is used: 1. The input `key` is split and iteratively updated before passing a derived value to any process that requires initialization. 2. `Initializer`s are called and applied to the module first. 3. `Module.rng_init` methods are called last. Arguments: key: The seed to use for initialization. Returns: The new module with the fields initialized. \"\"\" if isinstance ( key , int ): key = jax . random . PRNGKey ( key ) def next_key () -> jnp . ndarray : nonlocal key assert isinstance ( key , ( np . ndarray , jnp . ndarray )) next_key , key = utils . iter_split ( key ) return next_key tree_out : M = jax . tree_map ( lambda initializer : ( initializer ( next_key ()) if isinstance ( initializer , types . Initializer ) else initializer ), self , is_leaf = lambda x : isinstance ( x , types . Initializer ), ) if inplace : # here we update initialized fields by the above tree_map tree_out = to . merge ( self , tree_out , inplace = True ) def call_module_init ( module : Module ): if isinstance ( module , Module ) and not module . _initialized : module . rng_init ( next_key ()) module . _initialized = True return to . apply ( call_module_init , tree_out , inplace = inplace ) logs ( self , * filters ) inherited Returns a copy of the Module with only tx.Log TreeParts, alias for filter(tx.Log) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/dropout.py def logs ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Log TreeParts, alias for `filter(tx.Log)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . Log , * filters ) losses ( self , * filters ) inherited Returns a copy of the Module with only tx.Loss TreeParts, alias for filter(tx.Loss) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/dropout.py def losses ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Loss TreeParts, alias for `filter(tx.Loss)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . LossLog , * filters ) map ( self , f , * filters , * , inplace = False , flatten_mode = None , is_leaf = None ) inherited map is a wrapper over treeo.map that passes self as the second argument. Parameters: Name Type Description Default f Callable The function to apply to the leaves. required *filters Filter The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treex/nn/dropout.py def map ( self : A , f : tp . Callable , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , is_leaf : tp . Callable [[ tp . Any ], bool ] = None , ) -> A : \"\"\" `map` is a wrapper over `treeo.map` that passes `self` as the second argument. Arguments: f: The function to apply to the leaves. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" return api . map ( f , self , * filters , inplace = inplace , flatten_mode = flatten_mode , is_leaf = is_leaf , ) merge ( self , other , * rest , * , inplace = False , flatten_mode = None , ignore_static = False ) inherited merge is a wrapper over treeo.merge that passes self as the first argument. Parameters: Name Type Description Default other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the merged values. If inplace is True , obj is returned. Source code in treex/nn/dropout.py def merge ( self : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" `merge` is a wrapper over `treeo.merge` that passes `self` as the first argument. Arguments: other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the merged values. If `inplace` is `True`, `obj` is returned. \"\"\" return api . merge ( self , other , * rest , inplace = inplace , flatten_mode = flatten_mode , ignore_static = ignore_static , ) metrics ( self , * filters ) inherited Returns a copy of the Module with only tx.Metric TreeParts, alias for filter(tx.Metric) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/dropout.py def metrics ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Metric TreeParts, alias for `filter(tx.Metric)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . MetricLog , * filters ) model_states ( self , * filters ) inherited Returns a copy of the Module with only tx.ModelState TreeParts, alias for filter(tx.ModelState) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/dropout.py def model_states ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.ModelState TreeParts, alias for `filter(tx.ModelState)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . ModelState , * filters ) parameters ( self , * filters ) inherited Returns a copy of the Module with only tx.Parameter TreeParts, alias for filter(tx.Parameter) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/dropout.py def parameters ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Parameter TreeParts, alias for `filter(tx.Parameter)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . Parameter , * filters ) rngs ( self , * filters ) inherited Returns a copy of the Module with only tx.Rng TreeParts, alias for filter(tx.Rng) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/dropout.py def rngs ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Rng TreeParts, alias for `filter(tx.Rng)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . Rng , * filters ) states ( self , * filters ) inherited Returns a copy of the Module with only tx.State TreeParts, alias for filter(tx.State) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/dropout.py def states ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.State TreeParts, alias for `filter(tx.State)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . State , * filters ) tabulate ( self , inputs = None , depth =- 1 , signature = False , param_types = True ) inherited Returns a tabular representation of the module. Parameters: Name Type Description Default depth int The maximum depth of the representation in terms of nested Modules, -1 means no limit. -1 signature bool Whether to show the signature of the Module. False param_types bool Whether to show the types of the parameters. True Returns: Type Description str A string containing the tabular representation. Source code in treex/nn/dropout.py def tabulate ( self , inputs : tp . Union [ tp . Any , types . Inputs , None ] = None , depth : int = - 1 , signature : bool = False , param_types : bool = True , ) -> str : \"\"\" Returns a tabular representation of the module. Arguments: depth: The maximum depth of the representation in terms of nested Modules, -1 means no limit. signature: Whether to show the signature of the Module. param_types: Whether to show the types of the parameters. Returns: A string containing the tabular representation. \"\"\" self = to . copy ( self ) if inputs is not None : if not isinstance ( inputs , types . Inputs ): inputs = types . Inputs ( inputs ) inputs = tp . cast ( types . Inputs , inputs ) if not isinstance ( self , tp . Callable ): raise TypeError ( \"`inputs` can only be specified if the module is a callable.\" ) with _Context ( call_info = {}): # call using self to preserve references def eval_call ( args , kwargs ): assert isinstance ( self , tp . Callable ) return self ( * args , ** kwargs ) jax . eval_shape ( eval_call , inputs . args , inputs . kwargs , ) call_info = _CONTEXT . call_info else : call_info = None with to . add_field_info (): flat : tp . List [ to . FieldInfo ] flat , _ = jax . tree_flatten ( self ) tree_part_types : tp . Tuple [ tp . Type [ types . TreePart ], ... ] = tuple ( { field_info . kind for field_info in flat if utils . _generic_issubclass ( field_info . kind , types . TreePart ) } ) path = () rows = list ( utils . _get_tabulate_rows ( path , self , depth , tree_part_types , signature , param_types ) ) modules = [ row [ 0 ] for row in rows ] rows = [ row [ 1 :] for row in rows ] if call_info is not None : for module , row in zip ( modules , rows ): if module in call_info : inputs , outputs = call_info [ module ] simplified_inputs = ( inputs . args [ 0 ] if len ( inputs . kwargs ) == 0 and len ( inputs . args ) == 1 else inputs . kwargs if len ( inputs . kwargs ) == 0 else inputs . kwargs if len ( inputs . args ) == 0 else ( inputs . args , inputs . kwargs ) ) inputs_repr = utils . _format_param_tree ( simplified_inputs ) outputs_repr = utils . _format_param_tree ( outputs ) else : inputs_repr = \"\" outputs_repr = \"\" row . insert ( 3 , outputs_repr ) row . insert ( 3 , inputs_repr ) n_non_treepart_cols = 2 if call_info is None else 4 rows [ 0 ][ 0 ] = \"*\" rows . append ( [ \"\" ] * n_non_treepart_cols + [ \"Total:\" ] + [ utils . _format_obj_size ( self . filter ( kind ), add_padding = True ) for kind in tree_part_types ] ) utils . _add_padding ( rows ) table = Table ( show_header = True , show_lines = True , show_footer = True , # box=rich.box.HORIZONTALS, ) table . add_column ( \"path\" ) table . add_column ( \"module\" ) table . add_column ( \"params\" ) if call_info is not None : table . add_column ( \"inputs\" ) table . add_column ( \"outputs\" ) for tree_part_type in tree_part_types : type_name = tree_part_type . __name__ if type_name . startswith ( \"_\" ): type_name = type_name [ 1 :] table . add_column ( type_name ) for row in rows [: - 1 ]: table . add_row ( * row ) table . columns [ n_non_treepart_cols ] . footer = Text . from_markup ( rows [ - 1 ][ n_non_treepart_cols ], justify = \"right\" ) for i in range ( len ( tree_part_types )): table . columns [ n_non_treepart_cols + 1 + i ] . footer = rows [ - 1 ][ n_non_treepart_cols + 1 + i ] table . caption_style = \"bold\" table . caption = \" \\n Total Parameters: \" + utils . _format_obj_size ( self , add_padding = False ) return utils . _get_rich_repr ( table ) to_dict ( self , * , private_fields = False , static_fields = True , type_info = False , field_info = False ) inherited to_dict is a wrapper over treeo.to_dict that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True type_info bool If True , type information is included. False field_info bool If True , field information is included. False Returns: Type Description Any A dict representation of the object. Source code in treex/nn/dropout.py def to_dict ( self , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : \"\"\" `to_dict` is a wrapper over `treeo.to_dict` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. type_info: If `True`, type information is included. field_info: If `True`, field information is included. Returns: A dict representation of the object. \"\"\" return api . to_dict ( self , private_fields = private_fields , static_fields = static_fields , type_info = type_info , field_info = field_info , ) to_string ( self , * , private_fields = False , static_fields = True , color = False ) inherited to_string is a wrapper over treeo.to_string that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True color bool If True , color is included. False Returns: Type Description str A string representation of the object. Source code in treex/nn/dropout.py def to_string ( self : A , * , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" `to_string` is a wrapper over `treeo.to_string` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. color: If `True`, color is included. Returns: A string representation of the object. \"\"\" return api . to_string ( self , private_fields = private_fields , static_fields = static_fields , color = color , ) train ( self , mode = True , inplace = False ) inherited Creates a new module with the same structure, but with Module.training set to the given value. Parameters: Name Type Description Default mode bool The new training mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~M The new module in with the training mode is set to the given value, if inplace is True then self is returned. Source code in treex/nn/dropout.py def train ( self : M , mode : bool = True , inplace : bool = False ) -> M : \"\"\" Creates a new module with the same structure, but with `Module.training` set to the given value. Arguments: mode: The new training mode. inplace: Whether to update the module inplace. Returns: The new module in with the training mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_training ( module : Module ): if isinstance ( module , Module ): module . _training = mode return to . apply ( set_training , self , inplace = inplace ) unfreeze ( self , inplace = False ) inherited Creates a new module with .frozen set to False, equivalent to calling freeze(False) . Parameters: Name Type Description Default inplace bool Whether to update the module inplace. False Returns: Type Description ~M The new module with .frozen set to False, if inplace is True then self is returned. Source code in treex/nn/dropout.py def unfreeze ( self : M , inplace : bool = False ) -> M : \"\"\" Creates a new module with `.frozen` set to False, equivalent to calling `freeze(False)`. Arguments: inplace: Whether to update the module inplace. Returns: The new module with `.frozen` set to False, if `inplace` is `True` then `self` is returned. \"\"\" return self . freeze ( False , inplace = inplace )","title":"Dropout"},{"location":"api/Dropout/#treexdropout","text":"Create a dropout layer. Dropout is implemented as a wrapper over flax.linen.Dropout , its constructor arguments accept almost the same arguments including any Flax artifacts such as initializers. Main differences: deterministic is not a constructor argument, but remains a __call__ argument. self.training state is used to indicate how Dropout should behave, interally deterministic = not self.training or self.frozen is used unless deterministic is explicitly passed via __call__ . Dropout maintains an rng: Rng state which is used to generate random masks unless rng is passed via __call__ .","title":"treex.Dropout"},{"location":"api/Dropout/#treex.nn.dropout.Dropout.first_run","text":"Returns: Type Description bool True if its currently the first run of a compact method.","title":"first_run"},{"location":"api/Dropout/#treex.nn.dropout.Dropout.__class__","text":"","title":"__class__"},{"location":"api/Dropout/#treex.nn.dropout.Dropout.__class__.__base__","text":"Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()).","title":"__base__"},{"location":"api/Dropout/#treex.nn.dropout.Dropout.__class__.__base__.__instancecheck__","text":"Override for isinstance(instance, cls). Source code in treex/nn/dropout.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance )","title":"__instancecheck__()"},{"location":"api/Dropout/#treex.nn.dropout.Dropout.__class__.__base__.__new__","text":"Create and return a new object. See help(type) for accurate signature. Source code in treex/nn/dropout.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls","title":"__new__()"},{"location":"api/Dropout/#treex.nn.dropout.Dropout.__class__.__base__.__subclasscheck__","text":"Override for issubclass(subclass, cls). Source code in treex/nn/dropout.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass )","title":"__subclasscheck__()"},{"location":"api/Dropout/#treex.nn.dropout.Dropout.__class__.__base__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/dropout.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/Dropout/#treex.nn.dropout.Dropout.__class__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/dropout.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/Dropout/#treex.nn.dropout.Dropout.__call__","text":"Applies a random dropout mask to the input. Parameters: Name Type Description Default x ndarray the inputs that should be randomly masked. required deterministic Optional[bool] if false the inputs are scaled by 1 / (1 - rate) and masked, whereas if true, no mask is applied and the inputs are returned as is. None rng an optional jax.random.PRNGKey . By default self.rng will be used. None Returns: Type Description ndarray The masked inputs reweighted to preserve mean. Source code in treex/nn/dropout.py def __call__ ( self , x : np . ndarray , deterministic : tp . Optional [ bool ] = None , rng = None ) -> jnp . ndarray : \"\"\"Applies a random dropout mask to the input. Arguments: x: the inputs that should be randomly masked. deterministic: if false the inputs are scaled by `1 / (1 - rate)` and masked, whereas if true, no mask is applied and the inputs are returned as is. rng: an optional `jax.random.PRNGKey`. By default `self.rng` will be used. Returns: The masked inputs reweighted to preserve mean. \"\"\" variables = dict () training = ( not deterministic if deterministic is not None else self . training and not self . frozen ) if rng is None : rng = self . next_key () if training else self . next_key . key # call apply output = self . module . apply ( variables , x , deterministic = not training , rng = rng , ) return tp . cast ( jnp . ndarray , output )","title":"__call__()"},{"location":"api/Dropout/#treex.nn.dropout.Dropout.__init__","text":"Create a dropout layer. Parameters: Name Type Description Default rate float the dropout probability. ( not the keep rate!) required broadcast_dims Iterable[int] dimensions that will share the same dropout mask () Source code in treex/nn/dropout.py def __init__ ( self , rate : float , broadcast_dims : tp . Iterable [ int ] = (), ): \"\"\" Create a dropout layer. Arguments: rate: the dropout probability. (_not_ the keep rate!) broadcast_dims: dimensions that will share the same dropout mask \"\"\" self . rate = rate self . broadcast_dims = broadcast_dims self . next_key = KeySeq ()","title":"__init__()"},{"location":"api/Dropout/#treex.nn.dropout.Dropout.apply","text":"apply is a wrapper over treeo.apply that passes self as the second argument. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treex/nn/dropout.py def apply ( self : A , f : tp . Callable [ ... , None ], * rest : A , inplace : bool = False ) -> A : \"\"\" `apply` is a wrapper over `treeo.apply` that passes `self` as the second argument. Arguments: f: The function to apply. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" return api . apply ( f , self , * rest , inplace = inplace )","title":"apply()"},{"location":"api/Dropout/#treex.nn.dropout.Dropout.batch_stats","text":"Returns a copy of the Module with only tx.BatchStat TreeParts, alias for filter(tx.BatchStat) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/dropout.py def batch_stats ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.BatchStat TreeParts, alias for `filter(tx.BatchStat)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . BatchStat , * filters )","title":"batch_stats()"},{"location":"api/Dropout/#treex.nn.dropout.Dropout.check_metadata_updates","text":"Checks for new fields, if found, adds them to the metadata. Source code in treex/nn/dropout.py def check_metadata_updates ( self ): \"\"\" Checks for new fields, if found, adds them to the metadata. \"\"\" with _CONTEXT . update ( flatten_mode = FlattenMode . all_fields ): jax . tree_flatten ( self )","title":"check_metadata_updates()"},{"location":"api/Dropout/#treex.nn.dropout.Dropout.copy","text":"copy is a wrapper over treeo.copy that passes self as the first argument. Source code in treex/nn/dropout.py def copy ( self : A ) -> A : \"\"\" `copy` is a wrapper over `treeo.copy` that passes `self` as the first argument. \"\"\" return tree_m . copy ( self )","title":"copy()"},{"location":"api/Dropout/#treex.nn.dropout.Dropout.eval","text":"Creates a new module with the training mode set to False, equivalent to calling train(False) . Returns: Type Description ~M The new module with the training mode set to False. Source code in treex/nn/dropout.py def eval ( self : M , inplace : bool = False ) -> M : \"\"\" Creates a new module with the training mode set to False, equivalent to calling `train(False)`. Returns: The new module with the training mode set to False. \"\"\" return self . train ( False , inplace = inplace )","title":"eval()"},{"location":"api/Dropout/#treex.nn.dropout.Dropout.filter","text":"filter is a wrapper over treeo.filter that passes self as the first argument. Parameters: Name Type Description Default *filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treex/nn/dropout.py def filter ( self : A , * filters : api . Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ) -> A : \"\"\" `filter` is a wrapper over `treeo.filter` that passes `self` as the first argument. Arguments: *filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" return api . filter ( self , * filters , inplace = inplace , flatten_mode = flatten_mode )","title":"filter()"},{"location":"api/Dropout/#treex.nn.dropout.Dropout.freeze","text":"Creates a new module with the same structure, but with Module.frozen set to the given value. Parameters: Name Type Description Default mode bool The new frozen mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~M The new module in with the frozen mode is set to the given value, if inplace is True then self is returned. Source code in treex/nn/dropout.py def freeze ( self : M , mode : bool = True , inplace : bool = False ) -> M : \"\"\" Creates a new module with the same structure, but with `Module.frozen` set to the given value. Arguments: mode: The new `frozen` mode. inplace: Whether to update the module inplace. Returns: The new module in with the `frozen` mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_frozen ( module : Module ): if isinstance ( module , Module ): module . _frozen = mode return to . apply ( set_frozen , self , inplace = inplace )","title":"freeze()"},{"location":"api/Dropout/#treex.nn.dropout.Dropout.get_field","text":"A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: The field must be declared in the class definition. The method can only be called inside a compact context. Parameters: Name Type Description Default field_name str The name of the field to get. required initializer Callable[[], ~A] The function to initialize the field if it does not exist. required Returns: Type Description ~A The field value. Source code in treex/nn/dropout.py def get_field ( self , field_name : str , initializer : tp . Callable [[], A ], ) -> A : \"\"\" A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: * The field must be declared in the class definition. * The method can only be called inside a `compact` context. Arguments: field_name: The name of the field to get. initializer: The function to initialize the field if it does not exist. Returns: The field value. \"\"\" value : A if field_name not in self . _field_metadata : raise ValueError ( f \"Metadata for field ' { field_name } ' does not exist.\" ) if tree_m . _COMPACT_CONTEXT . current_tree is not self : raise RuntimeError ( f \"Object ' { type ( self ) . __name__ } ' is not the current tree, found ' { type ( tree_m . _COMPACT_CONTEXT . current_tree ) . __name__ } ', did you forget the @compact decorator?\" ) if field_name in vars ( self ): value = getattr ( self , field_name ) else : if tree_m . _COMPACT_CONTEXT . in_compact and not self . first_run : raise RuntimeError ( f \"Trying to initialize field ' { field_name } ' after the first run of `compact`.\" ) value = initializer () setattr ( self , field_name , value ) return value","title":"get_field()"},{"location":"api/Dropout/#treex.nn.dropout.Dropout.init","text":"Method version of tx.init , it applies self as first argument. init creates a new module with the same structure, but with its fields initialized given a seed key . The following procedure is used: The input key is split and iteratively updated before passing a derived value to any process that requires initialization. Initializer s are called and applied to the module first. Module.rng_init methods are called last. Parameters: Name Type Description Default key Union[int, jax._src.numpy.lax_numpy.ndarray] The seed to use for initialization. required Returns: Type Description ~M The new module with the fields initialized. Source code in treex/nn/dropout.py def init ( self : M , key : tp . Union [ int , jnp . ndarray ], inplace : bool = False ) -> M : \"\"\" Method version of `tx.init`, it applies `self` as first argument. `init` creates a new module with the same structure, but with its fields initialized given a seed `key`. The following procedure is used: 1. The input `key` is split and iteratively updated before passing a derived value to any process that requires initialization. 2. `Initializer`s are called and applied to the module first. 3. `Module.rng_init` methods are called last. Arguments: key: The seed to use for initialization. Returns: The new module with the fields initialized. \"\"\" if isinstance ( key , int ): key = jax . random . PRNGKey ( key ) def next_key () -> jnp . ndarray : nonlocal key assert isinstance ( key , ( np . ndarray , jnp . ndarray )) next_key , key = utils . iter_split ( key ) return next_key tree_out : M = jax . tree_map ( lambda initializer : ( initializer ( next_key ()) if isinstance ( initializer , types . Initializer ) else initializer ), self , is_leaf = lambda x : isinstance ( x , types . Initializer ), ) if inplace : # here we update initialized fields by the above tree_map tree_out = to . merge ( self , tree_out , inplace = True ) def call_module_init ( module : Module ): if isinstance ( module , Module ) and not module . _initialized : module . rng_init ( next_key ()) module . _initialized = True return to . apply ( call_module_init , tree_out , inplace = inplace )","title":"init()"},{"location":"api/Dropout/#treex.nn.dropout.Dropout.logs","text":"Returns a copy of the Module with only tx.Log TreeParts, alias for filter(tx.Log) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/dropout.py def logs ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Log TreeParts, alias for `filter(tx.Log)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . Log , * filters )","title":"logs()"},{"location":"api/Dropout/#treex.nn.dropout.Dropout.losses","text":"Returns a copy of the Module with only tx.Loss TreeParts, alias for filter(tx.Loss) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/dropout.py def losses ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Loss TreeParts, alias for `filter(tx.Loss)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . LossLog , * filters )","title":"losses()"},{"location":"api/Dropout/#treex.nn.dropout.Dropout.map","text":"map is a wrapper over treeo.map that passes self as the second argument. Parameters: Name Type Description Default f Callable The function to apply to the leaves. required *filters Filter The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treex/nn/dropout.py def map ( self : A , f : tp . Callable , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , is_leaf : tp . Callable [[ tp . Any ], bool ] = None , ) -> A : \"\"\" `map` is a wrapper over `treeo.map` that passes `self` as the second argument. Arguments: f: The function to apply to the leaves. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" return api . map ( f , self , * filters , inplace = inplace , flatten_mode = flatten_mode , is_leaf = is_leaf , )","title":"map()"},{"location":"api/Dropout/#treex.nn.dropout.Dropout.merge","text":"merge is a wrapper over treeo.merge that passes self as the first argument. Parameters: Name Type Description Default other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the merged values. If inplace is True , obj is returned. Source code in treex/nn/dropout.py def merge ( self : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" `merge` is a wrapper over `treeo.merge` that passes `self` as the first argument. Arguments: other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the merged values. If `inplace` is `True`, `obj` is returned. \"\"\" return api . merge ( self , other , * rest , inplace = inplace , flatten_mode = flatten_mode , ignore_static = ignore_static , )","title":"merge()"},{"location":"api/Dropout/#treex.nn.dropout.Dropout.metrics","text":"Returns a copy of the Module with only tx.Metric TreeParts, alias for filter(tx.Metric) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/dropout.py def metrics ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Metric TreeParts, alias for `filter(tx.Metric)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . MetricLog , * filters )","title":"metrics()"},{"location":"api/Dropout/#treex.nn.dropout.Dropout.model_states","text":"Returns a copy of the Module with only tx.ModelState TreeParts, alias for filter(tx.ModelState) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/dropout.py def model_states ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.ModelState TreeParts, alias for `filter(tx.ModelState)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . ModelState , * filters )","title":"model_states()"},{"location":"api/Dropout/#treex.nn.dropout.Dropout.parameters","text":"Returns a copy of the Module with only tx.Parameter TreeParts, alias for filter(tx.Parameter) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/dropout.py def parameters ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Parameter TreeParts, alias for `filter(tx.Parameter)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . Parameter , * filters )","title":"parameters()"},{"location":"api/Dropout/#treex.nn.dropout.Dropout.rngs","text":"Returns a copy of the Module with only tx.Rng TreeParts, alias for filter(tx.Rng) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/dropout.py def rngs ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Rng TreeParts, alias for `filter(tx.Rng)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . Rng , * filters )","title":"rngs()"},{"location":"api/Dropout/#treex.nn.dropout.Dropout.states","text":"Returns a copy of the Module with only tx.State TreeParts, alias for filter(tx.State) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/dropout.py def states ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.State TreeParts, alias for `filter(tx.State)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . State , * filters )","title":"states()"},{"location":"api/Dropout/#treex.nn.dropout.Dropout.tabulate","text":"Returns a tabular representation of the module. Parameters: Name Type Description Default depth int The maximum depth of the representation in terms of nested Modules, -1 means no limit. -1 signature bool Whether to show the signature of the Module. False param_types bool Whether to show the types of the parameters. True Returns: Type Description str A string containing the tabular representation. Source code in treex/nn/dropout.py def tabulate ( self , inputs : tp . Union [ tp . Any , types . Inputs , None ] = None , depth : int = - 1 , signature : bool = False , param_types : bool = True , ) -> str : \"\"\" Returns a tabular representation of the module. Arguments: depth: The maximum depth of the representation in terms of nested Modules, -1 means no limit. signature: Whether to show the signature of the Module. param_types: Whether to show the types of the parameters. Returns: A string containing the tabular representation. \"\"\" self = to . copy ( self ) if inputs is not None : if not isinstance ( inputs , types . Inputs ): inputs = types . Inputs ( inputs ) inputs = tp . cast ( types . Inputs , inputs ) if not isinstance ( self , tp . Callable ): raise TypeError ( \"`inputs` can only be specified if the module is a callable.\" ) with _Context ( call_info = {}): # call using self to preserve references def eval_call ( args , kwargs ): assert isinstance ( self , tp . Callable ) return self ( * args , ** kwargs ) jax . eval_shape ( eval_call , inputs . args , inputs . kwargs , ) call_info = _CONTEXT . call_info else : call_info = None with to . add_field_info (): flat : tp . List [ to . FieldInfo ] flat , _ = jax . tree_flatten ( self ) tree_part_types : tp . Tuple [ tp . Type [ types . TreePart ], ... ] = tuple ( { field_info . kind for field_info in flat if utils . _generic_issubclass ( field_info . kind , types . TreePart ) } ) path = () rows = list ( utils . _get_tabulate_rows ( path , self , depth , tree_part_types , signature , param_types ) ) modules = [ row [ 0 ] for row in rows ] rows = [ row [ 1 :] for row in rows ] if call_info is not None : for module , row in zip ( modules , rows ): if module in call_info : inputs , outputs = call_info [ module ] simplified_inputs = ( inputs . args [ 0 ] if len ( inputs . kwargs ) == 0 and len ( inputs . args ) == 1 else inputs . kwargs if len ( inputs . kwargs ) == 0 else inputs . kwargs if len ( inputs . args ) == 0 else ( inputs . args , inputs . kwargs ) ) inputs_repr = utils . _format_param_tree ( simplified_inputs ) outputs_repr = utils . _format_param_tree ( outputs ) else : inputs_repr = \"\" outputs_repr = \"\" row . insert ( 3 , outputs_repr ) row . insert ( 3 , inputs_repr ) n_non_treepart_cols = 2 if call_info is None else 4 rows [ 0 ][ 0 ] = \"*\" rows . append ( [ \"\" ] * n_non_treepart_cols + [ \"Total:\" ] + [ utils . _format_obj_size ( self . filter ( kind ), add_padding = True ) for kind in tree_part_types ] ) utils . _add_padding ( rows ) table = Table ( show_header = True , show_lines = True , show_footer = True , # box=rich.box.HORIZONTALS, ) table . add_column ( \"path\" ) table . add_column ( \"module\" ) table . add_column ( \"params\" ) if call_info is not None : table . add_column ( \"inputs\" ) table . add_column ( \"outputs\" ) for tree_part_type in tree_part_types : type_name = tree_part_type . __name__ if type_name . startswith ( \"_\" ): type_name = type_name [ 1 :] table . add_column ( type_name ) for row in rows [: - 1 ]: table . add_row ( * row ) table . columns [ n_non_treepart_cols ] . footer = Text . from_markup ( rows [ - 1 ][ n_non_treepart_cols ], justify = \"right\" ) for i in range ( len ( tree_part_types )): table . columns [ n_non_treepart_cols + 1 + i ] . footer = rows [ - 1 ][ n_non_treepart_cols + 1 + i ] table . caption_style = \"bold\" table . caption = \" \\n Total Parameters: \" + utils . _format_obj_size ( self , add_padding = False ) return utils . _get_rich_repr ( table )","title":"tabulate()"},{"location":"api/Dropout/#treex.nn.dropout.Dropout.to_dict","text":"to_dict is a wrapper over treeo.to_dict that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True type_info bool If True , type information is included. False field_info bool If True , field information is included. False Returns: Type Description Any A dict representation of the object. Source code in treex/nn/dropout.py def to_dict ( self , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : \"\"\" `to_dict` is a wrapper over `treeo.to_dict` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. type_info: If `True`, type information is included. field_info: If `True`, field information is included. Returns: A dict representation of the object. \"\"\" return api . to_dict ( self , private_fields = private_fields , static_fields = static_fields , type_info = type_info , field_info = field_info , )","title":"to_dict()"},{"location":"api/Dropout/#treex.nn.dropout.Dropout.to_string","text":"to_string is a wrapper over treeo.to_string that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True color bool If True , color is included. False Returns: Type Description str A string representation of the object. Source code in treex/nn/dropout.py def to_string ( self : A , * , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" `to_string` is a wrapper over `treeo.to_string` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. color: If `True`, color is included. Returns: A string representation of the object. \"\"\" return api . to_string ( self , private_fields = private_fields , static_fields = static_fields , color = color , )","title":"to_string()"},{"location":"api/Dropout/#treex.nn.dropout.Dropout.train","text":"Creates a new module with the same structure, but with Module.training set to the given value. Parameters: Name Type Description Default mode bool The new training mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~M The new module in with the training mode is set to the given value, if inplace is True then self is returned. Source code in treex/nn/dropout.py def train ( self : M , mode : bool = True , inplace : bool = False ) -> M : \"\"\" Creates a new module with the same structure, but with `Module.training` set to the given value. Arguments: mode: The new training mode. inplace: Whether to update the module inplace. Returns: The new module in with the training mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_training ( module : Module ): if isinstance ( module , Module ): module . _training = mode return to . apply ( set_training , self , inplace = inplace )","title":"train()"},{"location":"api/Dropout/#treex.nn.dropout.Dropout.unfreeze","text":"Creates a new module with .frozen set to False, equivalent to calling freeze(False) . Parameters: Name Type Description Default inplace bool Whether to update the module inplace. False Returns: Type Description ~M The new module with .frozen set to False, if inplace is True then self is returned. Source code in treex/nn/dropout.py def unfreeze ( self : M , inplace : bool = False ) -> M : \"\"\" Creates a new module with `.frozen` set to False, equivalent to calling `freeze(False)`. Arguments: inplace: Whether to update the module inplace. Returns: The new module with `.frozen` set to False, if `inplace` is `True` then `self` is returned. \"\"\" return self . freeze ( False , inplace = inplace )","title":"unfreeze()"},{"location":"api/Extensions/","text":"treex.Extensions Mixin that adds all available mixins from treeo.mixins except KindMixin . first_run : bool inherited property readonly Returns: Type Description bool True if its currently the first run of a compact method. __repr__ ( self ) inherited special Uses treeo.to_string to generate a string representation of the object. Source code in treeo/mixins.py def __repr__ ( self ) -> tp . Any : \"\"\" Uses `treeo.to_string` to generate a string representation of the object. \"\"\" return api . to_string ( self , private_fields = False , static_fields = True , color = False , ) apply ( self , f , * rest , * , inplace = False ) inherited apply is a wrapper over treeo.apply that passes self as the second argument. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treeo/mixins.py def apply ( self : A , f : tp . Callable [ ... , None ], * rest : A , inplace : bool = False ) -> A : \"\"\" `apply` is a wrapper over `treeo.apply` that passes `self` as the second argument. Arguments: f: The function to apply. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" return api . apply ( f , self , * rest , inplace = inplace ) copy ( self ) inherited copy is a wrapper over treeo.copy that passes self as the first argument. Source code in treeo/mixins.py def copy ( self : A ) -> A : \"\"\" `copy` is a wrapper over `treeo.copy` that passes `self` as the first argument. \"\"\" return tree_m . copy ( self ) filter ( self , * filters , * , inplace = False , flatten_mode = None ) inherited filter is a wrapper over treeo.filter that passes self as the first argument. Parameters: Name Type Description Default *filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treeo/mixins.py def filter ( self : A , * filters : api . Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ) -> A : \"\"\" `filter` is a wrapper over `treeo.filter` that passes `self` as the first argument. Arguments: *filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" return api . filter ( self , * filters , inplace = inplace , flatten_mode = flatten_mode ) get_field ( self , field_name , initializer ) inherited A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: The field must be declared in the class definition. The method can only be called inside a compact context. Parameters: Name Type Description Default field_name str The name of the field to get. required initializer Callable[[], ~A] The function to initialize the field if it does not exist. required Returns: Type Description ~A The field value. Source code in treeo/mixins.py def get_field ( self , field_name : str , initializer : tp . Callable [[], A ], ) -> A : \"\"\" A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: * The field must be declared in the class definition. * The method can only be called inside a `compact` context. Arguments: field_name: The name of the field to get. initializer: The function to initialize the field if it does not exist. Returns: The field value. \"\"\" value : A if field_name not in self . _field_metadata : raise ValueError ( f \"Metadata for field ' { field_name } ' does not exist.\" ) if tree_m . _COMPACT_CONTEXT . current_tree is not self : raise RuntimeError ( f \"Object ' { type ( self ) . __name__ } ' is not the current tree, found ' { type ( tree_m . _COMPACT_CONTEXT . current_tree ) . __name__ } ', did you forget the @compact decorator?\" ) if field_name in vars ( self ): value = getattr ( self , field_name ) else : if tree_m . _COMPACT_CONTEXT . in_compact and not self . first_run : raise RuntimeError ( f \"Trying to initialize field ' { field_name } ' after the first run of `compact`.\" ) value = initializer () setattr ( self , field_name , value ) return value map ( self , f , * filters , * , inplace = False , flatten_mode = None , is_leaf = None ) inherited map is a wrapper over treeo.map that passes self as the second argument. Parameters: Name Type Description Default f Callable The function to apply to the leaves. required *filters Filter The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treeo/mixins.py def map ( self : A , f : tp . Callable , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , is_leaf : tp . Callable [[ tp . Any ], bool ] = None , ) -> A : \"\"\" `map` is a wrapper over `treeo.map` that passes `self` as the second argument. Arguments: f: The function to apply to the leaves. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" return api . map ( f , self , * filters , inplace = inplace , flatten_mode = flatten_mode , is_leaf = is_leaf , ) merge ( self , other , * rest , * , inplace = False , flatten_mode = None , ignore_static = False ) inherited merge is a wrapper over treeo.merge that passes self as the first argument. Parameters: Name Type Description Default other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the merged values. If inplace is True , obj is returned. Source code in treeo/mixins.py def merge ( self : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" `merge` is a wrapper over `treeo.merge` that passes `self` as the first argument. Arguments: other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the merged values. If `inplace` is `True`, `obj` is returned. \"\"\" return api . merge ( self , other , * rest , inplace = inplace , flatten_mode = flatten_mode , ignore_static = ignore_static , ) to_dict ( self , * , private_fields = False , static_fields = True , type_info = False , field_info = False ) inherited to_dict is a wrapper over treeo.to_dict that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True type_info bool If True , type information is included. False field_info bool If True , field information is included. False Returns: Type Description Any A dict representation of the object. Source code in treeo/mixins.py def to_dict ( self , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : \"\"\" `to_dict` is a wrapper over `treeo.to_dict` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. type_info: If `True`, type information is included. field_info: If `True`, field information is included. Returns: A dict representation of the object. \"\"\" return api . to_dict ( self , private_fields = private_fields , static_fields = static_fields , type_info = type_info , field_info = field_info , ) to_string ( self , * , private_fields = False , static_fields = True , color = False ) inherited to_string is a wrapper over treeo.to_string that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True color bool If True , color is included. False Returns: Type Description str A string representation of the object. Source code in treeo/mixins.py def to_string ( self : A , * , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" `to_string` is a wrapper over `treeo.to_string` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. color: If `True`, color is included. Returns: A string representation of the object. \"\"\" return api . to_string ( self , private_fields = private_fields , static_fields = static_fields , color = color , )","title":"Extensions"},{"location":"api/Extensions/#treexextensions","text":"Mixin that adds all available mixins from treeo.mixins except KindMixin .","title":"treex.Extensions"},{"location":"api/Extensions/#treeo.mixins.Extensions.first_run","text":"Returns: Type Description bool True if its currently the first run of a compact method.","title":"first_run"},{"location":"api/Extensions/#treeo.mixins.Extensions.__repr__","text":"Uses treeo.to_string to generate a string representation of the object. Source code in treeo/mixins.py def __repr__ ( self ) -> tp . Any : \"\"\" Uses `treeo.to_string` to generate a string representation of the object. \"\"\" return api . to_string ( self , private_fields = False , static_fields = True , color = False , )","title":"__repr__()"},{"location":"api/Extensions/#treeo.mixins.Extensions.apply","text":"apply is a wrapper over treeo.apply that passes self as the second argument. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treeo/mixins.py def apply ( self : A , f : tp . Callable [ ... , None ], * rest : A , inplace : bool = False ) -> A : \"\"\" `apply` is a wrapper over `treeo.apply` that passes `self` as the second argument. Arguments: f: The function to apply. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" return api . apply ( f , self , * rest , inplace = inplace )","title":"apply()"},{"location":"api/Extensions/#treeo.mixins.Extensions.copy","text":"copy is a wrapper over treeo.copy that passes self as the first argument. Source code in treeo/mixins.py def copy ( self : A ) -> A : \"\"\" `copy` is a wrapper over `treeo.copy` that passes `self` as the first argument. \"\"\" return tree_m . copy ( self )","title":"copy()"},{"location":"api/Extensions/#treeo.mixins.Extensions.filter","text":"filter is a wrapper over treeo.filter that passes self as the first argument. Parameters: Name Type Description Default *filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treeo/mixins.py def filter ( self : A , * filters : api . Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ) -> A : \"\"\" `filter` is a wrapper over `treeo.filter` that passes `self` as the first argument. Arguments: *filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" return api . filter ( self , * filters , inplace = inplace , flatten_mode = flatten_mode )","title":"filter()"},{"location":"api/Extensions/#treeo.mixins.Extensions.get_field","text":"A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: The field must be declared in the class definition. The method can only be called inside a compact context. Parameters: Name Type Description Default field_name str The name of the field to get. required initializer Callable[[], ~A] The function to initialize the field if it does not exist. required Returns: Type Description ~A The field value. Source code in treeo/mixins.py def get_field ( self , field_name : str , initializer : tp . Callable [[], A ], ) -> A : \"\"\" A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: * The field must be declared in the class definition. * The method can only be called inside a `compact` context. Arguments: field_name: The name of the field to get. initializer: The function to initialize the field if it does not exist. Returns: The field value. \"\"\" value : A if field_name not in self . _field_metadata : raise ValueError ( f \"Metadata for field ' { field_name } ' does not exist.\" ) if tree_m . _COMPACT_CONTEXT . current_tree is not self : raise RuntimeError ( f \"Object ' { type ( self ) . __name__ } ' is not the current tree, found ' { type ( tree_m . _COMPACT_CONTEXT . current_tree ) . __name__ } ', did you forget the @compact decorator?\" ) if field_name in vars ( self ): value = getattr ( self , field_name ) else : if tree_m . _COMPACT_CONTEXT . in_compact and not self . first_run : raise RuntimeError ( f \"Trying to initialize field ' { field_name } ' after the first run of `compact`.\" ) value = initializer () setattr ( self , field_name , value ) return value","title":"get_field()"},{"location":"api/Extensions/#treeo.mixins.Extensions.map","text":"map is a wrapper over treeo.map that passes self as the second argument. Parameters: Name Type Description Default f Callable The function to apply to the leaves. required *filters Filter The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treeo/mixins.py def map ( self : A , f : tp . Callable , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , is_leaf : tp . Callable [[ tp . Any ], bool ] = None , ) -> A : \"\"\" `map` is a wrapper over `treeo.map` that passes `self` as the second argument. Arguments: f: The function to apply to the leaves. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" return api . map ( f , self , * filters , inplace = inplace , flatten_mode = flatten_mode , is_leaf = is_leaf , )","title":"map()"},{"location":"api/Extensions/#treeo.mixins.Extensions.merge","text":"merge is a wrapper over treeo.merge that passes self as the first argument. Parameters: Name Type Description Default other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the merged values. If inplace is True , obj is returned. Source code in treeo/mixins.py def merge ( self : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" `merge` is a wrapper over `treeo.merge` that passes `self` as the first argument. Arguments: other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the merged values. If `inplace` is `True`, `obj` is returned. \"\"\" return api . merge ( self , other , * rest , inplace = inplace , flatten_mode = flatten_mode , ignore_static = ignore_static , )","title":"merge()"},{"location":"api/Extensions/#treeo.mixins.Extensions.to_dict","text":"to_dict is a wrapper over treeo.to_dict that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True type_info bool If True , type information is included. False field_info bool If True , field information is included. False Returns: Type Description Any A dict representation of the object. Source code in treeo/mixins.py def to_dict ( self , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : \"\"\" `to_dict` is a wrapper over `treeo.to_dict` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. type_info: If `True`, type information is included. field_info: If `True`, field information is included. Returns: A dict representation of the object. \"\"\" return api . to_dict ( self , private_fields = private_fields , static_fields = static_fields , type_info = type_info , field_info = field_info , )","title":"to_dict()"},{"location":"api/Extensions/#treeo.mixins.Extensions.to_string","text":"to_string is a wrapper over treeo.to_string that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True color bool If True , color is included. False Returns: Type Description str A string representation of the object. Source code in treeo/mixins.py def to_string ( self : A , * , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" `to_string` is a wrapper over `treeo.to_string` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. color: If `True`, color is included. Returns: A string representation of the object. \"\"\" return api . to_string ( self , private_fields = private_fields , static_fields = static_fields , color = color , )","title":"to_string()"},{"location":"api/FieldInfo/","text":"treex.FieldInfo","title":"FieldInfo"},{"location":"api/FieldInfo/#treexfieldinfo","text":"","title":"treex.FieldInfo"},{"location":"api/FieldMetadata/","text":"treex.FieldMetadata","title":"FieldMetadata"},{"location":"api/FieldMetadata/#treexfieldmetadata","text":"","title":"treex.FieldMetadata"},{"location":"api/FlaxModule/","text":"treex.FlaxModule first_run : bool inherited property readonly Returns: Type Description bool True if its currently the first run of a compact method. __class__ inherited __base__ inherited Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()). __instancecheck__ ( cls , instance ) special Override for isinstance(instance, cls). Source code in treex/nn/flax_module.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance ) __new__ ( mcls , name , bases , namespace , ** kwargs ) special staticmethod Create and return a new object. See help(type) for accurate signature. Source code in treex/nn/flax_module.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls __subclasscheck__ ( cls , subclass ) special Override for issubclass(subclass, cls). Source code in treex/nn/flax_module.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass ) register ( cls , subclass ) Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/flax_module.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) register ( cls , subclass ) inherited Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/flax_module.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) apply ( self , f , * rest , * , inplace = False ) inherited apply is a wrapper over treeo.apply that passes self as the second argument. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treex/nn/flax_module.py def apply ( self : A , f : tp . Callable [ ... , None ], * rest : A , inplace : bool = False ) -> A : \"\"\" `apply` is a wrapper over `treeo.apply` that passes `self` as the second argument. Arguments: f: The function to apply. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" return api . apply ( f , self , * rest , inplace = inplace ) check_metadata_updates ( self ) inherited Checks for new fields, if found, adds them to the metadata. Source code in treex/nn/flax_module.py def check_metadata_updates ( self ): \"\"\" Checks for new fields, if found, adds them to the metadata. \"\"\" with _CONTEXT . update ( flatten_mode = FlattenMode . all_fields ): jax . tree_flatten ( self ) copy ( self ) inherited copy is a wrapper over treeo.copy that passes self as the first argument. Source code in treex/nn/flax_module.py def copy ( self : A ) -> A : \"\"\" `copy` is a wrapper over `treeo.copy` that passes `self` as the first argument. \"\"\" return tree_m . copy ( self ) eval ( self , inplace = False ) inherited Creates a new module with the training mode set to False, equivalent to calling train(False) . Returns: Type Description ~M The new module with the training mode set to False. Source code in treex/nn/flax_module.py def eval ( self : M , inplace : bool = False ) -> M : \"\"\" Creates a new module with the training mode set to False, equivalent to calling `train(False)`. Returns: The new module with the training mode set to False. \"\"\" return self . train ( False , inplace = inplace ) filter ( self , * filters , * , inplace = False , flatten_mode = None ) inherited filter is a wrapper over treeo.filter that passes self as the first argument. Parameters: Name Type Description Default *filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treex/nn/flax_module.py def filter ( self : A , * filters : api . Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ) -> A : \"\"\" `filter` is a wrapper over `treeo.filter` that passes `self` as the first argument. Arguments: *filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" return api . filter ( self , * filters , inplace = inplace , flatten_mode = flatten_mode ) freeze ( self , mode = True , inplace = False ) inherited Creates a new module with the same structure, but with Module.frozen set to the given value. Parameters: Name Type Description Default mode bool The new frozen mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~M The new module in with the frozen mode is set to the given value, if inplace is True then self is returned. Source code in treex/nn/flax_module.py def freeze ( self : M , mode : bool = True , inplace : bool = False ) -> M : \"\"\" Creates a new module with the same structure, but with `Module.frozen` set to the given value. Arguments: mode: The new `frozen` mode. inplace: Whether to update the module inplace. Returns: The new module in with the `frozen` mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_frozen ( module : Module ): if isinstance ( module , Module ): module . _frozen = mode return to . apply ( set_frozen , self , inplace = inplace ) get_field ( self , field_name , initializer ) inherited A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: The field must be declared in the class definition. The method can only be called inside a compact context. Parameters: Name Type Description Default field_name str The name of the field to get. required initializer Callable[[], ~A] The function to initialize the field if it does not exist. required Returns: Type Description ~A The field value. Source code in treex/nn/flax_module.py def get_field ( self , field_name : str , initializer : tp . Callable [[], A ], ) -> A : \"\"\" A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: * The field must be declared in the class definition. * The method can only be called inside a `compact` context. Arguments: field_name: The name of the field to get. initializer: The function to initialize the field if it does not exist. Returns: The field value. \"\"\" value : A if field_name not in self . _field_metadata : raise ValueError ( f \"Metadata for field ' { field_name } ' does not exist.\" ) if tree_m . _COMPACT_CONTEXT . current_tree is not self : raise RuntimeError ( f \"Object ' { type ( self ) . __name__ } ' is not the current tree, found ' { type ( tree_m . _COMPACT_CONTEXT . current_tree ) . __name__ } ', did you forget the @compact decorator?\" ) if field_name in vars ( self ): value = getattr ( self , field_name ) else : if tree_m . _COMPACT_CONTEXT . in_compact and not self . first_run : raise RuntimeError ( f \"Trying to initialize field ' { field_name } ' after the first run of `compact`.\" ) value = initializer () setattr ( self , field_name , value ) return value init ( self , key , inplace = False ) inherited Method version of tx.init , it applies self as first argument. init creates a new module with the same structure, but with its fields initialized given a seed key . The following procedure is used: The input key is split and iteratively updated before passing a derived value to any process that requires initialization. Initializer s are called and applied to the module first. Module.rng_init methods are called last. Parameters: Name Type Description Default key Union[int, jax._src.numpy.lax_numpy.ndarray] The seed to use for initialization. required Returns: Type Description ~M The new module with the fields initialized. Source code in treex/nn/flax_module.py def init ( self : M , key : tp . Union [ int , jnp . ndarray ], inplace : bool = False ) -> M : \"\"\" Method version of `tx.init`, it applies `self` as first argument. `init` creates a new module with the same structure, but with its fields initialized given a seed `key`. The following procedure is used: 1. The input `key` is split and iteratively updated before passing a derived value to any process that requires initialization. 2. `Initializer`s are called and applied to the module first. 3. `Module.rng_init` methods are called last. Arguments: key: The seed to use for initialization. Returns: The new module with the fields initialized. \"\"\" if isinstance ( key , int ): key = jax . random . PRNGKey ( key ) def next_key () -> jnp . ndarray : nonlocal key assert isinstance ( key , ( np . ndarray , jnp . ndarray )) next_key , key = utils . iter_split ( key ) return next_key tree_out : M = jax . tree_map ( lambda initializer : ( initializer ( next_key ()) if isinstance ( initializer , types . Initializer ) else initializer ), self , is_leaf = lambda x : isinstance ( x , types . Initializer ), ) if inplace : # here we update initialized fields by the above tree_map tree_out = to . merge ( self , tree_out , inplace = True ) def call_module_init ( module : Module ): if isinstance ( module , Module ) and not module . _initialized : module . rng_init ( next_key ()) module . _initialized = True return to . apply ( call_module_init , tree_out , inplace = inplace ) logs ( self , * filters ) inherited Returns a copy of the Module with only tx.Log TreeParts, alias for filter(tx.Log) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/flax_module.py def logs ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Log TreeParts, alias for `filter(tx.Log)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . Log , * filters ) losses ( self , * filters ) inherited Returns a copy of the Module with only tx.Loss TreeParts, alias for filter(tx.Loss) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/flax_module.py def losses ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Loss TreeParts, alias for `filter(tx.Loss)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . LossLog , * filters ) map ( self , f , * filters , * , inplace = False , flatten_mode = None , is_leaf = None ) inherited map is a wrapper over treeo.map that passes self as the second argument. Parameters: Name Type Description Default f Callable The function to apply to the leaves. required *filters Filter The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treex/nn/flax_module.py def map ( self : A , f : tp . Callable , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , is_leaf : tp . Callable [[ tp . Any ], bool ] = None , ) -> A : \"\"\" `map` is a wrapper over `treeo.map` that passes `self` as the second argument. Arguments: f: The function to apply to the leaves. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" return api . map ( f , self , * filters , inplace = inplace , flatten_mode = flatten_mode , is_leaf = is_leaf , ) merge ( self , other , * rest , * , inplace = False , flatten_mode = None , ignore_static = False ) inherited merge is a wrapper over treeo.merge that passes self as the first argument. Parameters: Name Type Description Default other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the merged values. If inplace is True , obj is returned. Source code in treex/nn/flax_module.py def merge ( self : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" `merge` is a wrapper over `treeo.merge` that passes `self` as the first argument. Arguments: other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the merged values. If `inplace` is `True`, `obj` is returned. \"\"\" return api . merge ( self , other , * rest , inplace = inplace , flatten_mode = flatten_mode , ignore_static = ignore_static , ) metrics ( self , * filters ) inherited Returns a copy of the Module with only tx.Metric TreeParts, alias for filter(tx.Metric) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/flax_module.py def metrics ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Metric TreeParts, alias for `filter(tx.Metric)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . MetricLog , * filters ) model_states ( self , * filters ) inherited Returns a copy of the Module with only tx.ModelState TreeParts, alias for filter(tx.ModelState) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/flax_module.py def model_states ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.ModelState TreeParts, alias for `filter(tx.ModelState)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . ModelState , * filters ) parameters ( self , * filters ) inherited Returns a copy of the Module with only tx.Parameter TreeParts, alias for filter(tx.Parameter) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/flax_module.py def parameters ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Parameter TreeParts, alias for `filter(tx.Parameter)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . Parameter , * filters ) rngs ( self , * filters ) inherited Returns a copy of the Module with only tx.Rng TreeParts, alias for filter(tx.Rng) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/flax_module.py def rngs ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Rng TreeParts, alias for `filter(tx.Rng)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . Rng , * filters ) states ( self , * filters ) inherited Returns a copy of the Module with only tx.State TreeParts, alias for filter(tx.State) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/flax_module.py def states ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.State TreeParts, alias for `filter(tx.State)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . State , * filters ) tabulate ( self , inputs = None , depth =- 1 , signature = False , param_types = True ) inherited Returns a tabular representation of the module. Parameters: Name Type Description Default depth int The maximum depth of the representation in terms of nested Modules, -1 means no limit. -1 signature bool Whether to show the signature of the Module. False param_types bool Whether to show the types of the parameters. True Returns: Type Description str A string containing the tabular representation. Source code in treex/nn/flax_module.py def tabulate ( self , inputs : tp . Union [ tp . Any , types . Inputs , None ] = None , depth : int = - 1 , signature : bool = False , param_types : bool = True , ) -> str : \"\"\" Returns a tabular representation of the module. Arguments: depth: The maximum depth of the representation in terms of nested Modules, -1 means no limit. signature: Whether to show the signature of the Module. param_types: Whether to show the types of the parameters. Returns: A string containing the tabular representation. \"\"\" self = to . copy ( self ) if inputs is not None : if not isinstance ( inputs , types . Inputs ): inputs = types . Inputs ( inputs ) inputs = tp . cast ( types . Inputs , inputs ) if not isinstance ( self , tp . Callable ): raise TypeError ( \"`inputs` can only be specified if the module is a callable.\" ) with _Context ( call_info = {}): # call using self to preserve references def eval_call ( args , kwargs ): assert isinstance ( self , tp . Callable ) return self ( * args , ** kwargs ) jax . eval_shape ( eval_call , inputs . args , inputs . kwargs , ) call_info = _CONTEXT . call_info else : call_info = None with to . add_field_info (): flat : tp . List [ to . FieldInfo ] flat , _ = jax . tree_flatten ( self ) tree_part_types : tp . Tuple [ tp . Type [ types . TreePart ], ... ] = tuple ( { field_info . kind for field_info in flat if utils . _generic_issubclass ( field_info . kind , types . TreePart ) } ) path = () rows = list ( utils . _get_tabulate_rows ( path , self , depth , tree_part_types , signature , param_types ) ) modules = [ row [ 0 ] for row in rows ] rows = [ row [ 1 :] for row in rows ] if call_info is not None : for module , row in zip ( modules , rows ): if module in call_info : inputs , outputs = call_info [ module ] simplified_inputs = ( inputs . args [ 0 ] if len ( inputs . kwargs ) == 0 and len ( inputs . args ) == 1 else inputs . kwargs if len ( inputs . kwargs ) == 0 else inputs . kwargs if len ( inputs . args ) == 0 else ( inputs . args , inputs . kwargs ) ) inputs_repr = utils . _format_param_tree ( simplified_inputs ) outputs_repr = utils . _format_param_tree ( outputs ) else : inputs_repr = \"\" outputs_repr = \"\" row . insert ( 3 , outputs_repr ) row . insert ( 3 , inputs_repr ) n_non_treepart_cols = 2 if call_info is None else 4 rows [ 0 ][ 0 ] = \"*\" rows . append ( [ \"\" ] * n_non_treepart_cols + [ \"Total:\" ] + [ utils . _format_obj_size ( self . filter ( kind ), add_padding = True ) for kind in tree_part_types ] ) utils . _add_padding ( rows ) table = Table ( show_header = True , show_lines = True , show_footer = True , # box=rich.box.HORIZONTALS, ) table . add_column ( \"path\" ) table . add_column ( \"module\" ) table . add_column ( \"params\" ) if call_info is not None : table . add_column ( \"inputs\" ) table . add_column ( \"outputs\" ) for tree_part_type in tree_part_types : type_name = tree_part_type . __name__ if type_name . startswith ( \"_\" ): type_name = type_name [ 1 :] table . add_column ( type_name ) for row in rows [: - 1 ]: table . add_row ( * row ) table . columns [ n_non_treepart_cols ] . footer = Text . from_markup ( rows [ - 1 ][ n_non_treepart_cols ], justify = \"right\" ) for i in range ( len ( tree_part_types )): table . columns [ n_non_treepart_cols + 1 + i ] . footer = rows [ - 1 ][ n_non_treepart_cols + 1 + i ] table . caption_style = \"bold\" table . caption = \" \\n Total Parameters: \" + utils . _format_obj_size ( self , add_padding = False ) return utils . _get_rich_repr ( table ) to_dict ( self , * , private_fields = False , static_fields = True , type_info = False , field_info = False ) inherited to_dict is a wrapper over treeo.to_dict that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True type_info bool If True , type information is included. False field_info bool If True , field information is included. False Returns: Type Description Any A dict representation of the object. Source code in treex/nn/flax_module.py def to_dict ( self , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : \"\"\" `to_dict` is a wrapper over `treeo.to_dict` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. type_info: If `True`, type information is included. field_info: If `True`, field information is included. Returns: A dict representation of the object. \"\"\" return api . to_dict ( self , private_fields = private_fields , static_fields = static_fields , type_info = type_info , field_info = field_info , ) to_string ( self , * , private_fields = False , static_fields = True , color = False ) inherited to_string is a wrapper over treeo.to_string that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True color bool If True , color is included. False Returns: Type Description str A string representation of the object. Source code in treex/nn/flax_module.py def to_string ( self : A , * , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" `to_string` is a wrapper over `treeo.to_string` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. color: If `True`, color is included. Returns: A string representation of the object. \"\"\" return api . to_string ( self , private_fields = private_fields , static_fields = static_fields , color = color , ) train ( self , mode = True , inplace = False ) inherited Creates a new module with the same structure, but with Module.training set to the given value. Parameters: Name Type Description Default mode bool The new training mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~M The new module in with the training mode is set to the given value, if inplace is True then self is returned. Source code in treex/nn/flax_module.py def train ( self : M , mode : bool = True , inplace : bool = False ) -> M : \"\"\" Creates a new module with the same structure, but with `Module.training` set to the given value. Arguments: mode: The new training mode. inplace: Whether to update the module inplace. Returns: The new module in with the training mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_training ( module : Module ): if isinstance ( module , Module ): module . _training = mode return to . apply ( set_training , self , inplace = inplace ) unfreeze ( self , inplace = False ) inherited Creates a new module with .frozen set to False, equivalent to calling freeze(False) . Parameters: Name Type Description Default inplace bool Whether to update the module inplace. False Returns: Type Description ~M The new module with .frozen set to False, if inplace is True then self is returned. Source code in treex/nn/flax_module.py def unfreeze ( self : M , inplace : bool = False ) -> M : \"\"\" Creates a new module with `.frozen` set to False, equivalent to calling `freeze(False)`. Arguments: inplace: Whether to update the module inplace. Returns: The new module with `.frozen` set to False, if `inplace` is `True` then `self` is returned. \"\"\" return self . freeze ( False , inplace = inplace )","title":"FlaxModule"},{"location":"api/FlaxModule/#treexflaxmodule","text":"","title":"treex.FlaxModule"},{"location":"api/FlaxModule/#treex.nn.flax_module.FlaxModule.first_run","text":"Returns: Type Description bool True if its currently the first run of a compact method.","title":"first_run"},{"location":"api/FlaxModule/#treex.nn.flax_module.FlaxModule.__class__","text":"","title":"__class__"},{"location":"api/FlaxModule/#treex.nn.flax_module.FlaxModule.__class__.__base__","text":"Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()).","title":"__base__"},{"location":"api/FlaxModule/#treex.nn.flax_module.FlaxModule.__class__.__base__.__instancecheck__","text":"Override for isinstance(instance, cls). Source code in treex/nn/flax_module.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance )","title":"__instancecheck__()"},{"location":"api/FlaxModule/#treex.nn.flax_module.FlaxModule.__class__.__base__.__new__","text":"Create and return a new object. See help(type) for accurate signature. Source code in treex/nn/flax_module.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls","title":"__new__()"},{"location":"api/FlaxModule/#treex.nn.flax_module.FlaxModule.__class__.__base__.__subclasscheck__","text":"Override for issubclass(subclass, cls). Source code in treex/nn/flax_module.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass )","title":"__subclasscheck__()"},{"location":"api/FlaxModule/#treex.nn.flax_module.FlaxModule.__class__.__base__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/flax_module.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/FlaxModule/#treex.nn.flax_module.FlaxModule.__class__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/flax_module.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/FlaxModule/#treex.nn.flax_module.FlaxModule.apply","text":"apply is a wrapper over treeo.apply that passes self as the second argument. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treex/nn/flax_module.py def apply ( self : A , f : tp . Callable [ ... , None ], * rest : A , inplace : bool = False ) -> A : \"\"\" `apply` is a wrapper over `treeo.apply` that passes `self` as the second argument. Arguments: f: The function to apply. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" return api . apply ( f , self , * rest , inplace = inplace )","title":"apply()"},{"location":"api/FlaxModule/#treex.nn.flax_module.FlaxModule.check_metadata_updates","text":"Checks for new fields, if found, adds them to the metadata. Source code in treex/nn/flax_module.py def check_metadata_updates ( self ): \"\"\" Checks for new fields, if found, adds them to the metadata. \"\"\" with _CONTEXT . update ( flatten_mode = FlattenMode . all_fields ): jax . tree_flatten ( self )","title":"check_metadata_updates()"},{"location":"api/FlaxModule/#treex.nn.flax_module.FlaxModule.copy","text":"copy is a wrapper over treeo.copy that passes self as the first argument. Source code in treex/nn/flax_module.py def copy ( self : A ) -> A : \"\"\" `copy` is a wrapper over `treeo.copy` that passes `self` as the first argument. \"\"\" return tree_m . copy ( self )","title":"copy()"},{"location":"api/FlaxModule/#treex.nn.flax_module.FlaxModule.eval","text":"Creates a new module with the training mode set to False, equivalent to calling train(False) . Returns: Type Description ~M The new module with the training mode set to False. Source code in treex/nn/flax_module.py def eval ( self : M , inplace : bool = False ) -> M : \"\"\" Creates a new module with the training mode set to False, equivalent to calling `train(False)`. Returns: The new module with the training mode set to False. \"\"\" return self . train ( False , inplace = inplace )","title":"eval()"},{"location":"api/FlaxModule/#treex.nn.flax_module.FlaxModule.filter","text":"filter is a wrapper over treeo.filter that passes self as the first argument. Parameters: Name Type Description Default *filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treex/nn/flax_module.py def filter ( self : A , * filters : api . Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ) -> A : \"\"\" `filter` is a wrapper over `treeo.filter` that passes `self` as the first argument. Arguments: *filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" return api . filter ( self , * filters , inplace = inplace , flatten_mode = flatten_mode )","title":"filter()"},{"location":"api/FlaxModule/#treex.nn.flax_module.FlaxModule.freeze","text":"Creates a new module with the same structure, but with Module.frozen set to the given value. Parameters: Name Type Description Default mode bool The new frozen mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~M The new module in with the frozen mode is set to the given value, if inplace is True then self is returned. Source code in treex/nn/flax_module.py def freeze ( self : M , mode : bool = True , inplace : bool = False ) -> M : \"\"\" Creates a new module with the same structure, but with `Module.frozen` set to the given value. Arguments: mode: The new `frozen` mode. inplace: Whether to update the module inplace. Returns: The new module in with the `frozen` mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_frozen ( module : Module ): if isinstance ( module , Module ): module . _frozen = mode return to . apply ( set_frozen , self , inplace = inplace )","title":"freeze()"},{"location":"api/FlaxModule/#treex.nn.flax_module.FlaxModule.get_field","text":"A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: The field must be declared in the class definition. The method can only be called inside a compact context. Parameters: Name Type Description Default field_name str The name of the field to get. required initializer Callable[[], ~A] The function to initialize the field if it does not exist. required Returns: Type Description ~A The field value. Source code in treex/nn/flax_module.py def get_field ( self , field_name : str , initializer : tp . Callable [[], A ], ) -> A : \"\"\" A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: * The field must be declared in the class definition. * The method can only be called inside a `compact` context. Arguments: field_name: The name of the field to get. initializer: The function to initialize the field if it does not exist. Returns: The field value. \"\"\" value : A if field_name not in self . _field_metadata : raise ValueError ( f \"Metadata for field ' { field_name } ' does not exist.\" ) if tree_m . _COMPACT_CONTEXT . current_tree is not self : raise RuntimeError ( f \"Object ' { type ( self ) . __name__ } ' is not the current tree, found ' { type ( tree_m . _COMPACT_CONTEXT . current_tree ) . __name__ } ', did you forget the @compact decorator?\" ) if field_name in vars ( self ): value = getattr ( self , field_name ) else : if tree_m . _COMPACT_CONTEXT . in_compact and not self . first_run : raise RuntimeError ( f \"Trying to initialize field ' { field_name } ' after the first run of `compact`.\" ) value = initializer () setattr ( self , field_name , value ) return value","title":"get_field()"},{"location":"api/FlaxModule/#treex.nn.flax_module.FlaxModule.init","text":"Method version of tx.init , it applies self as first argument. init creates a new module with the same structure, but with its fields initialized given a seed key . The following procedure is used: The input key is split and iteratively updated before passing a derived value to any process that requires initialization. Initializer s are called and applied to the module first. Module.rng_init methods are called last. Parameters: Name Type Description Default key Union[int, jax._src.numpy.lax_numpy.ndarray] The seed to use for initialization. required Returns: Type Description ~M The new module with the fields initialized. Source code in treex/nn/flax_module.py def init ( self : M , key : tp . Union [ int , jnp . ndarray ], inplace : bool = False ) -> M : \"\"\" Method version of `tx.init`, it applies `self` as first argument. `init` creates a new module with the same structure, but with its fields initialized given a seed `key`. The following procedure is used: 1. The input `key` is split and iteratively updated before passing a derived value to any process that requires initialization. 2. `Initializer`s are called and applied to the module first. 3. `Module.rng_init` methods are called last. Arguments: key: The seed to use for initialization. Returns: The new module with the fields initialized. \"\"\" if isinstance ( key , int ): key = jax . random . PRNGKey ( key ) def next_key () -> jnp . ndarray : nonlocal key assert isinstance ( key , ( np . ndarray , jnp . ndarray )) next_key , key = utils . iter_split ( key ) return next_key tree_out : M = jax . tree_map ( lambda initializer : ( initializer ( next_key ()) if isinstance ( initializer , types . Initializer ) else initializer ), self , is_leaf = lambda x : isinstance ( x , types . Initializer ), ) if inplace : # here we update initialized fields by the above tree_map tree_out = to . merge ( self , tree_out , inplace = True ) def call_module_init ( module : Module ): if isinstance ( module , Module ) and not module . _initialized : module . rng_init ( next_key ()) module . _initialized = True return to . apply ( call_module_init , tree_out , inplace = inplace )","title":"init()"},{"location":"api/FlaxModule/#treex.nn.flax_module.FlaxModule.logs","text":"Returns a copy of the Module with only tx.Log TreeParts, alias for filter(tx.Log) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/flax_module.py def logs ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Log TreeParts, alias for `filter(tx.Log)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . Log , * filters )","title":"logs()"},{"location":"api/FlaxModule/#treex.nn.flax_module.FlaxModule.losses","text":"Returns a copy of the Module with only tx.Loss TreeParts, alias for filter(tx.Loss) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/flax_module.py def losses ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Loss TreeParts, alias for `filter(tx.Loss)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . LossLog , * filters )","title":"losses()"},{"location":"api/FlaxModule/#treex.nn.flax_module.FlaxModule.map","text":"map is a wrapper over treeo.map that passes self as the second argument. Parameters: Name Type Description Default f Callable The function to apply to the leaves. required *filters Filter The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treex/nn/flax_module.py def map ( self : A , f : tp . Callable , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , is_leaf : tp . Callable [[ tp . Any ], bool ] = None , ) -> A : \"\"\" `map` is a wrapper over `treeo.map` that passes `self` as the second argument. Arguments: f: The function to apply to the leaves. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" return api . map ( f , self , * filters , inplace = inplace , flatten_mode = flatten_mode , is_leaf = is_leaf , )","title":"map()"},{"location":"api/FlaxModule/#treex.nn.flax_module.FlaxModule.merge","text":"merge is a wrapper over treeo.merge that passes self as the first argument. Parameters: Name Type Description Default other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the merged values. If inplace is True , obj is returned. Source code in treex/nn/flax_module.py def merge ( self : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" `merge` is a wrapper over `treeo.merge` that passes `self` as the first argument. Arguments: other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the merged values. If `inplace` is `True`, `obj` is returned. \"\"\" return api . merge ( self , other , * rest , inplace = inplace , flatten_mode = flatten_mode , ignore_static = ignore_static , )","title":"merge()"},{"location":"api/FlaxModule/#treex.nn.flax_module.FlaxModule.metrics","text":"Returns a copy of the Module with only tx.Metric TreeParts, alias for filter(tx.Metric) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/flax_module.py def metrics ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Metric TreeParts, alias for `filter(tx.Metric)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . MetricLog , * filters )","title":"metrics()"},{"location":"api/FlaxModule/#treex.nn.flax_module.FlaxModule.model_states","text":"Returns a copy of the Module with only tx.ModelState TreeParts, alias for filter(tx.ModelState) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/flax_module.py def model_states ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.ModelState TreeParts, alias for `filter(tx.ModelState)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . ModelState , * filters )","title":"model_states()"},{"location":"api/FlaxModule/#treex.nn.flax_module.FlaxModule.parameters","text":"Returns a copy of the Module with only tx.Parameter TreeParts, alias for filter(tx.Parameter) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/flax_module.py def parameters ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Parameter TreeParts, alias for `filter(tx.Parameter)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . Parameter , * filters )","title":"parameters()"},{"location":"api/FlaxModule/#treex.nn.flax_module.FlaxModule.rngs","text":"Returns a copy of the Module with only tx.Rng TreeParts, alias for filter(tx.Rng) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/flax_module.py def rngs ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Rng TreeParts, alias for `filter(tx.Rng)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . Rng , * filters )","title":"rngs()"},{"location":"api/FlaxModule/#treex.nn.flax_module.FlaxModule.states","text":"Returns a copy of the Module with only tx.State TreeParts, alias for filter(tx.State) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/flax_module.py def states ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.State TreeParts, alias for `filter(tx.State)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . State , * filters )","title":"states()"},{"location":"api/FlaxModule/#treex.nn.flax_module.FlaxModule.tabulate","text":"Returns a tabular representation of the module. Parameters: Name Type Description Default depth int The maximum depth of the representation in terms of nested Modules, -1 means no limit. -1 signature bool Whether to show the signature of the Module. False param_types bool Whether to show the types of the parameters. True Returns: Type Description str A string containing the tabular representation. Source code in treex/nn/flax_module.py def tabulate ( self , inputs : tp . Union [ tp . Any , types . Inputs , None ] = None , depth : int = - 1 , signature : bool = False , param_types : bool = True , ) -> str : \"\"\" Returns a tabular representation of the module. Arguments: depth: The maximum depth of the representation in terms of nested Modules, -1 means no limit. signature: Whether to show the signature of the Module. param_types: Whether to show the types of the parameters. Returns: A string containing the tabular representation. \"\"\" self = to . copy ( self ) if inputs is not None : if not isinstance ( inputs , types . Inputs ): inputs = types . Inputs ( inputs ) inputs = tp . cast ( types . Inputs , inputs ) if not isinstance ( self , tp . Callable ): raise TypeError ( \"`inputs` can only be specified if the module is a callable.\" ) with _Context ( call_info = {}): # call using self to preserve references def eval_call ( args , kwargs ): assert isinstance ( self , tp . Callable ) return self ( * args , ** kwargs ) jax . eval_shape ( eval_call , inputs . args , inputs . kwargs , ) call_info = _CONTEXT . call_info else : call_info = None with to . add_field_info (): flat : tp . List [ to . FieldInfo ] flat , _ = jax . tree_flatten ( self ) tree_part_types : tp . Tuple [ tp . Type [ types . TreePart ], ... ] = tuple ( { field_info . kind for field_info in flat if utils . _generic_issubclass ( field_info . kind , types . TreePart ) } ) path = () rows = list ( utils . _get_tabulate_rows ( path , self , depth , tree_part_types , signature , param_types ) ) modules = [ row [ 0 ] for row in rows ] rows = [ row [ 1 :] for row in rows ] if call_info is not None : for module , row in zip ( modules , rows ): if module in call_info : inputs , outputs = call_info [ module ] simplified_inputs = ( inputs . args [ 0 ] if len ( inputs . kwargs ) == 0 and len ( inputs . args ) == 1 else inputs . kwargs if len ( inputs . kwargs ) == 0 else inputs . kwargs if len ( inputs . args ) == 0 else ( inputs . args , inputs . kwargs ) ) inputs_repr = utils . _format_param_tree ( simplified_inputs ) outputs_repr = utils . _format_param_tree ( outputs ) else : inputs_repr = \"\" outputs_repr = \"\" row . insert ( 3 , outputs_repr ) row . insert ( 3 , inputs_repr ) n_non_treepart_cols = 2 if call_info is None else 4 rows [ 0 ][ 0 ] = \"*\" rows . append ( [ \"\" ] * n_non_treepart_cols + [ \"Total:\" ] + [ utils . _format_obj_size ( self . filter ( kind ), add_padding = True ) for kind in tree_part_types ] ) utils . _add_padding ( rows ) table = Table ( show_header = True , show_lines = True , show_footer = True , # box=rich.box.HORIZONTALS, ) table . add_column ( \"path\" ) table . add_column ( \"module\" ) table . add_column ( \"params\" ) if call_info is not None : table . add_column ( \"inputs\" ) table . add_column ( \"outputs\" ) for tree_part_type in tree_part_types : type_name = tree_part_type . __name__ if type_name . startswith ( \"_\" ): type_name = type_name [ 1 :] table . add_column ( type_name ) for row in rows [: - 1 ]: table . add_row ( * row ) table . columns [ n_non_treepart_cols ] . footer = Text . from_markup ( rows [ - 1 ][ n_non_treepart_cols ], justify = \"right\" ) for i in range ( len ( tree_part_types )): table . columns [ n_non_treepart_cols + 1 + i ] . footer = rows [ - 1 ][ n_non_treepart_cols + 1 + i ] table . caption_style = \"bold\" table . caption = \" \\n Total Parameters: \" + utils . _format_obj_size ( self , add_padding = False ) return utils . _get_rich_repr ( table )","title":"tabulate()"},{"location":"api/FlaxModule/#treex.nn.flax_module.FlaxModule.to_dict","text":"to_dict is a wrapper over treeo.to_dict that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True type_info bool If True , type information is included. False field_info bool If True , field information is included. False Returns: Type Description Any A dict representation of the object. Source code in treex/nn/flax_module.py def to_dict ( self , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : \"\"\" `to_dict` is a wrapper over `treeo.to_dict` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. type_info: If `True`, type information is included. field_info: If `True`, field information is included. Returns: A dict representation of the object. \"\"\" return api . to_dict ( self , private_fields = private_fields , static_fields = static_fields , type_info = type_info , field_info = field_info , )","title":"to_dict()"},{"location":"api/FlaxModule/#treex.nn.flax_module.FlaxModule.to_string","text":"to_string is a wrapper over treeo.to_string that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True color bool If True , color is included. False Returns: Type Description str A string representation of the object. Source code in treex/nn/flax_module.py def to_string ( self : A , * , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" `to_string` is a wrapper over `treeo.to_string` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. color: If `True`, color is included. Returns: A string representation of the object. \"\"\" return api . to_string ( self , private_fields = private_fields , static_fields = static_fields , color = color , )","title":"to_string()"},{"location":"api/FlaxModule/#treex.nn.flax_module.FlaxModule.train","text":"Creates a new module with the same structure, but with Module.training set to the given value. Parameters: Name Type Description Default mode bool The new training mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~M The new module in with the training mode is set to the given value, if inplace is True then self is returned. Source code in treex/nn/flax_module.py def train ( self : M , mode : bool = True , inplace : bool = False ) -> M : \"\"\" Creates a new module with the same structure, but with `Module.training` set to the given value. Arguments: mode: The new training mode. inplace: Whether to update the module inplace. Returns: The new module in with the training mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_training ( module : Module ): if isinstance ( module , Module ): module . _training = mode return to . apply ( set_training , self , inplace = inplace )","title":"train()"},{"location":"api/FlaxModule/#treex.nn.flax_module.FlaxModule.unfreeze","text":"Creates a new module with .frozen set to False, equivalent to calling freeze(False) . Parameters: Name Type Description Default inplace bool Whether to update the module inplace. False Returns: Type Description ~M The new module with .frozen set to False, if inplace is True then self is returned. Source code in treex/nn/flax_module.py def unfreeze ( self : M , inplace : bool = False ) -> M : \"\"\" Creates a new module with `.frozen` set to False, equivalent to calling `freeze(False)`. Arguments: inplace: Whether to update the module inplace. Returns: The new module with `.frozen` set to False, if `inplace` is `True` then `self` is returned. \"\"\" return self . freeze ( False , inplace = inplace )","title":"unfreeze()"},{"location":"api/Hashable/","text":"treex.Hashable A hashable immutable wrapper around non-hashable values","title":"Hashable"},{"location":"api/Hashable/#treexhashable","text":"A hashable immutable wrapper around non-hashable values","title":"treex.Hashable"},{"location":"api/Initializer/","text":"treex.Initializer Initialize a field from a function that expects a single argument with a PRNGKey. Initializers are called by Module.init and replace the value of the field they are assigned to. __class__ inherited __base__ inherited Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()). __instancecheck__ ( cls , instance ) special Override for isinstance(instance, cls). Source code in treex/types.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance ) __new__ ( mcls , name , bases , namespace , ** kwargs ) special staticmethod Create and return a new object. See help(type) for accurate signature. Source code in treex/types.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls __subclasscheck__ ( cls , subclass ) special Override for issubclass(subclass, cls). Source code in treex/types.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass ) register ( cls , subclass ) Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/types.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) register ( cls , subclass ) inherited Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/types.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) __init__ ( self , f ) special Parameters: Name Type Description Default f Callable[[jax._src.numpy.lax_numpy.ndarray], Any] A function that takes a PRNGKey and returns the initial value of the field. required Source code in treex/types.py def __init__ ( self , f : tp . Callable [[ jnp . ndarray ], tp . Any ]): \"\"\" Arguments: f: A function that takes a PRNGKey and returns the initial value of the field. \"\"\" self . f = f check_metadata_updates ( self ) inherited Checks for new fields, if found, adds them to the metadata. Source code in treex/types.py def check_metadata_updates ( self ): \"\"\" Checks for new fields, if found, adds them to the metadata. \"\"\" with _CONTEXT . update ( flatten_mode = FlattenMode . all_fields ): jax . tree_flatten ( self )","title":"Initializer"},{"location":"api/Initializer/#treexinitializer","text":"Initialize a field from a function that expects a single argument with a PRNGKey. Initializers are called by Module.init and replace the value of the field they are assigned to.","title":"treex.Initializer"},{"location":"api/Initializer/#treex.types.Initializer.__class__","text":"","title":"__class__"},{"location":"api/Initializer/#treex.types.Initializer.__class__.__base__","text":"Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()).","title":"__base__"},{"location":"api/Initializer/#treex.types.Initializer.__class__.__base__.__instancecheck__","text":"Override for isinstance(instance, cls). Source code in treex/types.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance )","title":"__instancecheck__()"},{"location":"api/Initializer/#treex.types.Initializer.__class__.__base__.__new__","text":"Create and return a new object. See help(type) for accurate signature. Source code in treex/types.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls","title":"__new__()"},{"location":"api/Initializer/#treex.types.Initializer.__class__.__base__.__subclasscheck__","text":"Override for issubclass(subclass, cls). Source code in treex/types.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass )","title":"__subclasscheck__()"},{"location":"api/Initializer/#treex.types.Initializer.__class__.__base__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/types.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/Initializer/#treex.types.Initializer.__class__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/types.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/Initializer/#treex.types.Initializer.__init__","text":"Parameters: Name Type Description Default f Callable[[jax._src.numpy.lax_numpy.ndarray], Any] A function that takes a PRNGKey and returns the initial value of the field. required Source code in treex/types.py def __init__ ( self , f : tp . Callable [[ jnp . ndarray ], tp . Any ]): \"\"\" Arguments: f: A function that takes a PRNGKey and returns the initial value of the field. \"\"\" self . f = f","title":"__init__()"},{"location":"api/Initializer/#treex.types.Initializer.check_metadata_updates","text":"Checks for new fields, if found, adds them to the metadata. Source code in treex/types.py def check_metadata_updates ( self ): \"\"\" Checks for new fields, if found, adds them to the metadata. \"\"\" with _CONTEXT . update ( flatten_mode = FlattenMode . all_fields ): jax . tree_flatten ( self )","title":"check_metadata_updates()"},{"location":"api/Inputs/","text":"treex.Inputs","title":"Inputs"},{"location":"api/Inputs/#treexinputs","text":"","title":"treex.Inputs"},{"location":"api/KeySeq/","text":"treex.KeySeq KeySeq is simple module that can produce a sequence of PRNGKeys. Examples: class Dropout ( Module ): rng : KeySeq () def __init__ ( self , rate : float ): self . next_key = KeySeq () ... def __call__ ( self , x : jnp . ndarray ) -> jnp . ndarray : key = self . next_key () mask = jax . random . bernoulli ( key , 1.0 - self . rate ) ... first_run : bool inherited property readonly Returns: Type Description bool True if its currently the first run of a compact method. __class__ inherited __base__ inherited Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()). __instancecheck__ ( cls , instance ) special Override for isinstance(instance, cls). Source code in treex/key_seq.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance ) __new__ ( mcls , name , bases , namespace , ** kwargs ) special staticmethod Create and return a new object. See help(type) for accurate signature. Source code in treex/key_seq.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls __subclasscheck__ ( cls , subclass ) special Override for issubclass(subclass, cls). Source code in treex/key_seq.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass ) register ( cls , subclass ) Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/key_seq.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) register ( cls , subclass ) inherited Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/key_seq.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) __call__ ( self ) special Return a new PRNGKey and updates the internal rng state. Returns: Type Description ndarray A PRNGKey. Source code in treex/key_seq.py def __call__ ( self ) -> jnp . ndarray : \"\"\" Return a new PRNGKey and updates the internal rng state. Returns: A PRNGKey. \"\"\" assert isinstance ( self . key , jnp . ndarray ) key , self . key = utils . iter_split ( self . key ) return key __init__ ( self , key = None ) special Parameters: Name Type Description Default key Union[jax._src.numpy.lax_numpy.ndarray, int] An optional PRNGKey to initialize the KeySeq with. None Source code in treex/key_seq.py def __init__ ( self , key : tp . Optional [ tp . Union [ jnp . ndarray , int ]] = None ): \"\"\" Arguments: key: An optional PRNGKey to initialize the KeySeq with. \"\"\" self . key = ( jax . random . PRNGKey ( key ) if isinstance ( key , int ) else key if isinstance ( key , ( jnp . ndarray , np . ndarray )) else types . Initializer ( lambda key : key ) ) apply ( self , f , * rest , * , inplace = False ) inherited apply is a wrapper over treeo.apply that passes self as the second argument. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treex/key_seq.py def apply ( self : A , f : tp . Callable [ ... , None ], * rest : A , inplace : bool = False ) -> A : \"\"\" `apply` is a wrapper over `treeo.apply` that passes `self` as the second argument. Arguments: f: The function to apply. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" return api . apply ( f , self , * rest , inplace = inplace ) batch_stats ( self , * filters ) inherited Returns a copy of the Module with only tx.BatchStat TreeParts, alias for filter(tx.BatchStat) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/key_seq.py def batch_stats ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.BatchStat TreeParts, alias for `filter(tx.BatchStat)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . BatchStat , * filters ) check_metadata_updates ( self ) inherited Checks for new fields, if found, adds them to the metadata. Source code in treex/key_seq.py def check_metadata_updates ( self ): \"\"\" Checks for new fields, if found, adds them to the metadata. \"\"\" with _CONTEXT . update ( flatten_mode = FlattenMode . all_fields ): jax . tree_flatten ( self ) copy ( self ) inherited copy is a wrapper over treeo.copy that passes self as the first argument. Source code in treex/key_seq.py def copy ( self : A ) -> A : \"\"\" `copy` is a wrapper over `treeo.copy` that passes `self` as the first argument. \"\"\" return tree_m . copy ( self ) eval ( self , inplace = False ) inherited Creates a new module with the training mode set to False, equivalent to calling train(False) . Returns: Type Description ~M The new module with the training mode set to False. Source code in treex/key_seq.py def eval ( self : M , inplace : bool = False ) -> M : \"\"\" Creates a new module with the training mode set to False, equivalent to calling `train(False)`. Returns: The new module with the training mode set to False. \"\"\" return self . train ( False , inplace = inplace ) filter ( self , * filters , * , inplace = False , flatten_mode = None ) inherited filter is a wrapper over treeo.filter that passes self as the first argument. Parameters: Name Type Description Default *filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treex/key_seq.py def filter ( self : A , * filters : api . Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ) -> A : \"\"\" `filter` is a wrapper over `treeo.filter` that passes `self` as the first argument. Arguments: *filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" return api . filter ( self , * filters , inplace = inplace , flatten_mode = flatten_mode ) freeze ( self , mode = True , inplace = False ) inherited Creates a new module with the same structure, but with Module.frozen set to the given value. Parameters: Name Type Description Default mode bool The new frozen mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~M The new module in with the frozen mode is set to the given value, if inplace is True then self is returned. Source code in treex/key_seq.py def freeze ( self : M , mode : bool = True , inplace : bool = False ) -> M : \"\"\" Creates a new module with the same structure, but with `Module.frozen` set to the given value. Arguments: mode: The new `frozen` mode. inplace: Whether to update the module inplace. Returns: The new module in with the `frozen` mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_frozen ( module : Module ): if isinstance ( module , Module ): module . _frozen = mode return to . apply ( set_frozen , self , inplace = inplace ) get_field ( self , field_name , initializer ) inherited A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: The field must be declared in the class definition. The method can only be called inside a compact context. Parameters: Name Type Description Default field_name str The name of the field to get. required initializer Callable[[], ~A] The function to initialize the field if it does not exist. required Returns: Type Description ~A The field value. Source code in treex/key_seq.py def get_field ( self , field_name : str , initializer : tp . Callable [[], A ], ) -> A : \"\"\" A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: * The field must be declared in the class definition. * The method can only be called inside a `compact` context. Arguments: field_name: The name of the field to get. initializer: The function to initialize the field if it does not exist. Returns: The field value. \"\"\" value : A if field_name not in self . _field_metadata : raise ValueError ( f \"Metadata for field ' { field_name } ' does not exist.\" ) if tree_m . _COMPACT_CONTEXT . current_tree is not self : raise RuntimeError ( f \"Object ' { type ( self ) . __name__ } ' is not the current tree, found ' { type ( tree_m . _COMPACT_CONTEXT . current_tree ) . __name__ } ', did you forget the @compact decorator?\" ) if field_name in vars ( self ): value = getattr ( self , field_name ) else : if tree_m . _COMPACT_CONTEXT . in_compact and not self . first_run : raise RuntimeError ( f \"Trying to initialize field ' { field_name } ' after the first run of `compact`.\" ) value = initializer () setattr ( self , field_name , value ) return value init ( self , key , inplace = False ) inherited Method version of tx.init , it applies self as first argument. init creates a new module with the same structure, but with its fields initialized given a seed key . The following procedure is used: The input key is split and iteratively updated before passing a derived value to any process that requires initialization. Initializer s are called and applied to the module first. Module.rng_init methods are called last. Parameters: Name Type Description Default key Union[int, jax._src.numpy.lax_numpy.ndarray] The seed to use for initialization. required Returns: Type Description ~M The new module with the fields initialized. Source code in treex/key_seq.py def init ( self : M , key : tp . Union [ int , jnp . ndarray ], inplace : bool = False ) -> M : \"\"\" Method version of `tx.init`, it applies `self` as first argument. `init` creates a new module with the same structure, but with its fields initialized given a seed `key`. The following procedure is used: 1. The input `key` is split and iteratively updated before passing a derived value to any process that requires initialization. 2. `Initializer`s are called and applied to the module first. 3. `Module.rng_init` methods are called last. Arguments: key: The seed to use for initialization. Returns: The new module with the fields initialized. \"\"\" if isinstance ( key , int ): key = jax . random . PRNGKey ( key ) def next_key () -> jnp . ndarray : nonlocal key assert isinstance ( key , ( np . ndarray , jnp . ndarray )) next_key , key = utils . iter_split ( key ) return next_key tree_out : M = jax . tree_map ( lambda initializer : ( initializer ( next_key ()) if isinstance ( initializer , types . Initializer ) else initializer ), self , is_leaf = lambda x : isinstance ( x , types . Initializer ), ) if inplace : # here we update initialized fields by the above tree_map tree_out = to . merge ( self , tree_out , inplace = True ) def call_module_init ( module : Module ): if isinstance ( module , Module ) and not module . _initialized : module . rng_init ( next_key ()) module . _initialized = True return to . apply ( call_module_init , tree_out , inplace = inplace ) logs ( self , * filters ) inherited Returns a copy of the Module with only tx.Log TreeParts, alias for filter(tx.Log) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/key_seq.py def logs ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Log TreeParts, alias for `filter(tx.Log)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . Log , * filters ) losses ( self , * filters ) inherited Returns a copy of the Module with only tx.Loss TreeParts, alias for filter(tx.Loss) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/key_seq.py def losses ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Loss TreeParts, alias for `filter(tx.Loss)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . LossLog , * filters ) map ( self , f , * filters , * , inplace = False , flatten_mode = None , is_leaf = None ) inherited map is a wrapper over treeo.map that passes self as the second argument. Parameters: Name Type Description Default f Callable The function to apply to the leaves. required *filters Filter The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treex/key_seq.py def map ( self : A , f : tp . Callable , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , is_leaf : tp . Callable [[ tp . Any ], bool ] = None , ) -> A : \"\"\" `map` is a wrapper over `treeo.map` that passes `self` as the second argument. Arguments: f: The function to apply to the leaves. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" return api . map ( f , self , * filters , inplace = inplace , flatten_mode = flatten_mode , is_leaf = is_leaf , ) merge ( self , other , * rest , * , inplace = False , flatten_mode = None , ignore_static = False ) inherited merge is a wrapper over treeo.merge that passes self as the first argument. Parameters: Name Type Description Default other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the merged values. If inplace is True , obj is returned. Source code in treex/key_seq.py def merge ( self : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" `merge` is a wrapper over `treeo.merge` that passes `self` as the first argument. Arguments: other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the merged values. If `inplace` is `True`, `obj` is returned. \"\"\" return api . merge ( self , other , * rest , inplace = inplace , flatten_mode = flatten_mode , ignore_static = ignore_static , ) metrics ( self , * filters ) inherited Returns a copy of the Module with only tx.Metric TreeParts, alias for filter(tx.Metric) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/key_seq.py def metrics ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Metric TreeParts, alias for `filter(tx.Metric)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . MetricLog , * filters ) model_states ( self , * filters ) inherited Returns a copy of the Module with only tx.ModelState TreeParts, alias for filter(tx.ModelState) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/key_seq.py def model_states ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.ModelState TreeParts, alias for `filter(tx.ModelState)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . ModelState , * filters ) parameters ( self , * filters ) inherited Returns a copy of the Module with only tx.Parameter TreeParts, alias for filter(tx.Parameter) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/key_seq.py def parameters ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Parameter TreeParts, alias for `filter(tx.Parameter)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . Parameter , * filters ) rngs ( self , * filters ) inherited Returns a copy of the Module with only tx.Rng TreeParts, alias for filter(tx.Rng) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/key_seq.py def rngs ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Rng TreeParts, alias for `filter(tx.Rng)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . Rng , * filters ) states ( self , * filters ) inherited Returns a copy of the Module with only tx.State TreeParts, alias for filter(tx.State) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/key_seq.py def states ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.State TreeParts, alias for `filter(tx.State)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . State , * filters ) tabulate ( self , inputs = None , depth =- 1 , signature = False , param_types = True ) inherited Returns a tabular representation of the module. Parameters: Name Type Description Default depth int The maximum depth of the representation in terms of nested Modules, -1 means no limit. -1 signature bool Whether to show the signature of the Module. False param_types bool Whether to show the types of the parameters. True Returns: Type Description str A string containing the tabular representation. Source code in treex/key_seq.py def tabulate ( self , inputs : tp . Union [ tp . Any , types . Inputs , None ] = None , depth : int = - 1 , signature : bool = False , param_types : bool = True , ) -> str : \"\"\" Returns a tabular representation of the module. Arguments: depth: The maximum depth of the representation in terms of nested Modules, -1 means no limit. signature: Whether to show the signature of the Module. param_types: Whether to show the types of the parameters. Returns: A string containing the tabular representation. \"\"\" self = to . copy ( self ) if inputs is not None : if not isinstance ( inputs , types . Inputs ): inputs = types . Inputs ( inputs ) inputs = tp . cast ( types . Inputs , inputs ) if not isinstance ( self , tp . Callable ): raise TypeError ( \"`inputs` can only be specified if the module is a callable.\" ) with _Context ( call_info = {}): # call using self to preserve references def eval_call ( args , kwargs ): assert isinstance ( self , tp . Callable ) return self ( * args , ** kwargs ) jax . eval_shape ( eval_call , inputs . args , inputs . kwargs , ) call_info = _CONTEXT . call_info else : call_info = None with to . add_field_info (): flat : tp . List [ to . FieldInfo ] flat , _ = jax . tree_flatten ( self ) tree_part_types : tp . Tuple [ tp . Type [ types . TreePart ], ... ] = tuple ( { field_info . kind for field_info in flat if utils . _generic_issubclass ( field_info . kind , types . TreePart ) } ) path = () rows = list ( utils . _get_tabulate_rows ( path , self , depth , tree_part_types , signature , param_types ) ) modules = [ row [ 0 ] for row in rows ] rows = [ row [ 1 :] for row in rows ] if call_info is not None : for module , row in zip ( modules , rows ): if module in call_info : inputs , outputs = call_info [ module ] simplified_inputs = ( inputs . args [ 0 ] if len ( inputs . kwargs ) == 0 and len ( inputs . args ) == 1 else inputs . kwargs if len ( inputs . kwargs ) == 0 else inputs . kwargs if len ( inputs . args ) == 0 else ( inputs . args , inputs . kwargs ) ) inputs_repr = utils . _format_param_tree ( simplified_inputs ) outputs_repr = utils . _format_param_tree ( outputs ) else : inputs_repr = \"\" outputs_repr = \"\" row . insert ( 3 , outputs_repr ) row . insert ( 3 , inputs_repr ) n_non_treepart_cols = 2 if call_info is None else 4 rows [ 0 ][ 0 ] = \"*\" rows . append ( [ \"\" ] * n_non_treepart_cols + [ \"Total:\" ] + [ utils . _format_obj_size ( self . filter ( kind ), add_padding = True ) for kind in tree_part_types ] ) utils . _add_padding ( rows ) table = Table ( show_header = True , show_lines = True , show_footer = True , # box=rich.box.HORIZONTALS, ) table . add_column ( \"path\" ) table . add_column ( \"module\" ) table . add_column ( \"params\" ) if call_info is not None : table . add_column ( \"inputs\" ) table . add_column ( \"outputs\" ) for tree_part_type in tree_part_types : type_name = tree_part_type . __name__ if type_name . startswith ( \"_\" ): type_name = type_name [ 1 :] table . add_column ( type_name ) for row in rows [: - 1 ]: table . add_row ( * row ) table . columns [ n_non_treepart_cols ] . footer = Text . from_markup ( rows [ - 1 ][ n_non_treepart_cols ], justify = \"right\" ) for i in range ( len ( tree_part_types )): table . columns [ n_non_treepart_cols + 1 + i ] . footer = rows [ - 1 ][ n_non_treepart_cols + 1 + i ] table . caption_style = \"bold\" table . caption = \" \\n Total Parameters: \" + utils . _format_obj_size ( self , add_padding = False ) return utils . _get_rich_repr ( table ) to_dict ( self , * , private_fields = False , static_fields = True , type_info = False , field_info = False ) inherited to_dict is a wrapper over treeo.to_dict that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True type_info bool If True , type information is included. False field_info bool If True , field information is included. False Returns: Type Description Any A dict representation of the object. Source code in treex/key_seq.py def to_dict ( self , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : \"\"\" `to_dict` is a wrapper over `treeo.to_dict` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. type_info: If `True`, type information is included. field_info: If `True`, field information is included. Returns: A dict representation of the object. \"\"\" return api . to_dict ( self , private_fields = private_fields , static_fields = static_fields , type_info = type_info , field_info = field_info , ) to_string ( self , * , private_fields = False , static_fields = True , color = False ) inherited to_string is a wrapper over treeo.to_string that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True color bool If True , color is included. False Returns: Type Description str A string representation of the object. Source code in treex/key_seq.py def to_string ( self : A , * , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" `to_string` is a wrapper over `treeo.to_string` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. color: If `True`, color is included. Returns: A string representation of the object. \"\"\" return api . to_string ( self , private_fields = private_fields , static_fields = static_fields , color = color , ) train ( self , mode = True , inplace = False ) inherited Creates a new module with the same structure, but with Module.training set to the given value. Parameters: Name Type Description Default mode bool The new training mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~M The new module in with the training mode is set to the given value, if inplace is True then self is returned. Source code in treex/key_seq.py def train ( self : M , mode : bool = True , inplace : bool = False ) -> M : \"\"\" Creates a new module with the same structure, but with `Module.training` set to the given value. Arguments: mode: The new training mode. inplace: Whether to update the module inplace. Returns: The new module in with the training mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_training ( module : Module ): if isinstance ( module , Module ): module . _training = mode return to . apply ( set_training , self , inplace = inplace ) unfreeze ( self , inplace = False ) inherited Creates a new module with .frozen set to False, equivalent to calling freeze(False) . Parameters: Name Type Description Default inplace bool Whether to update the module inplace. False Returns: Type Description ~M The new module with .frozen set to False, if inplace is True then self is returned. Source code in treex/key_seq.py def unfreeze ( self : M , inplace : bool = False ) -> M : \"\"\" Creates a new module with `.frozen` set to False, equivalent to calling `freeze(False)`. Arguments: inplace: Whether to update the module inplace. Returns: The new module with `.frozen` set to False, if `inplace` is `True` then `self` is returned. \"\"\" return self . freeze ( False , inplace = inplace )","title":"KeySeq"},{"location":"api/KeySeq/#treexkeyseq","text":"KeySeq is simple module that can produce a sequence of PRNGKeys. Examples: class Dropout ( Module ): rng : KeySeq () def __init__ ( self , rate : float ): self . next_key = KeySeq () ... def __call__ ( self , x : jnp . ndarray ) -> jnp . ndarray : key = self . next_key () mask = jax . random . bernoulli ( key , 1.0 - self . rate ) ...","title":"treex.KeySeq"},{"location":"api/KeySeq/#treex.key_seq.KeySeq.first_run","text":"Returns: Type Description bool True if its currently the first run of a compact method.","title":"first_run"},{"location":"api/KeySeq/#treex.key_seq.KeySeq.__class__","text":"","title":"__class__"},{"location":"api/KeySeq/#treex.key_seq.KeySeq.__class__.__base__","text":"Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()).","title":"__base__"},{"location":"api/KeySeq/#treex.key_seq.KeySeq.__class__.__base__.__instancecheck__","text":"Override for isinstance(instance, cls). Source code in treex/key_seq.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance )","title":"__instancecheck__()"},{"location":"api/KeySeq/#treex.key_seq.KeySeq.__class__.__base__.__new__","text":"Create and return a new object. See help(type) for accurate signature. Source code in treex/key_seq.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls","title":"__new__()"},{"location":"api/KeySeq/#treex.key_seq.KeySeq.__class__.__base__.__subclasscheck__","text":"Override for issubclass(subclass, cls). Source code in treex/key_seq.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass )","title":"__subclasscheck__()"},{"location":"api/KeySeq/#treex.key_seq.KeySeq.__class__.__base__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/key_seq.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/KeySeq/#treex.key_seq.KeySeq.__class__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/key_seq.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/KeySeq/#treex.key_seq.KeySeq.__call__","text":"Return a new PRNGKey and updates the internal rng state. Returns: Type Description ndarray A PRNGKey. Source code in treex/key_seq.py def __call__ ( self ) -> jnp . ndarray : \"\"\" Return a new PRNGKey and updates the internal rng state. Returns: A PRNGKey. \"\"\" assert isinstance ( self . key , jnp . ndarray ) key , self . key = utils . iter_split ( self . key ) return key","title":"__call__()"},{"location":"api/KeySeq/#treex.key_seq.KeySeq.__init__","text":"Parameters: Name Type Description Default key Union[jax._src.numpy.lax_numpy.ndarray, int] An optional PRNGKey to initialize the KeySeq with. None Source code in treex/key_seq.py def __init__ ( self , key : tp . Optional [ tp . Union [ jnp . ndarray , int ]] = None ): \"\"\" Arguments: key: An optional PRNGKey to initialize the KeySeq with. \"\"\" self . key = ( jax . random . PRNGKey ( key ) if isinstance ( key , int ) else key if isinstance ( key , ( jnp . ndarray , np . ndarray )) else types . Initializer ( lambda key : key ) )","title":"__init__()"},{"location":"api/KeySeq/#treex.key_seq.KeySeq.apply","text":"apply is a wrapper over treeo.apply that passes self as the second argument. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treex/key_seq.py def apply ( self : A , f : tp . Callable [ ... , None ], * rest : A , inplace : bool = False ) -> A : \"\"\" `apply` is a wrapper over `treeo.apply` that passes `self` as the second argument. Arguments: f: The function to apply. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" return api . apply ( f , self , * rest , inplace = inplace )","title":"apply()"},{"location":"api/KeySeq/#treex.key_seq.KeySeq.batch_stats","text":"Returns a copy of the Module with only tx.BatchStat TreeParts, alias for filter(tx.BatchStat) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/key_seq.py def batch_stats ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.BatchStat TreeParts, alias for `filter(tx.BatchStat)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . BatchStat , * filters )","title":"batch_stats()"},{"location":"api/KeySeq/#treex.key_seq.KeySeq.check_metadata_updates","text":"Checks for new fields, if found, adds them to the metadata. Source code in treex/key_seq.py def check_metadata_updates ( self ): \"\"\" Checks for new fields, if found, adds them to the metadata. \"\"\" with _CONTEXT . update ( flatten_mode = FlattenMode . all_fields ): jax . tree_flatten ( self )","title":"check_metadata_updates()"},{"location":"api/KeySeq/#treex.key_seq.KeySeq.copy","text":"copy is a wrapper over treeo.copy that passes self as the first argument. Source code in treex/key_seq.py def copy ( self : A ) -> A : \"\"\" `copy` is a wrapper over `treeo.copy` that passes `self` as the first argument. \"\"\" return tree_m . copy ( self )","title":"copy()"},{"location":"api/KeySeq/#treex.key_seq.KeySeq.eval","text":"Creates a new module with the training mode set to False, equivalent to calling train(False) . Returns: Type Description ~M The new module with the training mode set to False. Source code in treex/key_seq.py def eval ( self : M , inplace : bool = False ) -> M : \"\"\" Creates a new module with the training mode set to False, equivalent to calling `train(False)`. Returns: The new module with the training mode set to False. \"\"\" return self . train ( False , inplace = inplace )","title":"eval()"},{"location":"api/KeySeq/#treex.key_seq.KeySeq.filter","text":"filter is a wrapper over treeo.filter that passes self as the first argument. Parameters: Name Type Description Default *filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treex/key_seq.py def filter ( self : A , * filters : api . Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ) -> A : \"\"\" `filter` is a wrapper over `treeo.filter` that passes `self` as the first argument. Arguments: *filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" return api . filter ( self , * filters , inplace = inplace , flatten_mode = flatten_mode )","title":"filter()"},{"location":"api/KeySeq/#treex.key_seq.KeySeq.freeze","text":"Creates a new module with the same structure, but with Module.frozen set to the given value. Parameters: Name Type Description Default mode bool The new frozen mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~M The new module in with the frozen mode is set to the given value, if inplace is True then self is returned. Source code in treex/key_seq.py def freeze ( self : M , mode : bool = True , inplace : bool = False ) -> M : \"\"\" Creates a new module with the same structure, but with `Module.frozen` set to the given value. Arguments: mode: The new `frozen` mode. inplace: Whether to update the module inplace. Returns: The new module in with the `frozen` mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_frozen ( module : Module ): if isinstance ( module , Module ): module . _frozen = mode return to . apply ( set_frozen , self , inplace = inplace )","title":"freeze()"},{"location":"api/KeySeq/#treex.key_seq.KeySeq.get_field","text":"A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: The field must be declared in the class definition. The method can only be called inside a compact context. Parameters: Name Type Description Default field_name str The name of the field to get. required initializer Callable[[], ~A] The function to initialize the field if it does not exist. required Returns: Type Description ~A The field value. Source code in treex/key_seq.py def get_field ( self , field_name : str , initializer : tp . Callable [[], A ], ) -> A : \"\"\" A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: * The field must be declared in the class definition. * The method can only be called inside a `compact` context. Arguments: field_name: The name of the field to get. initializer: The function to initialize the field if it does not exist. Returns: The field value. \"\"\" value : A if field_name not in self . _field_metadata : raise ValueError ( f \"Metadata for field ' { field_name } ' does not exist.\" ) if tree_m . _COMPACT_CONTEXT . current_tree is not self : raise RuntimeError ( f \"Object ' { type ( self ) . __name__ } ' is not the current tree, found ' { type ( tree_m . _COMPACT_CONTEXT . current_tree ) . __name__ } ', did you forget the @compact decorator?\" ) if field_name in vars ( self ): value = getattr ( self , field_name ) else : if tree_m . _COMPACT_CONTEXT . in_compact and not self . first_run : raise RuntimeError ( f \"Trying to initialize field ' { field_name } ' after the first run of `compact`.\" ) value = initializer () setattr ( self , field_name , value ) return value","title":"get_field()"},{"location":"api/KeySeq/#treex.key_seq.KeySeq.init","text":"Method version of tx.init , it applies self as first argument. init creates a new module with the same structure, but with its fields initialized given a seed key . The following procedure is used: The input key is split and iteratively updated before passing a derived value to any process that requires initialization. Initializer s are called and applied to the module first. Module.rng_init methods are called last. Parameters: Name Type Description Default key Union[int, jax._src.numpy.lax_numpy.ndarray] The seed to use for initialization. required Returns: Type Description ~M The new module with the fields initialized. Source code in treex/key_seq.py def init ( self : M , key : tp . Union [ int , jnp . ndarray ], inplace : bool = False ) -> M : \"\"\" Method version of `tx.init`, it applies `self` as first argument. `init` creates a new module with the same structure, but with its fields initialized given a seed `key`. The following procedure is used: 1. The input `key` is split and iteratively updated before passing a derived value to any process that requires initialization. 2. `Initializer`s are called and applied to the module first. 3. `Module.rng_init` methods are called last. Arguments: key: The seed to use for initialization. Returns: The new module with the fields initialized. \"\"\" if isinstance ( key , int ): key = jax . random . PRNGKey ( key ) def next_key () -> jnp . ndarray : nonlocal key assert isinstance ( key , ( np . ndarray , jnp . ndarray )) next_key , key = utils . iter_split ( key ) return next_key tree_out : M = jax . tree_map ( lambda initializer : ( initializer ( next_key ()) if isinstance ( initializer , types . Initializer ) else initializer ), self , is_leaf = lambda x : isinstance ( x , types . Initializer ), ) if inplace : # here we update initialized fields by the above tree_map tree_out = to . merge ( self , tree_out , inplace = True ) def call_module_init ( module : Module ): if isinstance ( module , Module ) and not module . _initialized : module . rng_init ( next_key ()) module . _initialized = True return to . apply ( call_module_init , tree_out , inplace = inplace )","title":"init()"},{"location":"api/KeySeq/#treex.key_seq.KeySeq.logs","text":"Returns a copy of the Module with only tx.Log TreeParts, alias for filter(tx.Log) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/key_seq.py def logs ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Log TreeParts, alias for `filter(tx.Log)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . Log , * filters )","title":"logs()"},{"location":"api/KeySeq/#treex.key_seq.KeySeq.losses","text":"Returns a copy of the Module with only tx.Loss TreeParts, alias for filter(tx.Loss) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/key_seq.py def losses ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Loss TreeParts, alias for `filter(tx.Loss)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . LossLog , * filters )","title":"losses()"},{"location":"api/KeySeq/#treex.key_seq.KeySeq.map","text":"map is a wrapper over treeo.map that passes self as the second argument. Parameters: Name Type Description Default f Callable The function to apply to the leaves. required *filters Filter The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treex/key_seq.py def map ( self : A , f : tp . Callable , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , is_leaf : tp . Callable [[ tp . Any ], bool ] = None , ) -> A : \"\"\" `map` is a wrapper over `treeo.map` that passes `self` as the second argument. Arguments: f: The function to apply to the leaves. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" return api . map ( f , self , * filters , inplace = inplace , flatten_mode = flatten_mode , is_leaf = is_leaf , )","title":"map()"},{"location":"api/KeySeq/#treex.key_seq.KeySeq.merge","text":"merge is a wrapper over treeo.merge that passes self as the first argument. Parameters: Name Type Description Default other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the merged values. If inplace is True , obj is returned. Source code in treex/key_seq.py def merge ( self : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" `merge` is a wrapper over `treeo.merge` that passes `self` as the first argument. Arguments: other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the merged values. If `inplace` is `True`, `obj` is returned. \"\"\" return api . merge ( self , other , * rest , inplace = inplace , flatten_mode = flatten_mode , ignore_static = ignore_static , )","title":"merge()"},{"location":"api/KeySeq/#treex.key_seq.KeySeq.metrics","text":"Returns a copy of the Module with only tx.Metric TreeParts, alias for filter(tx.Metric) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/key_seq.py def metrics ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Metric TreeParts, alias for `filter(tx.Metric)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . MetricLog , * filters )","title":"metrics()"},{"location":"api/KeySeq/#treex.key_seq.KeySeq.model_states","text":"Returns a copy of the Module with only tx.ModelState TreeParts, alias for filter(tx.ModelState) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/key_seq.py def model_states ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.ModelState TreeParts, alias for `filter(tx.ModelState)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . ModelState , * filters )","title":"model_states()"},{"location":"api/KeySeq/#treex.key_seq.KeySeq.parameters","text":"Returns a copy of the Module with only tx.Parameter TreeParts, alias for filter(tx.Parameter) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/key_seq.py def parameters ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Parameter TreeParts, alias for `filter(tx.Parameter)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . Parameter , * filters )","title":"parameters()"},{"location":"api/KeySeq/#treex.key_seq.KeySeq.rngs","text":"Returns a copy of the Module with only tx.Rng TreeParts, alias for filter(tx.Rng) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/key_seq.py def rngs ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Rng TreeParts, alias for `filter(tx.Rng)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . Rng , * filters )","title":"rngs()"},{"location":"api/KeySeq/#treex.key_seq.KeySeq.states","text":"Returns a copy of the Module with only tx.State TreeParts, alias for filter(tx.State) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/key_seq.py def states ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.State TreeParts, alias for `filter(tx.State)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . State , * filters )","title":"states()"},{"location":"api/KeySeq/#treex.key_seq.KeySeq.tabulate","text":"Returns a tabular representation of the module. Parameters: Name Type Description Default depth int The maximum depth of the representation in terms of nested Modules, -1 means no limit. -1 signature bool Whether to show the signature of the Module. False param_types bool Whether to show the types of the parameters. True Returns: Type Description str A string containing the tabular representation. Source code in treex/key_seq.py def tabulate ( self , inputs : tp . Union [ tp . Any , types . Inputs , None ] = None , depth : int = - 1 , signature : bool = False , param_types : bool = True , ) -> str : \"\"\" Returns a tabular representation of the module. Arguments: depth: The maximum depth of the representation in terms of nested Modules, -1 means no limit. signature: Whether to show the signature of the Module. param_types: Whether to show the types of the parameters. Returns: A string containing the tabular representation. \"\"\" self = to . copy ( self ) if inputs is not None : if not isinstance ( inputs , types . Inputs ): inputs = types . Inputs ( inputs ) inputs = tp . cast ( types . Inputs , inputs ) if not isinstance ( self , tp . Callable ): raise TypeError ( \"`inputs` can only be specified if the module is a callable.\" ) with _Context ( call_info = {}): # call using self to preserve references def eval_call ( args , kwargs ): assert isinstance ( self , tp . Callable ) return self ( * args , ** kwargs ) jax . eval_shape ( eval_call , inputs . args , inputs . kwargs , ) call_info = _CONTEXT . call_info else : call_info = None with to . add_field_info (): flat : tp . List [ to . FieldInfo ] flat , _ = jax . tree_flatten ( self ) tree_part_types : tp . Tuple [ tp . Type [ types . TreePart ], ... ] = tuple ( { field_info . kind for field_info in flat if utils . _generic_issubclass ( field_info . kind , types . TreePart ) } ) path = () rows = list ( utils . _get_tabulate_rows ( path , self , depth , tree_part_types , signature , param_types ) ) modules = [ row [ 0 ] for row in rows ] rows = [ row [ 1 :] for row in rows ] if call_info is not None : for module , row in zip ( modules , rows ): if module in call_info : inputs , outputs = call_info [ module ] simplified_inputs = ( inputs . args [ 0 ] if len ( inputs . kwargs ) == 0 and len ( inputs . args ) == 1 else inputs . kwargs if len ( inputs . kwargs ) == 0 else inputs . kwargs if len ( inputs . args ) == 0 else ( inputs . args , inputs . kwargs ) ) inputs_repr = utils . _format_param_tree ( simplified_inputs ) outputs_repr = utils . _format_param_tree ( outputs ) else : inputs_repr = \"\" outputs_repr = \"\" row . insert ( 3 , outputs_repr ) row . insert ( 3 , inputs_repr ) n_non_treepart_cols = 2 if call_info is None else 4 rows [ 0 ][ 0 ] = \"*\" rows . append ( [ \"\" ] * n_non_treepart_cols + [ \"Total:\" ] + [ utils . _format_obj_size ( self . filter ( kind ), add_padding = True ) for kind in tree_part_types ] ) utils . _add_padding ( rows ) table = Table ( show_header = True , show_lines = True , show_footer = True , # box=rich.box.HORIZONTALS, ) table . add_column ( \"path\" ) table . add_column ( \"module\" ) table . add_column ( \"params\" ) if call_info is not None : table . add_column ( \"inputs\" ) table . add_column ( \"outputs\" ) for tree_part_type in tree_part_types : type_name = tree_part_type . __name__ if type_name . startswith ( \"_\" ): type_name = type_name [ 1 :] table . add_column ( type_name ) for row in rows [: - 1 ]: table . add_row ( * row ) table . columns [ n_non_treepart_cols ] . footer = Text . from_markup ( rows [ - 1 ][ n_non_treepart_cols ], justify = \"right\" ) for i in range ( len ( tree_part_types )): table . columns [ n_non_treepart_cols + 1 + i ] . footer = rows [ - 1 ][ n_non_treepart_cols + 1 + i ] table . caption_style = \"bold\" table . caption = \" \\n Total Parameters: \" + utils . _format_obj_size ( self , add_padding = False ) return utils . _get_rich_repr ( table )","title":"tabulate()"},{"location":"api/KeySeq/#treex.key_seq.KeySeq.to_dict","text":"to_dict is a wrapper over treeo.to_dict that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True type_info bool If True , type information is included. False field_info bool If True , field information is included. False Returns: Type Description Any A dict representation of the object. Source code in treex/key_seq.py def to_dict ( self , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : \"\"\" `to_dict` is a wrapper over `treeo.to_dict` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. type_info: If `True`, type information is included. field_info: If `True`, field information is included. Returns: A dict representation of the object. \"\"\" return api . to_dict ( self , private_fields = private_fields , static_fields = static_fields , type_info = type_info , field_info = field_info , )","title":"to_dict()"},{"location":"api/KeySeq/#treex.key_seq.KeySeq.to_string","text":"to_string is a wrapper over treeo.to_string that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True color bool If True , color is included. False Returns: Type Description str A string representation of the object. Source code in treex/key_seq.py def to_string ( self : A , * , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" `to_string` is a wrapper over `treeo.to_string` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. color: If `True`, color is included. Returns: A string representation of the object. \"\"\" return api . to_string ( self , private_fields = private_fields , static_fields = static_fields , color = color , )","title":"to_string()"},{"location":"api/KeySeq/#treex.key_seq.KeySeq.train","text":"Creates a new module with the same structure, but with Module.training set to the given value. Parameters: Name Type Description Default mode bool The new training mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~M The new module in with the training mode is set to the given value, if inplace is True then self is returned. Source code in treex/key_seq.py def train ( self : M , mode : bool = True , inplace : bool = False ) -> M : \"\"\" Creates a new module with the same structure, but with `Module.training` set to the given value. Arguments: mode: The new training mode. inplace: Whether to update the module inplace. Returns: The new module in with the training mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_training ( module : Module ): if isinstance ( module , Module ): module . _training = mode return to . apply ( set_training , self , inplace = inplace )","title":"train()"},{"location":"api/KeySeq/#treex.key_seq.KeySeq.unfreeze","text":"Creates a new module with .frozen set to False, equivalent to calling freeze(False) . Parameters: Name Type Description Default inplace bool Whether to update the module inplace. False Returns: Type Description ~M The new module with .frozen set to False, if inplace is True then self is returned. Source code in treex/key_seq.py def unfreeze ( self : M , inplace : bool = False ) -> M : \"\"\" Creates a new module with `.frozen` set to False, equivalent to calling `freeze(False)`. Arguments: inplace: Whether to update the module inplace. Returns: The new module with `.frozen` set to False, if `inplace` is `True` then `self` is returned. \"\"\" return self . freeze ( False , inplace = inplace )","title":"unfreeze()"},{"location":"api/KindMixin/","text":"treex.KindMixin","title":"KindMixin"},{"location":"api/KindMixin/#treexkindmixin","text":"","title":"treex.KindMixin"},{"location":"api/Lambda/","text":"treex.Lambda A Module that applies a pure function to its input. first_run : bool inherited property readonly Returns: Type Description bool True if its currently the first run of a compact method. __class__ inherited __base__ inherited Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()). __instancecheck__ ( cls , instance ) special Override for isinstance(instance, cls). Source code in treex/nn/sequential.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance ) __new__ ( mcls , name , bases , namespace , ** kwargs ) special staticmethod Create and return a new object. See help(type) for accurate signature. Source code in treex/nn/sequential.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls __subclasscheck__ ( cls , subclass ) special Override for issubclass(subclass, cls). Source code in treex/nn/sequential.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass ) register ( cls , subclass ) Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/sequential.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) register ( cls , subclass ) inherited Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/sequential.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) __call__ ( self , x ) special Parameters: Name Type Description Default x ndarray The input to the function. required Returns: Type Description ndarray The output of the function. Source code in treex/nn/sequential.py def __call__ ( self , x : jnp . ndarray ) -> jnp . ndarray : \"\"\" Arguments: x: The input to the function. Returns: The output of the function. \"\"\" return self . f ( x ) __init__ ( self , f ) special Parameters: Name Type Description Default f Callable[[jax._src.numpy.lax_numpy.ndarray], jax._src.numpy.lax_numpy.ndarray] A function to apply to the input. required Source code in treex/nn/sequential.py def __init__ ( self , f : tp . Callable [[ jnp . ndarray ], jnp . ndarray ]): \"\"\" Arguments: f: A function to apply to the input. \"\"\" self . f = f self . f = f apply ( self , f , * rest , * , inplace = False ) inherited apply is a wrapper over treeo.apply that passes self as the second argument. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treex/nn/sequential.py def apply ( self : A , f : tp . Callable [ ... , None ], * rest : A , inplace : bool = False ) -> A : \"\"\" `apply` is a wrapper over `treeo.apply` that passes `self` as the second argument. Arguments: f: The function to apply. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" return api . apply ( f , self , * rest , inplace = inplace ) batch_stats ( self , * filters ) inherited Returns a copy of the Module with only tx.BatchStat TreeParts, alias for filter(tx.BatchStat) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/sequential.py def batch_stats ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.BatchStat TreeParts, alias for `filter(tx.BatchStat)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . BatchStat , * filters ) check_metadata_updates ( self ) inherited Checks for new fields, if found, adds them to the metadata. Source code in treex/nn/sequential.py def check_metadata_updates ( self ): \"\"\" Checks for new fields, if found, adds them to the metadata. \"\"\" with _CONTEXT . update ( flatten_mode = FlattenMode . all_fields ): jax . tree_flatten ( self ) copy ( self ) inherited copy is a wrapper over treeo.copy that passes self as the first argument. Source code in treex/nn/sequential.py def copy ( self : A ) -> A : \"\"\" `copy` is a wrapper over `treeo.copy` that passes `self` as the first argument. \"\"\" return tree_m . copy ( self ) eval ( self , inplace = False ) inherited Creates a new module with the training mode set to False, equivalent to calling train(False) . Returns: Type Description ~M The new module with the training mode set to False. Source code in treex/nn/sequential.py def eval ( self : M , inplace : bool = False ) -> M : \"\"\" Creates a new module with the training mode set to False, equivalent to calling `train(False)`. Returns: The new module with the training mode set to False. \"\"\" return self . train ( False , inplace = inplace ) filter ( self , * filters , * , inplace = False , flatten_mode = None ) inherited filter is a wrapper over treeo.filter that passes self as the first argument. Parameters: Name Type Description Default *filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treex/nn/sequential.py def filter ( self : A , * filters : api . Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ) -> A : \"\"\" `filter` is a wrapper over `treeo.filter` that passes `self` as the first argument. Arguments: *filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" return api . filter ( self , * filters , inplace = inplace , flatten_mode = flatten_mode ) freeze ( self , mode = True , inplace = False ) inherited Creates a new module with the same structure, but with Module.frozen set to the given value. Parameters: Name Type Description Default mode bool The new frozen mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~M The new module in with the frozen mode is set to the given value, if inplace is True then self is returned. Source code in treex/nn/sequential.py def freeze ( self : M , mode : bool = True , inplace : bool = False ) -> M : \"\"\" Creates a new module with the same structure, but with `Module.frozen` set to the given value. Arguments: mode: The new `frozen` mode. inplace: Whether to update the module inplace. Returns: The new module in with the `frozen` mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_frozen ( module : Module ): if isinstance ( module , Module ): module . _frozen = mode return to . apply ( set_frozen , self , inplace = inplace ) get_field ( self , field_name , initializer ) inherited A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: The field must be declared in the class definition. The method can only be called inside a compact context. Parameters: Name Type Description Default field_name str The name of the field to get. required initializer Callable[[], ~A] The function to initialize the field if it does not exist. required Returns: Type Description ~A The field value. Source code in treex/nn/sequential.py def get_field ( self , field_name : str , initializer : tp . Callable [[], A ], ) -> A : \"\"\" A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: * The field must be declared in the class definition. * The method can only be called inside a `compact` context. Arguments: field_name: The name of the field to get. initializer: The function to initialize the field if it does not exist. Returns: The field value. \"\"\" value : A if field_name not in self . _field_metadata : raise ValueError ( f \"Metadata for field ' { field_name } ' does not exist.\" ) if tree_m . _COMPACT_CONTEXT . current_tree is not self : raise RuntimeError ( f \"Object ' { type ( self ) . __name__ } ' is not the current tree, found ' { type ( tree_m . _COMPACT_CONTEXT . current_tree ) . __name__ } ', did you forget the @compact decorator?\" ) if field_name in vars ( self ): value = getattr ( self , field_name ) else : if tree_m . _COMPACT_CONTEXT . in_compact and not self . first_run : raise RuntimeError ( f \"Trying to initialize field ' { field_name } ' after the first run of `compact`.\" ) value = initializer () setattr ( self , field_name , value ) return value init ( self , key , inplace = False ) inherited Method version of tx.init , it applies self as first argument. init creates a new module with the same structure, but with its fields initialized given a seed key . The following procedure is used: The input key is split and iteratively updated before passing a derived value to any process that requires initialization. Initializer s are called and applied to the module first. Module.rng_init methods are called last. Parameters: Name Type Description Default key Union[int, jax._src.numpy.lax_numpy.ndarray] The seed to use for initialization. required Returns: Type Description ~M The new module with the fields initialized. Source code in treex/nn/sequential.py def init ( self : M , key : tp . Union [ int , jnp . ndarray ], inplace : bool = False ) -> M : \"\"\" Method version of `tx.init`, it applies `self` as first argument. `init` creates a new module with the same structure, but with its fields initialized given a seed `key`. The following procedure is used: 1. The input `key` is split and iteratively updated before passing a derived value to any process that requires initialization. 2. `Initializer`s are called and applied to the module first. 3. `Module.rng_init` methods are called last. Arguments: key: The seed to use for initialization. Returns: The new module with the fields initialized. \"\"\" if isinstance ( key , int ): key = jax . random . PRNGKey ( key ) def next_key () -> jnp . ndarray : nonlocal key assert isinstance ( key , ( np . ndarray , jnp . ndarray )) next_key , key = utils . iter_split ( key ) return next_key tree_out : M = jax . tree_map ( lambda initializer : ( initializer ( next_key ()) if isinstance ( initializer , types . Initializer ) else initializer ), self , is_leaf = lambda x : isinstance ( x , types . Initializer ), ) if inplace : # here we update initialized fields by the above tree_map tree_out = to . merge ( self , tree_out , inplace = True ) def call_module_init ( module : Module ): if isinstance ( module , Module ) and not module . _initialized : module . rng_init ( next_key ()) module . _initialized = True return to . apply ( call_module_init , tree_out , inplace = inplace ) logs ( self , * filters ) inherited Returns a copy of the Module with only tx.Log TreeParts, alias for filter(tx.Log) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/sequential.py def logs ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Log TreeParts, alias for `filter(tx.Log)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . Log , * filters ) losses ( self , * filters ) inherited Returns a copy of the Module with only tx.Loss TreeParts, alias for filter(tx.Loss) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/sequential.py def losses ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Loss TreeParts, alias for `filter(tx.Loss)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . LossLog , * filters ) map ( self , f , * filters , * , inplace = False , flatten_mode = None , is_leaf = None ) inherited map is a wrapper over treeo.map that passes self as the second argument. Parameters: Name Type Description Default f Callable The function to apply to the leaves. required *filters Filter The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treex/nn/sequential.py def map ( self : A , f : tp . Callable , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , is_leaf : tp . Callable [[ tp . Any ], bool ] = None , ) -> A : \"\"\" `map` is a wrapper over `treeo.map` that passes `self` as the second argument. Arguments: f: The function to apply to the leaves. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" return api . map ( f , self , * filters , inplace = inplace , flatten_mode = flatten_mode , is_leaf = is_leaf , ) merge ( self , other , * rest , * , inplace = False , flatten_mode = None , ignore_static = False ) inherited merge is a wrapper over treeo.merge that passes self as the first argument. Parameters: Name Type Description Default other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the merged values. If inplace is True , obj is returned. Source code in treex/nn/sequential.py def merge ( self : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" `merge` is a wrapper over `treeo.merge` that passes `self` as the first argument. Arguments: other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the merged values. If `inplace` is `True`, `obj` is returned. \"\"\" return api . merge ( self , other , * rest , inplace = inplace , flatten_mode = flatten_mode , ignore_static = ignore_static , ) metrics ( self , * filters ) inherited Returns a copy of the Module with only tx.Metric TreeParts, alias for filter(tx.Metric) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/sequential.py def metrics ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Metric TreeParts, alias for `filter(tx.Metric)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . MetricLog , * filters ) model_states ( self , * filters ) inherited Returns a copy of the Module with only tx.ModelState TreeParts, alias for filter(tx.ModelState) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/sequential.py def model_states ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.ModelState TreeParts, alias for `filter(tx.ModelState)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . ModelState , * filters ) parameters ( self , * filters ) inherited Returns a copy of the Module with only tx.Parameter TreeParts, alias for filter(tx.Parameter) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/sequential.py def parameters ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Parameter TreeParts, alias for `filter(tx.Parameter)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . Parameter , * filters ) rngs ( self , * filters ) inherited Returns a copy of the Module with only tx.Rng TreeParts, alias for filter(tx.Rng) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/sequential.py def rngs ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Rng TreeParts, alias for `filter(tx.Rng)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . Rng , * filters ) states ( self , * filters ) inherited Returns a copy of the Module with only tx.State TreeParts, alias for filter(tx.State) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/sequential.py def states ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.State TreeParts, alias for `filter(tx.State)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . State , * filters ) tabulate ( self , inputs = None , depth =- 1 , signature = False , param_types = True ) inherited Returns a tabular representation of the module. Parameters: Name Type Description Default depth int The maximum depth of the representation in terms of nested Modules, -1 means no limit. -1 signature bool Whether to show the signature of the Module. False param_types bool Whether to show the types of the parameters. True Returns: Type Description str A string containing the tabular representation. Source code in treex/nn/sequential.py def tabulate ( self , inputs : tp . Union [ tp . Any , types . Inputs , None ] = None , depth : int = - 1 , signature : bool = False , param_types : bool = True , ) -> str : \"\"\" Returns a tabular representation of the module. Arguments: depth: The maximum depth of the representation in terms of nested Modules, -1 means no limit. signature: Whether to show the signature of the Module. param_types: Whether to show the types of the parameters. Returns: A string containing the tabular representation. \"\"\" self = to . copy ( self ) if inputs is not None : if not isinstance ( inputs , types . Inputs ): inputs = types . Inputs ( inputs ) inputs = tp . cast ( types . Inputs , inputs ) if not isinstance ( self , tp . Callable ): raise TypeError ( \"`inputs` can only be specified if the module is a callable.\" ) with _Context ( call_info = {}): # call using self to preserve references def eval_call ( args , kwargs ): assert isinstance ( self , tp . Callable ) return self ( * args , ** kwargs ) jax . eval_shape ( eval_call , inputs . args , inputs . kwargs , ) call_info = _CONTEXT . call_info else : call_info = None with to . add_field_info (): flat : tp . List [ to . FieldInfo ] flat , _ = jax . tree_flatten ( self ) tree_part_types : tp . Tuple [ tp . Type [ types . TreePart ], ... ] = tuple ( { field_info . kind for field_info in flat if utils . _generic_issubclass ( field_info . kind , types . TreePart ) } ) path = () rows = list ( utils . _get_tabulate_rows ( path , self , depth , tree_part_types , signature , param_types ) ) modules = [ row [ 0 ] for row in rows ] rows = [ row [ 1 :] for row in rows ] if call_info is not None : for module , row in zip ( modules , rows ): if module in call_info : inputs , outputs = call_info [ module ] simplified_inputs = ( inputs . args [ 0 ] if len ( inputs . kwargs ) == 0 and len ( inputs . args ) == 1 else inputs . kwargs if len ( inputs . kwargs ) == 0 else inputs . kwargs if len ( inputs . args ) == 0 else ( inputs . args , inputs . kwargs ) ) inputs_repr = utils . _format_param_tree ( simplified_inputs ) outputs_repr = utils . _format_param_tree ( outputs ) else : inputs_repr = \"\" outputs_repr = \"\" row . insert ( 3 , outputs_repr ) row . insert ( 3 , inputs_repr ) n_non_treepart_cols = 2 if call_info is None else 4 rows [ 0 ][ 0 ] = \"*\" rows . append ( [ \"\" ] * n_non_treepart_cols + [ \"Total:\" ] + [ utils . _format_obj_size ( self . filter ( kind ), add_padding = True ) for kind in tree_part_types ] ) utils . _add_padding ( rows ) table = Table ( show_header = True , show_lines = True , show_footer = True , # box=rich.box.HORIZONTALS, ) table . add_column ( \"path\" ) table . add_column ( \"module\" ) table . add_column ( \"params\" ) if call_info is not None : table . add_column ( \"inputs\" ) table . add_column ( \"outputs\" ) for tree_part_type in tree_part_types : type_name = tree_part_type . __name__ if type_name . startswith ( \"_\" ): type_name = type_name [ 1 :] table . add_column ( type_name ) for row in rows [: - 1 ]: table . add_row ( * row ) table . columns [ n_non_treepart_cols ] . footer = Text . from_markup ( rows [ - 1 ][ n_non_treepart_cols ], justify = \"right\" ) for i in range ( len ( tree_part_types )): table . columns [ n_non_treepart_cols + 1 + i ] . footer = rows [ - 1 ][ n_non_treepart_cols + 1 + i ] table . caption_style = \"bold\" table . caption = \" \\n Total Parameters: \" + utils . _format_obj_size ( self , add_padding = False ) return utils . _get_rich_repr ( table ) to_dict ( self , * , private_fields = False , static_fields = True , type_info = False , field_info = False ) inherited to_dict is a wrapper over treeo.to_dict that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True type_info bool If True , type information is included. False field_info bool If True , field information is included. False Returns: Type Description Any A dict representation of the object. Source code in treex/nn/sequential.py def to_dict ( self , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : \"\"\" `to_dict` is a wrapper over `treeo.to_dict` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. type_info: If `True`, type information is included. field_info: If `True`, field information is included. Returns: A dict representation of the object. \"\"\" return api . to_dict ( self , private_fields = private_fields , static_fields = static_fields , type_info = type_info , field_info = field_info , ) to_string ( self , * , private_fields = False , static_fields = True , color = False ) inherited to_string is a wrapper over treeo.to_string that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True color bool If True , color is included. False Returns: Type Description str A string representation of the object. Source code in treex/nn/sequential.py def to_string ( self : A , * , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" `to_string` is a wrapper over `treeo.to_string` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. color: If `True`, color is included. Returns: A string representation of the object. \"\"\" return api . to_string ( self , private_fields = private_fields , static_fields = static_fields , color = color , ) train ( self , mode = True , inplace = False ) inherited Creates a new module with the same structure, but with Module.training set to the given value. Parameters: Name Type Description Default mode bool The new training mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~M The new module in with the training mode is set to the given value, if inplace is True then self is returned. Source code in treex/nn/sequential.py def train ( self : M , mode : bool = True , inplace : bool = False ) -> M : \"\"\" Creates a new module with the same structure, but with `Module.training` set to the given value. Arguments: mode: The new training mode. inplace: Whether to update the module inplace. Returns: The new module in with the training mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_training ( module : Module ): if isinstance ( module , Module ): module . _training = mode return to . apply ( set_training , self , inplace = inplace ) unfreeze ( self , inplace = False ) inherited Creates a new module with .frozen set to False, equivalent to calling freeze(False) . Parameters: Name Type Description Default inplace bool Whether to update the module inplace. False Returns: Type Description ~M The new module with .frozen set to False, if inplace is True then self is returned. Source code in treex/nn/sequential.py def unfreeze ( self : M , inplace : bool = False ) -> M : \"\"\" Creates a new module with `.frozen` set to False, equivalent to calling `freeze(False)`. Arguments: inplace: Whether to update the module inplace. Returns: The new module with `.frozen` set to False, if `inplace` is `True` then `self` is returned. \"\"\" return self . freeze ( False , inplace = inplace )","title":"Lambda"},{"location":"api/Lambda/#treexlambda","text":"A Module that applies a pure function to its input.","title":"treex.Lambda"},{"location":"api/Lambda/#treex.nn.sequential.Lambda.first_run","text":"Returns: Type Description bool True if its currently the first run of a compact method.","title":"first_run"},{"location":"api/Lambda/#treex.nn.sequential.Lambda.__class__","text":"","title":"__class__"},{"location":"api/Lambda/#treex.nn.sequential.Lambda.__class__.__base__","text":"Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()).","title":"__base__"},{"location":"api/Lambda/#treex.nn.sequential.Lambda.__class__.__base__.__instancecheck__","text":"Override for isinstance(instance, cls). Source code in treex/nn/sequential.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance )","title":"__instancecheck__()"},{"location":"api/Lambda/#treex.nn.sequential.Lambda.__class__.__base__.__new__","text":"Create and return a new object. See help(type) for accurate signature. Source code in treex/nn/sequential.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls","title":"__new__()"},{"location":"api/Lambda/#treex.nn.sequential.Lambda.__class__.__base__.__subclasscheck__","text":"Override for issubclass(subclass, cls). Source code in treex/nn/sequential.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass )","title":"__subclasscheck__()"},{"location":"api/Lambda/#treex.nn.sequential.Lambda.__class__.__base__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/sequential.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/Lambda/#treex.nn.sequential.Lambda.__class__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/sequential.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/Lambda/#treex.nn.sequential.Lambda.__call__","text":"Parameters: Name Type Description Default x ndarray The input to the function. required Returns: Type Description ndarray The output of the function. Source code in treex/nn/sequential.py def __call__ ( self , x : jnp . ndarray ) -> jnp . ndarray : \"\"\" Arguments: x: The input to the function. Returns: The output of the function. \"\"\" return self . f ( x )","title":"__call__()"},{"location":"api/Lambda/#treex.nn.sequential.Lambda.__init__","text":"Parameters: Name Type Description Default f Callable[[jax._src.numpy.lax_numpy.ndarray], jax._src.numpy.lax_numpy.ndarray] A function to apply to the input. required Source code in treex/nn/sequential.py def __init__ ( self , f : tp . Callable [[ jnp . ndarray ], jnp . ndarray ]): \"\"\" Arguments: f: A function to apply to the input. \"\"\" self . f = f self . f = f","title":"__init__()"},{"location":"api/Lambda/#treex.nn.sequential.Lambda.apply","text":"apply is a wrapper over treeo.apply that passes self as the second argument. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treex/nn/sequential.py def apply ( self : A , f : tp . Callable [ ... , None ], * rest : A , inplace : bool = False ) -> A : \"\"\" `apply` is a wrapper over `treeo.apply` that passes `self` as the second argument. Arguments: f: The function to apply. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" return api . apply ( f , self , * rest , inplace = inplace )","title":"apply()"},{"location":"api/Lambda/#treex.nn.sequential.Lambda.batch_stats","text":"Returns a copy of the Module with only tx.BatchStat TreeParts, alias for filter(tx.BatchStat) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/sequential.py def batch_stats ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.BatchStat TreeParts, alias for `filter(tx.BatchStat)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . BatchStat , * filters )","title":"batch_stats()"},{"location":"api/Lambda/#treex.nn.sequential.Lambda.check_metadata_updates","text":"Checks for new fields, if found, adds them to the metadata. Source code in treex/nn/sequential.py def check_metadata_updates ( self ): \"\"\" Checks for new fields, if found, adds them to the metadata. \"\"\" with _CONTEXT . update ( flatten_mode = FlattenMode . all_fields ): jax . tree_flatten ( self )","title":"check_metadata_updates()"},{"location":"api/Lambda/#treex.nn.sequential.Lambda.copy","text":"copy is a wrapper over treeo.copy that passes self as the first argument. Source code in treex/nn/sequential.py def copy ( self : A ) -> A : \"\"\" `copy` is a wrapper over `treeo.copy` that passes `self` as the first argument. \"\"\" return tree_m . copy ( self )","title":"copy()"},{"location":"api/Lambda/#treex.nn.sequential.Lambda.eval","text":"Creates a new module with the training mode set to False, equivalent to calling train(False) . Returns: Type Description ~M The new module with the training mode set to False. Source code in treex/nn/sequential.py def eval ( self : M , inplace : bool = False ) -> M : \"\"\" Creates a new module with the training mode set to False, equivalent to calling `train(False)`. Returns: The new module with the training mode set to False. \"\"\" return self . train ( False , inplace = inplace )","title":"eval()"},{"location":"api/Lambda/#treex.nn.sequential.Lambda.filter","text":"filter is a wrapper over treeo.filter that passes self as the first argument. Parameters: Name Type Description Default *filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treex/nn/sequential.py def filter ( self : A , * filters : api . Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ) -> A : \"\"\" `filter` is a wrapper over `treeo.filter` that passes `self` as the first argument. Arguments: *filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" return api . filter ( self , * filters , inplace = inplace , flatten_mode = flatten_mode )","title":"filter()"},{"location":"api/Lambda/#treex.nn.sequential.Lambda.freeze","text":"Creates a new module with the same structure, but with Module.frozen set to the given value. Parameters: Name Type Description Default mode bool The new frozen mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~M The new module in with the frozen mode is set to the given value, if inplace is True then self is returned. Source code in treex/nn/sequential.py def freeze ( self : M , mode : bool = True , inplace : bool = False ) -> M : \"\"\" Creates a new module with the same structure, but with `Module.frozen` set to the given value. Arguments: mode: The new `frozen` mode. inplace: Whether to update the module inplace. Returns: The new module in with the `frozen` mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_frozen ( module : Module ): if isinstance ( module , Module ): module . _frozen = mode return to . apply ( set_frozen , self , inplace = inplace )","title":"freeze()"},{"location":"api/Lambda/#treex.nn.sequential.Lambda.get_field","text":"A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: The field must be declared in the class definition. The method can only be called inside a compact context. Parameters: Name Type Description Default field_name str The name of the field to get. required initializer Callable[[], ~A] The function to initialize the field if it does not exist. required Returns: Type Description ~A The field value. Source code in treex/nn/sequential.py def get_field ( self , field_name : str , initializer : tp . Callable [[], A ], ) -> A : \"\"\" A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: * The field must be declared in the class definition. * The method can only be called inside a `compact` context. Arguments: field_name: The name of the field to get. initializer: The function to initialize the field if it does not exist. Returns: The field value. \"\"\" value : A if field_name not in self . _field_metadata : raise ValueError ( f \"Metadata for field ' { field_name } ' does not exist.\" ) if tree_m . _COMPACT_CONTEXT . current_tree is not self : raise RuntimeError ( f \"Object ' { type ( self ) . __name__ } ' is not the current tree, found ' { type ( tree_m . _COMPACT_CONTEXT . current_tree ) . __name__ } ', did you forget the @compact decorator?\" ) if field_name in vars ( self ): value = getattr ( self , field_name ) else : if tree_m . _COMPACT_CONTEXT . in_compact and not self . first_run : raise RuntimeError ( f \"Trying to initialize field ' { field_name } ' after the first run of `compact`.\" ) value = initializer () setattr ( self , field_name , value ) return value","title":"get_field()"},{"location":"api/Lambda/#treex.nn.sequential.Lambda.init","text":"Method version of tx.init , it applies self as first argument. init creates a new module with the same structure, but with its fields initialized given a seed key . The following procedure is used: The input key is split and iteratively updated before passing a derived value to any process that requires initialization. Initializer s are called and applied to the module first. Module.rng_init methods are called last. Parameters: Name Type Description Default key Union[int, jax._src.numpy.lax_numpy.ndarray] The seed to use for initialization. required Returns: Type Description ~M The new module with the fields initialized. Source code in treex/nn/sequential.py def init ( self : M , key : tp . Union [ int , jnp . ndarray ], inplace : bool = False ) -> M : \"\"\" Method version of `tx.init`, it applies `self` as first argument. `init` creates a new module with the same structure, but with its fields initialized given a seed `key`. The following procedure is used: 1. The input `key` is split and iteratively updated before passing a derived value to any process that requires initialization. 2. `Initializer`s are called and applied to the module first. 3. `Module.rng_init` methods are called last. Arguments: key: The seed to use for initialization. Returns: The new module with the fields initialized. \"\"\" if isinstance ( key , int ): key = jax . random . PRNGKey ( key ) def next_key () -> jnp . ndarray : nonlocal key assert isinstance ( key , ( np . ndarray , jnp . ndarray )) next_key , key = utils . iter_split ( key ) return next_key tree_out : M = jax . tree_map ( lambda initializer : ( initializer ( next_key ()) if isinstance ( initializer , types . Initializer ) else initializer ), self , is_leaf = lambda x : isinstance ( x , types . Initializer ), ) if inplace : # here we update initialized fields by the above tree_map tree_out = to . merge ( self , tree_out , inplace = True ) def call_module_init ( module : Module ): if isinstance ( module , Module ) and not module . _initialized : module . rng_init ( next_key ()) module . _initialized = True return to . apply ( call_module_init , tree_out , inplace = inplace )","title":"init()"},{"location":"api/Lambda/#treex.nn.sequential.Lambda.logs","text":"Returns a copy of the Module with only tx.Log TreeParts, alias for filter(tx.Log) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/sequential.py def logs ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Log TreeParts, alias for `filter(tx.Log)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . Log , * filters )","title":"logs()"},{"location":"api/Lambda/#treex.nn.sequential.Lambda.losses","text":"Returns a copy of the Module with only tx.Loss TreeParts, alias for filter(tx.Loss) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/sequential.py def losses ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Loss TreeParts, alias for `filter(tx.Loss)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . LossLog , * filters )","title":"losses()"},{"location":"api/Lambda/#treex.nn.sequential.Lambda.map","text":"map is a wrapper over treeo.map that passes self as the second argument. Parameters: Name Type Description Default f Callable The function to apply to the leaves. required *filters Filter The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treex/nn/sequential.py def map ( self : A , f : tp . Callable , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , is_leaf : tp . Callable [[ tp . Any ], bool ] = None , ) -> A : \"\"\" `map` is a wrapper over `treeo.map` that passes `self` as the second argument. Arguments: f: The function to apply to the leaves. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" return api . map ( f , self , * filters , inplace = inplace , flatten_mode = flatten_mode , is_leaf = is_leaf , )","title":"map()"},{"location":"api/Lambda/#treex.nn.sequential.Lambda.merge","text":"merge is a wrapper over treeo.merge that passes self as the first argument. Parameters: Name Type Description Default other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the merged values. If inplace is True , obj is returned. Source code in treex/nn/sequential.py def merge ( self : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" `merge` is a wrapper over `treeo.merge` that passes `self` as the first argument. Arguments: other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the merged values. If `inplace` is `True`, `obj` is returned. \"\"\" return api . merge ( self , other , * rest , inplace = inplace , flatten_mode = flatten_mode , ignore_static = ignore_static , )","title":"merge()"},{"location":"api/Lambda/#treex.nn.sequential.Lambda.metrics","text":"Returns a copy of the Module with only tx.Metric TreeParts, alias for filter(tx.Metric) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/sequential.py def metrics ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Metric TreeParts, alias for `filter(tx.Metric)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . MetricLog , * filters )","title":"metrics()"},{"location":"api/Lambda/#treex.nn.sequential.Lambda.model_states","text":"Returns a copy of the Module with only tx.ModelState TreeParts, alias for filter(tx.ModelState) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/sequential.py def model_states ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.ModelState TreeParts, alias for `filter(tx.ModelState)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . ModelState , * filters )","title":"model_states()"},{"location":"api/Lambda/#treex.nn.sequential.Lambda.parameters","text":"Returns a copy of the Module with only tx.Parameter TreeParts, alias for filter(tx.Parameter) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/sequential.py def parameters ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Parameter TreeParts, alias for `filter(tx.Parameter)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . Parameter , * filters )","title":"parameters()"},{"location":"api/Lambda/#treex.nn.sequential.Lambda.rngs","text":"Returns a copy of the Module with only tx.Rng TreeParts, alias for filter(tx.Rng) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/sequential.py def rngs ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Rng TreeParts, alias for `filter(tx.Rng)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . Rng , * filters )","title":"rngs()"},{"location":"api/Lambda/#treex.nn.sequential.Lambda.states","text":"Returns a copy of the Module with only tx.State TreeParts, alias for filter(tx.State) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/sequential.py def states ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.State TreeParts, alias for `filter(tx.State)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . State , * filters )","title":"states()"},{"location":"api/Lambda/#treex.nn.sequential.Lambda.tabulate","text":"Returns a tabular representation of the module. Parameters: Name Type Description Default depth int The maximum depth of the representation in terms of nested Modules, -1 means no limit. -1 signature bool Whether to show the signature of the Module. False param_types bool Whether to show the types of the parameters. True Returns: Type Description str A string containing the tabular representation. Source code in treex/nn/sequential.py def tabulate ( self , inputs : tp . Union [ tp . Any , types . Inputs , None ] = None , depth : int = - 1 , signature : bool = False , param_types : bool = True , ) -> str : \"\"\" Returns a tabular representation of the module. Arguments: depth: The maximum depth of the representation in terms of nested Modules, -1 means no limit. signature: Whether to show the signature of the Module. param_types: Whether to show the types of the parameters. Returns: A string containing the tabular representation. \"\"\" self = to . copy ( self ) if inputs is not None : if not isinstance ( inputs , types . Inputs ): inputs = types . Inputs ( inputs ) inputs = tp . cast ( types . Inputs , inputs ) if not isinstance ( self , tp . Callable ): raise TypeError ( \"`inputs` can only be specified if the module is a callable.\" ) with _Context ( call_info = {}): # call using self to preserve references def eval_call ( args , kwargs ): assert isinstance ( self , tp . Callable ) return self ( * args , ** kwargs ) jax . eval_shape ( eval_call , inputs . args , inputs . kwargs , ) call_info = _CONTEXT . call_info else : call_info = None with to . add_field_info (): flat : tp . List [ to . FieldInfo ] flat , _ = jax . tree_flatten ( self ) tree_part_types : tp . Tuple [ tp . Type [ types . TreePart ], ... ] = tuple ( { field_info . kind for field_info in flat if utils . _generic_issubclass ( field_info . kind , types . TreePart ) } ) path = () rows = list ( utils . _get_tabulate_rows ( path , self , depth , tree_part_types , signature , param_types ) ) modules = [ row [ 0 ] for row in rows ] rows = [ row [ 1 :] for row in rows ] if call_info is not None : for module , row in zip ( modules , rows ): if module in call_info : inputs , outputs = call_info [ module ] simplified_inputs = ( inputs . args [ 0 ] if len ( inputs . kwargs ) == 0 and len ( inputs . args ) == 1 else inputs . kwargs if len ( inputs . kwargs ) == 0 else inputs . kwargs if len ( inputs . args ) == 0 else ( inputs . args , inputs . kwargs ) ) inputs_repr = utils . _format_param_tree ( simplified_inputs ) outputs_repr = utils . _format_param_tree ( outputs ) else : inputs_repr = \"\" outputs_repr = \"\" row . insert ( 3 , outputs_repr ) row . insert ( 3 , inputs_repr ) n_non_treepart_cols = 2 if call_info is None else 4 rows [ 0 ][ 0 ] = \"*\" rows . append ( [ \"\" ] * n_non_treepart_cols + [ \"Total:\" ] + [ utils . _format_obj_size ( self . filter ( kind ), add_padding = True ) for kind in tree_part_types ] ) utils . _add_padding ( rows ) table = Table ( show_header = True , show_lines = True , show_footer = True , # box=rich.box.HORIZONTALS, ) table . add_column ( \"path\" ) table . add_column ( \"module\" ) table . add_column ( \"params\" ) if call_info is not None : table . add_column ( \"inputs\" ) table . add_column ( \"outputs\" ) for tree_part_type in tree_part_types : type_name = tree_part_type . __name__ if type_name . startswith ( \"_\" ): type_name = type_name [ 1 :] table . add_column ( type_name ) for row in rows [: - 1 ]: table . add_row ( * row ) table . columns [ n_non_treepart_cols ] . footer = Text . from_markup ( rows [ - 1 ][ n_non_treepart_cols ], justify = \"right\" ) for i in range ( len ( tree_part_types )): table . columns [ n_non_treepart_cols + 1 + i ] . footer = rows [ - 1 ][ n_non_treepart_cols + 1 + i ] table . caption_style = \"bold\" table . caption = \" \\n Total Parameters: \" + utils . _format_obj_size ( self , add_padding = False ) return utils . _get_rich_repr ( table )","title":"tabulate()"},{"location":"api/Lambda/#treex.nn.sequential.Lambda.to_dict","text":"to_dict is a wrapper over treeo.to_dict that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True type_info bool If True , type information is included. False field_info bool If True , field information is included. False Returns: Type Description Any A dict representation of the object. Source code in treex/nn/sequential.py def to_dict ( self , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : \"\"\" `to_dict` is a wrapper over `treeo.to_dict` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. type_info: If `True`, type information is included. field_info: If `True`, field information is included. Returns: A dict representation of the object. \"\"\" return api . to_dict ( self , private_fields = private_fields , static_fields = static_fields , type_info = type_info , field_info = field_info , )","title":"to_dict()"},{"location":"api/Lambda/#treex.nn.sequential.Lambda.to_string","text":"to_string is a wrapper over treeo.to_string that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True color bool If True , color is included. False Returns: Type Description str A string representation of the object. Source code in treex/nn/sequential.py def to_string ( self : A , * , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" `to_string` is a wrapper over `treeo.to_string` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. color: If `True`, color is included. Returns: A string representation of the object. \"\"\" return api . to_string ( self , private_fields = private_fields , static_fields = static_fields , color = color , )","title":"to_string()"},{"location":"api/Lambda/#treex.nn.sequential.Lambda.train","text":"Creates a new module with the same structure, but with Module.training set to the given value. Parameters: Name Type Description Default mode bool The new training mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~M The new module in with the training mode is set to the given value, if inplace is True then self is returned. Source code in treex/nn/sequential.py def train ( self : M , mode : bool = True , inplace : bool = False ) -> M : \"\"\" Creates a new module with the same structure, but with `Module.training` set to the given value. Arguments: mode: The new training mode. inplace: Whether to update the module inplace. Returns: The new module in with the training mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_training ( module : Module ): if isinstance ( module , Module ): module . _training = mode return to . apply ( set_training , self , inplace = inplace )","title":"train()"},{"location":"api/Lambda/#treex.nn.sequential.Lambda.unfreeze","text":"Creates a new module with .frozen set to False, equivalent to calling freeze(False) . Parameters: Name Type Description Default inplace bool Whether to update the module inplace. False Returns: Type Description ~M The new module with .frozen set to False, if inplace is True then self is returned. Source code in treex/nn/sequential.py def unfreeze ( self : M , inplace : bool = False ) -> M : \"\"\" Creates a new module with `.frozen` set to False, equivalent to calling `freeze(False)`. Arguments: inplace: Whether to update the module inplace. Returns: The new module with `.frozen` set to False, if `inplace` is `True` then `self` is returned. \"\"\" return self . freeze ( False , inplace = inplace )","title":"unfreeze()"},{"location":"api/Linear/","text":"treex.Linear A linear transformation applied over the last dimension of the input. Linear is implemented as a wrapper over flax.linen.Dense , its constructor arguments accept almost the same arguments including any Flax artifacts such as initializers. Main differences: receives features_in as a first argument since shapes must be statically known. features argument is renamed to features_out . first_run : bool inherited property readonly Returns: Type Description bool True if its currently the first run of a compact method. __class__ inherited __base__ inherited Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()). __instancecheck__ ( cls , instance ) special Override for isinstance(instance, cls). Source code in treex/nn/linear.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance ) __new__ ( mcls , name , bases , namespace , ** kwargs ) special staticmethod Create and return a new object. See help(type) for accurate signature. Source code in treex/nn/linear.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls __subclasscheck__ ( cls , subclass ) special Override for issubclass(subclass, cls). Source code in treex/nn/linear.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass ) register ( cls , subclass ) Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/linear.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) register ( cls , subclass ) inherited Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/linear.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) __call__ ( self , x ) special Applies a linear transformation to the inputs along the last dimension. Parameters: Name Type Description Default x ndarray The nd-array to be transformed. required Returns: Type Description ndarray The transformed input. Source code in treex/nn/linear.py def __call__ ( self , x : np . ndarray ) -> jnp . ndarray : \"\"\"Applies a linear transformation to the inputs along the last dimension. Arguments: x: The nd-array to be transformed. Returns: The transformed input. \"\"\" assert self . initialized , \"Module is not initialized.\" assert self . kernel is not None params = { \"kernel\" : self . kernel } if self . use_bias : assert self . bias is not None params [ \"bias\" ] = self . bias output = self . module . apply ({ \"params\" : params }, x ) return tp . cast ( jnp . ndarray , output ) __init__ ( self , features_in , features_out , use_bias = True , dtype =< class ' jax . _src . numpy . lax_numpy . float32 '>, precision=None, kernel_init=<function variance_scaling.<locals>.init at 0x7fc075c2ed30>, bias_init=<function zeros at 0x7fc07ed80ca0>) special Parameters: Name Type Description Default features_in int the number of input features. required features_out int the number of output features. required use_bias bool whether to add a bias to the output (default: True). True dtype Any the dtype of the computation (default: float32). <class 'jax._src.numpy.lax_numpy.float32'> precision Any numerical precision of the computation see jax.lax.Precision for details. None kernel_init Callable[[Any, Iterable[int], Any], Any] initializer function for the weight matrix. <function variance_scaling.<locals>.init at 0x7fc075c2ed30> bias_init Callable[[Any, Iterable[int], Any], Any] initializer function for the bias. <function zeros at 0x7fc07ed80ca0> Source code in treex/nn/linear.py def __init__ ( self , features_in : int , features_out : int , use_bias : bool = True , dtype : tp . Any = jnp . float32 , precision : tp . Any = None , kernel_init : tp . Callable [ [ flax_module . PRNGKey , flax_module . Shape , flax_module . Dtype ], flax_module . Array , ] = flax_module . default_kernel_init , bias_init : tp . Callable [ [ flax_module . PRNGKey , flax_module . Shape , flax_module . Dtype ], flax_module . Array , ] = flax_module . zeros , ): \"\"\" Arguments: features_in: the number of input features. features_out: the number of output features. use_bias: whether to add a bias to the output (default: True). dtype: the dtype of the computation (default: float32). precision: numerical precision of the computation see `jax.lax.Precision` for details. kernel_init: initializer function for the weight matrix. bias_init: initializer function for the bias. \"\"\" self . features_in = features_in self . features_out = features_out self . use_bias = use_bias self . dtype = dtype self . precision = precision self . kernel_init = kernel_init self . bias_init = bias_init self . kernel = None self . bias = None apply ( self , f , * rest , * , inplace = False ) inherited apply is a wrapper over treeo.apply that passes self as the second argument. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treex/nn/linear.py def apply ( self : A , f : tp . Callable [ ... , None ], * rest : A , inplace : bool = False ) -> A : \"\"\" `apply` is a wrapper over `treeo.apply` that passes `self` as the second argument. Arguments: f: The function to apply. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" return api . apply ( f , self , * rest , inplace = inplace ) batch_stats ( self , * filters ) inherited Returns a copy of the Module with only tx.BatchStat TreeParts, alias for filter(tx.BatchStat) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/linear.py def batch_stats ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.BatchStat TreeParts, alias for `filter(tx.BatchStat)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . BatchStat , * filters ) check_metadata_updates ( self ) inherited Checks for new fields, if found, adds them to the metadata. Source code in treex/nn/linear.py def check_metadata_updates ( self ): \"\"\" Checks for new fields, if found, adds them to the metadata. \"\"\" with _CONTEXT . update ( flatten_mode = FlattenMode . all_fields ): jax . tree_flatten ( self ) copy ( self ) inherited copy is a wrapper over treeo.copy that passes self as the first argument. Source code in treex/nn/linear.py def copy ( self : A ) -> A : \"\"\" `copy` is a wrapper over `treeo.copy` that passes `self` as the first argument. \"\"\" return tree_m . copy ( self ) eval ( self , inplace = False ) inherited Creates a new module with the training mode set to False, equivalent to calling train(False) . Returns: Type Description ~M The new module with the training mode set to False. Source code in treex/nn/linear.py def eval ( self : M , inplace : bool = False ) -> M : \"\"\" Creates a new module with the training mode set to False, equivalent to calling `train(False)`. Returns: The new module with the training mode set to False. \"\"\" return self . train ( False , inplace = inplace ) filter ( self , * filters , * , inplace = False , flatten_mode = None ) inherited filter is a wrapper over treeo.filter that passes self as the first argument. Parameters: Name Type Description Default *filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treex/nn/linear.py def filter ( self : A , * filters : api . Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ) -> A : \"\"\" `filter` is a wrapper over `treeo.filter` that passes `self` as the first argument. Arguments: *filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" return api . filter ( self , * filters , inplace = inplace , flatten_mode = flatten_mode ) freeze ( self , mode = True , inplace = False ) inherited Creates a new module with the same structure, but with Module.frozen set to the given value. Parameters: Name Type Description Default mode bool The new frozen mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~M The new module in with the frozen mode is set to the given value, if inplace is True then self is returned. Source code in treex/nn/linear.py def freeze ( self : M , mode : bool = True , inplace : bool = False ) -> M : \"\"\" Creates a new module with the same structure, but with `Module.frozen` set to the given value. Arguments: mode: The new `frozen` mode. inplace: Whether to update the module inplace. Returns: The new module in with the `frozen` mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_frozen ( module : Module ): if isinstance ( module , Module ): module . _frozen = mode return to . apply ( set_frozen , self , inplace = inplace ) get_field ( self , field_name , initializer ) inherited A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: The field must be declared in the class definition. The method can only be called inside a compact context. Parameters: Name Type Description Default field_name str The name of the field to get. required initializer Callable[[], ~A] The function to initialize the field if it does not exist. required Returns: Type Description ~A The field value. Source code in treex/nn/linear.py def get_field ( self , field_name : str , initializer : tp . Callable [[], A ], ) -> A : \"\"\" A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: * The field must be declared in the class definition. * The method can only be called inside a `compact` context. Arguments: field_name: The name of the field to get. initializer: The function to initialize the field if it does not exist. Returns: The field value. \"\"\" value : A if field_name not in self . _field_metadata : raise ValueError ( f \"Metadata for field ' { field_name } ' does not exist.\" ) if tree_m . _COMPACT_CONTEXT . current_tree is not self : raise RuntimeError ( f \"Object ' { type ( self ) . __name__ } ' is not the current tree, found ' { type ( tree_m . _COMPACT_CONTEXT . current_tree ) . __name__ } ', did you forget the @compact decorator?\" ) if field_name in vars ( self ): value = getattr ( self , field_name ) else : if tree_m . _COMPACT_CONTEXT . in_compact and not self . first_run : raise RuntimeError ( f \"Trying to initialize field ' { field_name } ' after the first run of `compact`.\" ) value = initializer () setattr ( self , field_name , value ) return value init ( self , key , inplace = False ) inherited Method version of tx.init , it applies self as first argument. init creates a new module with the same structure, but with its fields initialized given a seed key . The following procedure is used: The input key is split and iteratively updated before passing a derived value to any process that requires initialization. Initializer s are called and applied to the module first. Module.rng_init methods are called last. Parameters: Name Type Description Default key Union[int, jax._src.numpy.lax_numpy.ndarray] The seed to use for initialization. required Returns: Type Description ~M The new module with the fields initialized. Source code in treex/nn/linear.py def init ( self : M , key : tp . Union [ int , jnp . ndarray ], inplace : bool = False ) -> M : \"\"\" Method version of `tx.init`, it applies `self` as first argument. `init` creates a new module with the same structure, but with its fields initialized given a seed `key`. The following procedure is used: 1. The input `key` is split and iteratively updated before passing a derived value to any process that requires initialization. 2. `Initializer`s are called and applied to the module first. 3. `Module.rng_init` methods are called last. Arguments: key: The seed to use for initialization. Returns: The new module with the fields initialized. \"\"\" if isinstance ( key , int ): key = jax . random . PRNGKey ( key ) def next_key () -> jnp . ndarray : nonlocal key assert isinstance ( key , ( np . ndarray , jnp . ndarray )) next_key , key = utils . iter_split ( key ) return next_key tree_out : M = jax . tree_map ( lambda initializer : ( initializer ( next_key ()) if isinstance ( initializer , types . Initializer ) else initializer ), self , is_leaf = lambda x : isinstance ( x , types . Initializer ), ) if inplace : # here we update initialized fields by the above tree_map tree_out = to . merge ( self , tree_out , inplace = True ) def call_module_init ( module : Module ): if isinstance ( module , Module ) and not module . _initialized : module . rng_init ( next_key ()) module . _initialized = True return to . apply ( call_module_init , tree_out , inplace = inplace ) logs ( self , * filters ) inherited Returns a copy of the Module with only tx.Log TreeParts, alias for filter(tx.Log) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/linear.py def logs ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Log TreeParts, alias for `filter(tx.Log)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . Log , * filters ) losses ( self , * filters ) inherited Returns a copy of the Module with only tx.Loss TreeParts, alias for filter(tx.Loss) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/linear.py def losses ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Loss TreeParts, alias for `filter(tx.Loss)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . LossLog , * filters ) map ( self , f , * filters , * , inplace = False , flatten_mode = None , is_leaf = None ) inherited map is a wrapper over treeo.map that passes self as the second argument. Parameters: Name Type Description Default f Callable The function to apply to the leaves. required *filters Filter The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treex/nn/linear.py def map ( self : A , f : tp . Callable , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , is_leaf : tp . Callable [[ tp . Any ], bool ] = None , ) -> A : \"\"\" `map` is a wrapper over `treeo.map` that passes `self` as the second argument. Arguments: f: The function to apply to the leaves. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" return api . map ( f , self , * filters , inplace = inplace , flatten_mode = flatten_mode , is_leaf = is_leaf , ) merge ( self , other , * rest , * , inplace = False , flatten_mode = None , ignore_static = False ) inherited merge is a wrapper over treeo.merge that passes self as the first argument. Parameters: Name Type Description Default other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the merged values. If inplace is True , obj is returned. Source code in treex/nn/linear.py def merge ( self : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" `merge` is a wrapper over `treeo.merge` that passes `self` as the first argument. Arguments: other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the merged values. If `inplace` is `True`, `obj` is returned. \"\"\" return api . merge ( self , other , * rest , inplace = inplace , flatten_mode = flatten_mode , ignore_static = ignore_static , ) metrics ( self , * filters ) inherited Returns a copy of the Module with only tx.Metric TreeParts, alias for filter(tx.Metric) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/linear.py def metrics ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Metric TreeParts, alias for `filter(tx.Metric)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . MetricLog , * filters ) model_states ( self , * filters ) inherited Returns a copy of the Module with only tx.ModelState TreeParts, alias for filter(tx.ModelState) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/linear.py def model_states ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.ModelState TreeParts, alias for `filter(tx.ModelState)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . ModelState , * filters ) parameters ( self , * filters ) inherited Returns a copy of the Module with only tx.Parameter TreeParts, alias for filter(tx.Parameter) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/linear.py def parameters ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Parameter TreeParts, alias for `filter(tx.Parameter)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . Parameter , * filters ) rngs ( self , * filters ) inherited Returns a copy of the Module with only tx.Rng TreeParts, alias for filter(tx.Rng) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/linear.py def rngs ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Rng TreeParts, alias for `filter(tx.Rng)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . Rng , * filters ) states ( self , * filters ) inherited Returns a copy of the Module with only tx.State TreeParts, alias for filter(tx.State) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/linear.py def states ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.State TreeParts, alias for `filter(tx.State)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . State , * filters ) tabulate ( self , inputs = None , depth =- 1 , signature = False , param_types = True ) inherited Returns a tabular representation of the module. Parameters: Name Type Description Default depth int The maximum depth of the representation in terms of nested Modules, -1 means no limit. -1 signature bool Whether to show the signature of the Module. False param_types bool Whether to show the types of the parameters. True Returns: Type Description str A string containing the tabular representation. Source code in treex/nn/linear.py def tabulate ( self , inputs : tp . Union [ tp . Any , types . Inputs , None ] = None , depth : int = - 1 , signature : bool = False , param_types : bool = True , ) -> str : \"\"\" Returns a tabular representation of the module. Arguments: depth: The maximum depth of the representation in terms of nested Modules, -1 means no limit. signature: Whether to show the signature of the Module. param_types: Whether to show the types of the parameters. Returns: A string containing the tabular representation. \"\"\" self = to . copy ( self ) if inputs is not None : if not isinstance ( inputs , types . Inputs ): inputs = types . Inputs ( inputs ) inputs = tp . cast ( types . Inputs , inputs ) if not isinstance ( self , tp . Callable ): raise TypeError ( \"`inputs` can only be specified if the module is a callable.\" ) with _Context ( call_info = {}): # call using self to preserve references def eval_call ( args , kwargs ): assert isinstance ( self , tp . Callable ) return self ( * args , ** kwargs ) jax . eval_shape ( eval_call , inputs . args , inputs . kwargs , ) call_info = _CONTEXT . call_info else : call_info = None with to . add_field_info (): flat : tp . List [ to . FieldInfo ] flat , _ = jax . tree_flatten ( self ) tree_part_types : tp . Tuple [ tp . Type [ types . TreePart ], ... ] = tuple ( { field_info . kind for field_info in flat if utils . _generic_issubclass ( field_info . kind , types . TreePart ) } ) path = () rows = list ( utils . _get_tabulate_rows ( path , self , depth , tree_part_types , signature , param_types ) ) modules = [ row [ 0 ] for row in rows ] rows = [ row [ 1 :] for row in rows ] if call_info is not None : for module , row in zip ( modules , rows ): if module in call_info : inputs , outputs = call_info [ module ] simplified_inputs = ( inputs . args [ 0 ] if len ( inputs . kwargs ) == 0 and len ( inputs . args ) == 1 else inputs . kwargs if len ( inputs . kwargs ) == 0 else inputs . kwargs if len ( inputs . args ) == 0 else ( inputs . args , inputs . kwargs ) ) inputs_repr = utils . _format_param_tree ( simplified_inputs ) outputs_repr = utils . _format_param_tree ( outputs ) else : inputs_repr = \"\" outputs_repr = \"\" row . insert ( 3 , outputs_repr ) row . insert ( 3 , inputs_repr ) n_non_treepart_cols = 2 if call_info is None else 4 rows [ 0 ][ 0 ] = \"*\" rows . append ( [ \"\" ] * n_non_treepart_cols + [ \"Total:\" ] + [ utils . _format_obj_size ( self . filter ( kind ), add_padding = True ) for kind in tree_part_types ] ) utils . _add_padding ( rows ) table = Table ( show_header = True , show_lines = True , show_footer = True , # box=rich.box.HORIZONTALS, ) table . add_column ( \"path\" ) table . add_column ( \"module\" ) table . add_column ( \"params\" ) if call_info is not None : table . add_column ( \"inputs\" ) table . add_column ( \"outputs\" ) for tree_part_type in tree_part_types : type_name = tree_part_type . __name__ if type_name . startswith ( \"_\" ): type_name = type_name [ 1 :] table . add_column ( type_name ) for row in rows [: - 1 ]: table . add_row ( * row ) table . columns [ n_non_treepart_cols ] . footer = Text . from_markup ( rows [ - 1 ][ n_non_treepart_cols ], justify = \"right\" ) for i in range ( len ( tree_part_types )): table . columns [ n_non_treepart_cols + 1 + i ] . footer = rows [ - 1 ][ n_non_treepart_cols + 1 + i ] table . caption_style = \"bold\" table . caption = \" \\n Total Parameters: \" + utils . _format_obj_size ( self , add_padding = False ) return utils . _get_rich_repr ( table ) to_dict ( self , * , private_fields = False , static_fields = True , type_info = False , field_info = False ) inherited to_dict is a wrapper over treeo.to_dict that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True type_info bool If True , type information is included. False field_info bool If True , field information is included. False Returns: Type Description Any A dict representation of the object. Source code in treex/nn/linear.py def to_dict ( self , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : \"\"\" `to_dict` is a wrapper over `treeo.to_dict` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. type_info: If `True`, type information is included. field_info: If `True`, field information is included. Returns: A dict representation of the object. \"\"\" return api . to_dict ( self , private_fields = private_fields , static_fields = static_fields , type_info = type_info , field_info = field_info , ) to_string ( self , * , private_fields = False , static_fields = True , color = False ) inherited to_string is a wrapper over treeo.to_string that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True color bool If True , color is included. False Returns: Type Description str A string representation of the object. Source code in treex/nn/linear.py def to_string ( self : A , * , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" `to_string` is a wrapper over `treeo.to_string` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. color: If `True`, color is included. Returns: A string representation of the object. \"\"\" return api . to_string ( self , private_fields = private_fields , static_fields = static_fields , color = color , ) train ( self , mode = True , inplace = False ) inherited Creates a new module with the same structure, but with Module.training set to the given value. Parameters: Name Type Description Default mode bool The new training mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~M The new module in with the training mode is set to the given value, if inplace is True then self is returned. Source code in treex/nn/linear.py def train ( self : M , mode : bool = True , inplace : bool = False ) -> M : \"\"\" Creates a new module with the same structure, but with `Module.training` set to the given value. Arguments: mode: The new training mode. inplace: Whether to update the module inplace. Returns: The new module in with the training mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_training ( module : Module ): if isinstance ( module , Module ): module . _training = mode return to . apply ( set_training , self , inplace = inplace ) unfreeze ( self , inplace = False ) inherited Creates a new module with .frozen set to False, equivalent to calling freeze(False) . Parameters: Name Type Description Default inplace bool Whether to update the module inplace. False Returns: Type Description ~M The new module with .frozen set to False, if inplace is True then self is returned. Source code in treex/nn/linear.py def unfreeze ( self : M , inplace : bool = False ) -> M : \"\"\" Creates a new module with `.frozen` set to False, equivalent to calling `freeze(False)`. Arguments: inplace: Whether to update the module inplace. Returns: The new module with `.frozen` set to False, if `inplace` is `True` then `self` is returned. \"\"\" return self . freeze ( False , inplace = inplace )","title":"Linear"},{"location":"api/Linear/#treexlinear","text":"A linear transformation applied over the last dimension of the input. Linear is implemented as a wrapper over flax.linen.Dense , its constructor arguments accept almost the same arguments including any Flax artifacts such as initializers. Main differences: receives features_in as a first argument since shapes must be statically known. features argument is renamed to features_out .","title":"treex.Linear"},{"location":"api/Linear/#treex.nn.linear.Linear.first_run","text":"Returns: Type Description bool True if its currently the first run of a compact method.","title":"first_run"},{"location":"api/Linear/#treex.nn.linear.Linear.__class__","text":"","title":"__class__"},{"location":"api/Linear/#treex.nn.linear.Linear.__class__.__base__","text":"Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()).","title":"__base__"},{"location":"api/Linear/#treex.nn.linear.Linear.__class__.__base__.__instancecheck__","text":"Override for isinstance(instance, cls). Source code in treex/nn/linear.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance )","title":"__instancecheck__()"},{"location":"api/Linear/#treex.nn.linear.Linear.__class__.__base__.__new__","text":"Create and return a new object. See help(type) for accurate signature. Source code in treex/nn/linear.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls","title":"__new__()"},{"location":"api/Linear/#treex.nn.linear.Linear.__class__.__base__.__subclasscheck__","text":"Override for issubclass(subclass, cls). Source code in treex/nn/linear.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass )","title":"__subclasscheck__()"},{"location":"api/Linear/#treex.nn.linear.Linear.__class__.__base__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/linear.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/Linear/#treex.nn.linear.Linear.__class__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/linear.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/Linear/#treex.nn.linear.Linear.__call__","text":"Applies a linear transformation to the inputs along the last dimension. Parameters: Name Type Description Default x ndarray The nd-array to be transformed. required Returns: Type Description ndarray The transformed input. Source code in treex/nn/linear.py def __call__ ( self , x : np . ndarray ) -> jnp . ndarray : \"\"\"Applies a linear transformation to the inputs along the last dimension. Arguments: x: The nd-array to be transformed. Returns: The transformed input. \"\"\" assert self . initialized , \"Module is not initialized.\" assert self . kernel is not None params = { \"kernel\" : self . kernel } if self . use_bias : assert self . bias is not None params [ \"bias\" ] = self . bias output = self . module . apply ({ \"params\" : params }, x ) return tp . cast ( jnp . ndarray , output )","title":"__call__()"},{"location":"api/Linear/#treex.nn.linear.Linear.__init__","text":"Parameters: Name Type Description Default features_in int the number of input features. required features_out int the number of output features. required use_bias bool whether to add a bias to the output (default: True). True dtype Any the dtype of the computation (default: float32). <class 'jax._src.numpy.lax_numpy.float32'> precision Any numerical precision of the computation see jax.lax.Precision for details. None kernel_init Callable[[Any, Iterable[int], Any], Any] initializer function for the weight matrix. <function variance_scaling.<locals>.init at 0x7fc075c2ed30> bias_init Callable[[Any, Iterable[int], Any], Any] initializer function for the bias. <function zeros at 0x7fc07ed80ca0> Source code in treex/nn/linear.py def __init__ ( self , features_in : int , features_out : int , use_bias : bool = True , dtype : tp . Any = jnp . float32 , precision : tp . Any = None , kernel_init : tp . Callable [ [ flax_module . PRNGKey , flax_module . Shape , flax_module . Dtype ], flax_module . Array , ] = flax_module . default_kernel_init , bias_init : tp . Callable [ [ flax_module . PRNGKey , flax_module . Shape , flax_module . Dtype ], flax_module . Array , ] = flax_module . zeros , ): \"\"\" Arguments: features_in: the number of input features. features_out: the number of output features. use_bias: whether to add a bias to the output (default: True). dtype: the dtype of the computation (default: float32). precision: numerical precision of the computation see `jax.lax.Precision` for details. kernel_init: initializer function for the weight matrix. bias_init: initializer function for the bias. \"\"\" self . features_in = features_in self . features_out = features_out self . use_bias = use_bias self . dtype = dtype self . precision = precision self . kernel_init = kernel_init self . bias_init = bias_init self . kernel = None self . bias = None","title":"__init__()"},{"location":"api/Linear/#treex.nn.linear.Linear.apply","text":"apply is a wrapper over treeo.apply that passes self as the second argument. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treex/nn/linear.py def apply ( self : A , f : tp . Callable [ ... , None ], * rest : A , inplace : bool = False ) -> A : \"\"\" `apply` is a wrapper over `treeo.apply` that passes `self` as the second argument. Arguments: f: The function to apply. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" return api . apply ( f , self , * rest , inplace = inplace )","title":"apply()"},{"location":"api/Linear/#treex.nn.linear.Linear.batch_stats","text":"Returns a copy of the Module with only tx.BatchStat TreeParts, alias for filter(tx.BatchStat) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/linear.py def batch_stats ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.BatchStat TreeParts, alias for `filter(tx.BatchStat)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . BatchStat , * filters )","title":"batch_stats()"},{"location":"api/Linear/#treex.nn.linear.Linear.check_metadata_updates","text":"Checks for new fields, if found, adds them to the metadata. Source code in treex/nn/linear.py def check_metadata_updates ( self ): \"\"\" Checks for new fields, if found, adds them to the metadata. \"\"\" with _CONTEXT . update ( flatten_mode = FlattenMode . all_fields ): jax . tree_flatten ( self )","title":"check_metadata_updates()"},{"location":"api/Linear/#treex.nn.linear.Linear.copy","text":"copy is a wrapper over treeo.copy that passes self as the first argument. Source code in treex/nn/linear.py def copy ( self : A ) -> A : \"\"\" `copy` is a wrapper over `treeo.copy` that passes `self` as the first argument. \"\"\" return tree_m . copy ( self )","title":"copy()"},{"location":"api/Linear/#treex.nn.linear.Linear.eval","text":"Creates a new module with the training mode set to False, equivalent to calling train(False) . Returns: Type Description ~M The new module with the training mode set to False. Source code in treex/nn/linear.py def eval ( self : M , inplace : bool = False ) -> M : \"\"\" Creates a new module with the training mode set to False, equivalent to calling `train(False)`. Returns: The new module with the training mode set to False. \"\"\" return self . train ( False , inplace = inplace )","title":"eval()"},{"location":"api/Linear/#treex.nn.linear.Linear.filter","text":"filter is a wrapper over treeo.filter that passes self as the first argument. Parameters: Name Type Description Default *filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treex/nn/linear.py def filter ( self : A , * filters : api . Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ) -> A : \"\"\" `filter` is a wrapper over `treeo.filter` that passes `self` as the first argument. Arguments: *filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" return api . filter ( self , * filters , inplace = inplace , flatten_mode = flatten_mode )","title":"filter()"},{"location":"api/Linear/#treex.nn.linear.Linear.freeze","text":"Creates a new module with the same structure, but with Module.frozen set to the given value. Parameters: Name Type Description Default mode bool The new frozen mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~M The new module in with the frozen mode is set to the given value, if inplace is True then self is returned. Source code in treex/nn/linear.py def freeze ( self : M , mode : bool = True , inplace : bool = False ) -> M : \"\"\" Creates a new module with the same structure, but with `Module.frozen` set to the given value. Arguments: mode: The new `frozen` mode. inplace: Whether to update the module inplace. Returns: The new module in with the `frozen` mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_frozen ( module : Module ): if isinstance ( module , Module ): module . _frozen = mode return to . apply ( set_frozen , self , inplace = inplace )","title":"freeze()"},{"location":"api/Linear/#treex.nn.linear.Linear.get_field","text":"A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: The field must be declared in the class definition. The method can only be called inside a compact context. Parameters: Name Type Description Default field_name str The name of the field to get. required initializer Callable[[], ~A] The function to initialize the field if it does not exist. required Returns: Type Description ~A The field value. Source code in treex/nn/linear.py def get_field ( self , field_name : str , initializer : tp . Callable [[], A ], ) -> A : \"\"\" A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: * The field must be declared in the class definition. * The method can only be called inside a `compact` context. Arguments: field_name: The name of the field to get. initializer: The function to initialize the field if it does not exist. Returns: The field value. \"\"\" value : A if field_name not in self . _field_metadata : raise ValueError ( f \"Metadata for field ' { field_name } ' does not exist.\" ) if tree_m . _COMPACT_CONTEXT . current_tree is not self : raise RuntimeError ( f \"Object ' { type ( self ) . __name__ } ' is not the current tree, found ' { type ( tree_m . _COMPACT_CONTEXT . current_tree ) . __name__ } ', did you forget the @compact decorator?\" ) if field_name in vars ( self ): value = getattr ( self , field_name ) else : if tree_m . _COMPACT_CONTEXT . in_compact and not self . first_run : raise RuntimeError ( f \"Trying to initialize field ' { field_name } ' after the first run of `compact`.\" ) value = initializer () setattr ( self , field_name , value ) return value","title":"get_field()"},{"location":"api/Linear/#treex.nn.linear.Linear.init","text":"Method version of tx.init , it applies self as first argument. init creates a new module with the same structure, but with its fields initialized given a seed key . The following procedure is used: The input key is split and iteratively updated before passing a derived value to any process that requires initialization. Initializer s are called and applied to the module first. Module.rng_init methods are called last. Parameters: Name Type Description Default key Union[int, jax._src.numpy.lax_numpy.ndarray] The seed to use for initialization. required Returns: Type Description ~M The new module with the fields initialized. Source code in treex/nn/linear.py def init ( self : M , key : tp . Union [ int , jnp . ndarray ], inplace : bool = False ) -> M : \"\"\" Method version of `tx.init`, it applies `self` as first argument. `init` creates a new module with the same structure, but with its fields initialized given a seed `key`. The following procedure is used: 1. The input `key` is split and iteratively updated before passing a derived value to any process that requires initialization. 2. `Initializer`s are called and applied to the module first. 3. `Module.rng_init` methods are called last. Arguments: key: The seed to use for initialization. Returns: The new module with the fields initialized. \"\"\" if isinstance ( key , int ): key = jax . random . PRNGKey ( key ) def next_key () -> jnp . ndarray : nonlocal key assert isinstance ( key , ( np . ndarray , jnp . ndarray )) next_key , key = utils . iter_split ( key ) return next_key tree_out : M = jax . tree_map ( lambda initializer : ( initializer ( next_key ()) if isinstance ( initializer , types . Initializer ) else initializer ), self , is_leaf = lambda x : isinstance ( x , types . Initializer ), ) if inplace : # here we update initialized fields by the above tree_map tree_out = to . merge ( self , tree_out , inplace = True ) def call_module_init ( module : Module ): if isinstance ( module , Module ) and not module . _initialized : module . rng_init ( next_key ()) module . _initialized = True return to . apply ( call_module_init , tree_out , inplace = inplace )","title":"init()"},{"location":"api/Linear/#treex.nn.linear.Linear.logs","text":"Returns a copy of the Module with only tx.Log TreeParts, alias for filter(tx.Log) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/linear.py def logs ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Log TreeParts, alias for `filter(tx.Log)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . Log , * filters )","title":"logs()"},{"location":"api/Linear/#treex.nn.linear.Linear.losses","text":"Returns a copy of the Module with only tx.Loss TreeParts, alias for filter(tx.Loss) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/linear.py def losses ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Loss TreeParts, alias for `filter(tx.Loss)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . LossLog , * filters )","title":"losses()"},{"location":"api/Linear/#treex.nn.linear.Linear.map","text":"map is a wrapper over treeo.map that passes self as the second argument. Parameters: Name Type Description Default f Callable The function to apply to the leaves. required *filters Filter The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treex/nn/linear.py def map ( self : A , f : tp . Callable , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , is_leaf : tp . Callable [[ tp . Any ], bool ] = None , ) -> A : \"\"\" `map` is a wrapper over `treeo.map` that passes `self` as the second argument. Arguments: f: The function to apply to the leaves. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" return api . map ( f , self , * filters , inplace = inplace , flatten_mode = flatten_mode , is_leaf = is_leaf , )","title":"map()"},{"location":"api/Linear/#treex.nn.linear.Linear.merge","text":"merge is a wrapper over treeo.merge that passes self as the first argument. Parameters: Name Type Description Default other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the merged values. If inplace is True , obj is returned. Source code in treex/nn/linear.py def merge ( self : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" `merge` is a wrapper over `treeo.merge` that passes `self` as the first argument. Arguments: other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the merged values. If `inplace` is `True`, `obj` is returned. \"\"\" return api . merge ( self , other , * rest , inplace = inplace , flatten_mode = flatten_mode , ignore_static = ignore_static , )","title":"merge()"},{"location":"api/Linear/#treex.nn.linear.Linear.metrics","text":"Returns a copy of the Module with only tx.Metric TreeParts, alias for filter(tx.Metric) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/linear.py def metrics ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Metric TreeParts, alias for `filter(tx.Metric)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . MetricLog , * filters )","title":"metrics()"},{"location":"api/Linear/#treex.nn.linear.Linear.model_states","text":"Returns a copy of the Module with only tx.ModelState TreeParts, alias for filter(tx.ModelState) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/linear.py def model_states ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.ModelState TreeParts, alias for `filter(tx.ModelState)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . ModelState , * filters )","title":"model_states()"},{"location":"api/Linear/#treex.nn.linear.Linear.parameters","text":"Returns a copy of the Module with only tx.Parameter TreeParts, alias for filter(tx.Parameter) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/linear.py def parameters ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Parameter TreeParts, alias for `filter(tx.Parameter)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . Parameter , * filters )","title":"parameters()"},{"location":"api/Linear/#treex.nn.linear.Linear.rngs","text":"Returns a copy of the Module with only tx.Rng TreeParts, alias for filter(tx.Rng) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/linear.py def rngs ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Rng TreeParts, alias for `filter(tx.Rng)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . Rng , * filters )","title":"rngs()"},{"location":"api/Linear/#treex.nn.linear.Linear.states","text":"Returns a copy of the Module with only tx.State TreeParts, alias for filter(tx.State) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/linear.py def states ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.State TreeParts, alias for `filter(tx.State)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . State , * filters )","title":"states()"},{"location":"api/Linear/#treex.nn.linear.Linear.tabulate","text":"Returns a tabular representation of the module. Parameters: Name Type Description Default depth int The maximum depth of the representation in terms of nested Modules, -1 means no limit. -1 signature bool Whether to show the signature of the Module. False param_types bool Whether to show the types of the parameters. True Returns: Type Description str A string containing the tabular representation. Source code in treex/nn/linear.py def tabulate ( self , inputs : tp . Union [ tp . Any , types . Inputs , None ] = None , depth : int = - 1 , signature : bool = False , param_types : bool = True , ) -> str : \"\"\" Returns a tabular representation of the module. Arguments: depth: The maximum depth of the representation in terms of nested Modules, -1 means no limit. signature: Whether to show the signature of the Module. param_types: Whether to show the types of the parameters. Returns: A string containing the tabular representation. \"\"\" self = to . copy ( self ) if inputs is not None : if not isinstance ( inputs , types . Inputs ): inputs = types . Inputs ( inputs ) inputs = tp . cast ( types . Inputs , inputs ) if not isinstance ( self , tp . Callable ): raise TypeError ( \"`inputs` can only be specified if the module is a callable.\" ) with _Context ( call_info = {}): # call using self to preserve references def eval_call ( args , kwargs ): assert isinstance ( self , tp . Callable ) return self ( * args , ** kwargs ) jax . eval_shape ( eval_call , inputs . args , inputs . kwargs , ) call_info = _CONTEXT . call_info else : call_info = None with to . add_field_info (): flat : tp . List [ to . FieldInfo ] flat , _ = jax . tree_flatten ( self ) tree_part_types : tp . Tuple [ tp . Type [ types . TreePart ], ... ] = tuple ( { field_info . kind for field_info in flat if utils . _generic_issubclass ( field_info . kind , types . TreePart ) } ) path = () rows = list ( utils . _get_tabulate_rows ( path , self , depth , tree_part_types , signature , param_types ) ) modules = [ row [ 0 ] for row in rows ] rows = [ row [ 1 :] for row in rows ] if call_info is not None : for module , row in zip ( modules , rows ): if module in call_info : inputs , outputs = call_info [ module ] simplified_inputs = ( inputs . args [ 0 ] if len ( inputs . kwargs ) == 0 and len ( inputs . args ) == 1 else inputs . kwargs if len ( inputs . kwargs ) == 0 else inputs . kwargs if len ( inputs . args ) == 0 else ( inputs . args , inputs . kwargs ) ) inputs_repr = utils . _format_param_tree ( simplified_inputs ) outputs_repr = utils . _format_param_tree ( outputs ) else : inputs_repr = \"\" outputs_repr = \"\" row . insert ( 3 , outputs_repr ) row . insert ( 3 , inputs_repr ) n_non_treepart_cols = 2 if call_info is None else 4 rows [ 0 ][ 0 ] = \"*\" rows . append ( [ \"\" ] * n_non_treepart_cols + [ \"Total:\" ] + [ utils . _format_obj_size ( self . filter ( kind ), add_padding = True ) for kind in tree_part_types ] ) utils . _add_padding ( rows ) table = Table ( show_header = True , show_lines = True , show_footer = True , # box=rich.box.HORIZONTALS, ) table . add_column ( \"path\" ) table . add_column ( \"module\" ) table . add_column ( \"params\" ) if call_info is not None : table . add_column ( \"inputs\" ) table . add_column ( \"outputs\" ) for tree_part_type in tree_part_types : type_name = tree_part_type . __name__ if type_name . startswith ( \"_\" ): type_name = type_name [ 1 :] table . add_column ( type_name ) for row in rows [: - 1 ]: table . add_row ( * row ) table . columns [ n_non_treepart_cols ] . footer = Text . from_markup ( rows [ - 1 ][ n_non_treepart_cols ], justify = \"right\" ) for i in range ( len ( tree_part_types )): table . columns [ n_non_treepart_cols + 1 + i ] . footer = rows [ - 1 ][ n_non_treepart_cols + 1 + i ] table . caption_style = \"bold\" table . caption = \" \\n Total Parameters: \" + utils . _format_obj_size ( self , add_padding = False ) return utils . _get_rich_repr ( table )","title":"tabulate()"},{"location":"api/Linear/#treex.nn.linear.Linear.to_dict","text":"to_dict is a wrapper over treeo.to_dict that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True type_info bool If True , type information is included. False field_info bool If True , field information is included. False Returns: Type Description Any A dict representation of the object. Source code in treex/nn/linear.py def to_dict ( self , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : \"\"\" `to_dict` is a wrapper over `treeo.to_dict` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. type_info: If `True`, type information is included. field_info: If `True`, field information is included. Returns: A dict representation of the object. \"\"\" return api . to_dict ( self , private_fields = private_fields , static_fields = static_fields , type_info = type_info , field_info = field_info , )","title":"to_dict()"},{"location":"api/Linear/#treex.nn.linear.Linear.to_string","text":"to_string is a wrapper over treeo.to_string that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True color bool If True , color is included. False Returns: Type Description str A string representation of the object. Source code in treex/nn/linear.py def to_string ( self : A , * , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" `to_string` is a wrapper over `treeo.to_string` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. color: If `True`, color is included. Returns: A string representation of the object. \"\"\" return api . to_string ( self , private_fields = private_fields , static_fields = static_fields , color = color , )","title":"to_string()"},{"location":"api/Linear/#treex.nn.linear.Linear.train","text":"Creates a new module with the same structure, but with Module.training set to the given value. Parameters: Name Type Description Default mode bool The new training mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~M The new module in with the training mode is set to the given value, if inplace is True then self is returned. Source code in treex/nn/linear.py def train ( self : M , mode : bool = True , inplace : bool = False ) -> M : \"\"\" Creates a new module with the same structure, but with `Module.training` set to the given value. Arguments: mode: The new training mode. inplace: Whether to update the module inplace. Returns: The new module in with the training mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_training ( module : Module ): if isinstance ( module , Module ): module . _training = mode return to . apply ( set_training , self , inplace = inplace )","title":"train()"},{"location":"api/Linear/#treex.nn.linear.Linear.unfreeze","text":"Creates a new module with .frozen set to False, equivalent to calling freeze(False) . Parameters: Name Type Description Default inplace bool Whether to update the module inplace. False Returns: Type Description ~M The new module with .frozen set to False, if inplace is True then self is returned. Source code in treex/nn/linear.py def unfreeze ( self : M , inplace : bool = False ) -> M : \"\"\" Creates a new module with `.frozen` set to False, equivalent to calling `freeze(False)`. Arguments: inplace: Whether to update the module inplace. Returns: The new module with `.frozen` set to False, if `inplace` is `True` then `self` is returned. \"\"\" return self . freeze ( False , inplace = inplace )","title":"unfreeze()"},{"location":"api/Log/","text":"treex.Log","title":"Log"},{"location":"api/Log/#treexlog","text":"","title":"treex.Log"},{"location":"api/LossLog/","text":"treex.LossLog","title":"LossLog"},{"location":"api/LossLog/#treexlosslog","text":"","title":"treex.LossLog"},{"location":"api/MLP/","text":"treex.MLP A Multi-Layer Perceptron (MLP) that applies a sequence of linear layers with a given activation (relu by default), the last layer is linear. first_run : bool inherited property readonly Returns: Type Description bool True if its currently the first run of a compact method. __class__ inherited __base__ inherited Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()). __instancecheck__ ( cls , instance ) special Override for isinstance(instance, cls). Source code in treex/nn/mlp.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance ) __new__ ( mcls , name , bases , namespace , ** kwargs ) special staticmethod Create and return a new object. See help(type) for accurate signature. Source code in treex/nn/mlp.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls __subclasscheck__ ( cls , subclass ) special Override for issubclass(subclass, cls). Source code in treex/nn/mlp.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass ) register ( cls , subclass ) Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/mlp.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) register ( cls , subclass ) inherited Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/mlp.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) __call__ ( self , x ) special Applies the MLP to the input. Parameters: Name Type Description Default x ndarray input array. required Returns: Type Description ndarray The output of the MLP. Source code in treex/nn/mlp.py def __call__ ( self , x : np . ndarray ) -> jnp . ndarray : \"\"\" Applies the MLP to the input. Arguments: x: input array. Returns: The output of the MLP. \"\"\" for layer in self . layers [: - 1 ]: x = self . activation ( layer ( x )) return self . layers [ - 1 ]( x ) __init__ ( self , features , activation =< jax . _src . custom_derivatives . custom_jvp object at 0x7fc07ed48130 > , use_bias = True , dtype =< class ' jax . _src . numpy . lax_numpy . float32 '>, precision=None, kernel_init=<function variance_scaling.<locals>.init at 0x7fc075c2ed30>, bias_init=<function zeros at 0x7fc07ed80ca0>) special Parameters: Name Type Description Default features Sequence[int] a sequence of L+1 integers, where L is the number of layers, the first integer is the number of input features and all subsequent integers are the number of output features of the respective layer. required activation Callable[[jax._src.numpy.lax_numpy.ndarray], jax._src.numpy.lax_numpy.ndarray] the activation function to use. <jax._src.custom_derivatives.custom_jvp object at 0x7fc07ed48130> use_bias bool whether to add a bias to the output (default: True). True dtype Any the dtype of the computation (default: float32). <class 'jax._src.numpy.lax_numpy.float32'> precision Any numerical precision of the computation see jax.lax.Precision for details. None kernel_init Callable[[Any, Iterable[int], Any], Any] initializer function for the weight matrix. <function variance_scaling.<locals>.init at 0x7fc075c2ed30> bias_init Callable[[Any, Iterable[int], Any], Any] initializer function for the bias. <function zeros at 0x7fc07ed80ca0> Source code in treex/nn/mlp.py def __init__ ( self , features : tp . Sequence [ int ], activation : tp . Callable [[ jnp . ndarray ], jnp . ndarray ] = jax . nn . relu , use_bias : bool = True , dtype : tp . Any = jnp . float32 , precision : tp . Any = None , kernel_init : tp . Callable [ [ flax_module . PRNGKey , flax_module . Shape , flax_module . Dtype ], flax_module . Array , ] = flax_module . default_kernel_init , bias_init : tp . Callable [ [ flax_module . PRNGKey , flax_module . Shape , flax_module . Dtype ], flax_module . Array , ] = flax_module . zeros , ): \"\"\" Arguments: features: a sequence of L+1 integers, where L is the number of layers, the first integer is the number of input features and all subsequent integers are the number of output features of the respective layer. activation: the activation function to use. use_bias: whether to add a bias to the output (default: True). dtype: the dtype of the computation (default: float32). precision: numerical precision of the computation see `jax.lax.Precision` for details. kernel_init: initializer function for the weight matrix. bias_init: initializer function for the bias. \"\"\" if len ( features ) < 2 : raise ValueError ( \"features must have at least 2 elements\" ) self . features = features self . activation = activation self . layers = [ Linear ( features_in = features_in , features_out = features_out , use_bias = use_bias , dtype = dtype , precision = precision , kernel_init = kernel_init , bias_init = bias_init , ) for features_in , features_out in zip ( features [: - 1 ], features [ 1 :]) ] apply ( self , f , * rest , * , inplace = False ) inherited apply is a wrapper over treeo.apply that passes self as the second argument. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treex/nn/mlp.py def apply ( self : A , f : tp . Callable [ ... , None ], * rest : A , inplace : bool = False ) -> A : \"\"\" `apply` is a wrapper over `treeo.apply` that passes `self` as the second argument. Arguments: f: The function to apply. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" return api . apply ( f , self , * rest , inplace = inplace ) batch_stats ( self , * filters ) inherited Returns a copy of the Module with only tx.BatchStat TreeParts, alias for filter(tx.BatchStat) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/mlp.py def batch_stats ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.BatchStat TreeParts, alias for `filter(tx.BatchStat)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . BatchStat , * filters ) check_metadata_updates ( self ) inherited Checks for new fields, if found, adds them to the metadata. Source code in treex/nn/mlp.py def check_metadata_updates ( self ): \"\"\" Checks for new fields, if found, adds them to the metadata. \"\"\" with _CONTEXT . update ( flatten_mode = FlattenMode . all_fields ): jax . tree_flatten ( self ) copy ( self ) inherited copy is a wrapper over treeo.copy that passes self as the first argument. Source code in treex/nn/mlp.py def copy ( self : A ) -> A : \"\"\" `copy` is a wrapper over `treeo.copy` that passes `self` as the first argument. \"\"\" return tree_m . copy ( self ) eval ( self , inplace = False ) inherited Creates a new module with the training mode set to False, equivalent to calling train(False) . Returns: Type Description ~M The new module with the training mode set to False. Source code in treex/nn/mlp.py def eval ( self : M , inplace : bool = False ) -> M : \"\"\" Creates a new module with the training mode set to False, equivalent to calling `train(False)`. Returns: The new module with the training mode set to False. \"\"\" return self . train ( False , inplace = inplace ) filter ( self , * filters , * , inplace = False , flatten_mode = None ) inherited filter is a wrapper over treeo.filter that passes self as the first argument. Parameters: Name Type Description Default *filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treex/nn/mlp.py def filter ( self : A , * filters : api . Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ) -> A : \"\"\" `filter` is a wrapper over `treeo.filter` that passes `self` as the first argument. Arguments: *filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" return api . filter ( self , * filters , inplace = inplace , flatten_mode = flatten_mode ) freeze ( self , mode = True , inplace = False ) inherited Creates a new module with the same structure, but with Module.frozen set to the given value. Parameters: Name Type Description Default mode bool The new frozen mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~M The new module in with the frozen mode is set to the given value, if inplace is True then self is returned. Source code in treex/nn/mlp.py def freeze ( self : M , mode : bool = True , inplace : bool = False ) -> M : \"\"\" Creates a new module with the same structure, but with `Module.frozen` set to the given value. Arguments: mode: The new `frozen` mode. inplace: Whether to update the module inplace. Returns: The new module in with the `frozen` mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_frozen ( module : Module ): if isinstance ( module , Module ): module . _frozen = mode return to . apply ( set_frozen , self , inplace = inplace ) get_field ( self , field_name , initializer ) inherited A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: The field must be declared in the class definition. The method can only be called inside a compact context. Parameters: Name Type Description Default field_name str The name of the field to get. required initializer Callable[[], ~A] The function to initialize the field if it does not exist. required Returns: Type Description ~A The field value. Source code in treex/nn/mlp.py def get_field ( self , field_name : str , initializer : tp . Callable [[], A ], ) -> A : \"\"\" A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: * The field must be declared in the class definition. * The method can only be called inside a `compact` context. Arguments: field_name: The name of the field to get. initializer: The function to initialize the field if it does not exist. Returns: The field value. \"\"\" value : A if field_name not in self . _field_metadata : raise ValueError ( f \"Metadata for field ' { field_name } ' does not exist.\" ) if tree_m . _COMPACT_CONTEXT . current_tree is not self : raise RuntimeError ( f \"Object ' { type ( self ) . __name__ } ' is not the current tree, found ' { type ( tree_m . _COMPACT_CONTEXT . current_tree ) . __name__ } ', did you forget the @compact decorator?\" ) if field_name in vars ( self ): value = getattr ( self , field_name ) else : if tree_m . _COMPACT_CONTEXT . in_compact and not self . first_run : raise RuntimeError ( f \"Trying to initialize field ' { field_name } ' after the first run of `compact`.\" ) value = initializer () setattr ( self , field_name , value ) return value init ( self , key , inplace = False ) inherited Method version of tx.init , it applies self as first argument. init creates a new module with the same structure, but with its fields initialized given a seed key . The following procedure is used: The input key is split and iteratively updated before passing a derived value to any process that requires initialization. Initializer s are called and applied to the module first. Module.rng_init methods are called last. Parameters: Name Type Description Default key Union[int, jax._src.numpy.lax_numpy.ndarray] The seed to use for initialization. required Returns: Type Description ~M The new module with the fields initialized. Source code in treex/nn/mlp.py def init ( self : M , key : tp . Union [ int , jnp . ndarray ], inplace : bool = False ) -> M : \"\"\" Method version of `tx.init`, it applies `self` as first argument. `init` creates a new module with the same structure, but with its fields initialized given a seed `key`. The following procedure is used: 1. The input `key` is split and iteratively updated before passing a derived value to any process that requires initialization. 2. `Initializer`s are called and applied to the module first. 3. `Module.rng_init` methods are called last. Arguments: key: The seed to use for initialization. Returns: The new module with the fields initialized. \"\"\" if isinstance ( key , int ): key = jax . random . PRNGKey ( key ) def next_key () -> jnp . ndarray : nonlocal key assert isinstance ( key , ( np . ndarray , jnp . ndarray )) next_key , key = utils . iter_split ( key ) return next_key tree_out : M = jax . tree_map ( lambda initializer : ( initializer ( next_key ()) if isinstance ( initializer , types . Initializer ) else initializer ), self , is_leaf = lambda x : isinstance ( x , types . Initializer ), ) if inplace : # here we update initialized fields by the above tree_map tree_out = to . merge ( self , tree_out , inplace = True ) def call_module_init ( module : Module ): if isinstance ( module , Module ) and not module . _initialized : module . rng_init ( next_key ()) module . _initialized = True return to . apply ( call_module_init , tree_out , inplace = inplace ) logs ( self , * filters ) inherited Returns a copy of the Module with only tx.Log TreeParts, alias for filter(tx.Log) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/mlp.py def logs ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Log TreeParts, alias for `filter(tx.Log)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . Log , * filters ) losses ( self , * filters ) inherited Returns a copy of the Module with only tx.Loss TreeParts, alias for filter(tx.Loss) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/mlp.py def losses ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Loss TreeParts, alias for `filter(tx.Loss)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . LossLog , * filters ) map ( self , f , * filters , * , inplace = False , flatten_mode = None , is_leaf = None ) inherited map is a wrapper over treeo.map that passes self as the second argument. Parameters: Name Type Description Default f Callable The function to apply to the leaves. required *filters Filter The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treex/nn/mlp.py def map ( self : A , f : tp . Callable , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , is_leaf : tp . Callable [[ tp . Any ], bool ] = None , ) -> A : \"\"\" `map` is a wrapper over `treeo.map` that passes `self` as the second argument. Arguments: f: The function to apply to the leaves. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" return api . map ( f , self , * filters , inplace = inplace , flatten_mode = flatten_mode , is_leaf = is_leaf , ) merge ( self , other , * rest , * , inplace = False , flatten_mode = None , ignore_static = False ) inherited merge is a wrapper over treeo.merge that passes self as the first argument. Parameters: Name Type Description Default other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the merged values. If inplace is True , obj is returned. Source code in treex/nn/mlp.py def merge ( self : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" `merge` is a wrapper over `treeo.merge` that passes `self` as the first argument. Arguments: other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the merged values. If `inplace` is `True`, `obj` is returned. \"\"\" return api . merge ( self , other , * rest , inplace = inplace , flatten_mode = flatten_mode , ignore_static = ignore_static , ) metrics ( self , * filters ) inherited Returns a copy of the Module with only tx.Metric TreeParts, alias for filter(tx.Metric) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/mlp.py def metrics ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Metric TreeParts, alias for `filter(tx.Metric)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . MetricLog , * filters ) model_states ( self , * filters ) inherited Returns a copy of the Module with only tx.ModelState TreeParts, alias for filter(tx.ModelState) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/mlp.py def model_states ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.ModelState TreeParts, alias for `filter(tx.ModelState)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . ModelState , * filters ) parameters ( self , * filters ) inherited Returns a copy of the Module with only tx.Parameter TreeParts, alias for filter(tx.Parameter) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/mlp.py def parameters ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Parameter TreeParts, alias for `filter(tx.Parameter)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . Parameter , * filters ) rngs ( self , * filters ) inherited Returns a copy of the Module with only tx.Rng TreeParts, alias for filter(tx.Rng) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/mlp.py def rngs ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Rng TreeParts, alias for `filter(tx.Rng)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . Rng , * filters ) states ( self , * filters ) inherited Returns a copy of the Module with only tx.State TreeParts, alias for filter(tx.State) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/mlp.py def states ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.State TreeParts, alias for `filter(tx.State)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . State , * filters ) tabulate ( self , inputs = None , depth =- 1 , signature = False , param_types = True ) inherited Returns a tabular representation of the module. Parameters: Name Type Description Default depth int The maximum depth of the representation in terms of nested Modules, -1 means no limit. -1 signature bool Whether to show the signature of the Module. False param_types bool Whether to show the types of the parameters. True Returns: Type Description str A string containing the tabular representation. Source code in treex/nn/mlp.py def tabulate ( self , inputs : tp . Union [ tp . Any , types . Inputs , None ] = None , depth : int = - 1 , signature : bool = False , param_types : bool = True , ) -> str : \"\"\" Returns a tabular representation of the module. Arguments: depth: The maximum depth of the representation in terms of nested Modules, -1 means no limit. signature: Whether to show the signature of the Module. param_types: Whether to show the types of the parameters. Returns: A string containing the tabular representation. \"\"\" self = to . copy ( self ) if inputs is not None : if not isinstance ( inputs , types . Inputs ): inputs = types . Inputs ( inputs ) inputs = tp . cast ( types . Inputs , inputs ) if not isinstance ( self , tp . Callable ): raise TypeError ( \"`inputs` can only be specified if the module is a callable.\" ) with _Context ( call_info = {}): # call using self to preserve references def eval_call ( args , kwargs ): assert isinstance ( self , tp . Callable ) return self ( * args , ** kwargs ) jax . eval_shape ( eval_call , inputs . args , inputs . kwargs , ) call_info = _CONTEXT . call_info else : call_info = None with to . add_field_info (): flat : tp . List [ to . FieldInfo ] flat , _ = jax . tree_flatten ( self ) tree_part_types : tp . Tuple [ tp . Type [ types . TreePart ], ... ] = tuple ( { field_info . kind for field_info in flat if utils . _generic_issubclass ( field_info . kind , types . TreePart ) } ) path = () rows = list ( utils . _get_tabulate_rows ( path , self , depth , tree_part_types , signature , param_types ) ) modules = [ row [ 0 ] for row in rows ] rows = [ row [ 1 :] for row in rows ] if call_info is not None : for module , row in zip ( modules , rows ): if module in call_info : inputs , outputs = call_info [ module ] simplified_inputs = ( inputs . args [ 0 ] if len ( inputs . kwargs ) == 0 and len ( inputs . args ) == 1 else inputs . kwargs if len ( inputs . kwargs ) == 0 else inputs . kwargs if len ( inputs . args ) == 0 else ( inputs . args , inputs . kwargs ) ) inputs_repr = utils . _format_param_tree ( simplified_inputs ) outputs_repr = utils . _format_param_tree ( outputs ) else : inputs_repr = \"\" outputs_repr = \"\" row . insert ( 3 , outputs_repr ) row . insert ( 3 , inputs_repr ) n_non_treepart_cols = 2 if call_info is None else 4 rows [ 0 ][ 0 ] = \"*\" rows . append ( [ \"\" ] * n_non_treepart_cols + [ \"Total:\" ] + [ utils . _format_obj_size ( self . filter ( kind ), add_padding = True ) for kind in tree_part_types ] ) utils . _add_padding ( rows ) table = Table ( show_header = True , show_lines = True , show_footer = True , # box=rich.box.HORIZONTALS, ) table . add_column ( \"path\" ) table . add_column ( \"module\" ) table . add_column ( \"params\" ) if call_info is not None : table . add_column ( \"inputs\" ) table . add_column ( \"outputs\" ) for tree_part_type in tree_part_types : type_name = tree_part_type . __name__ if type_name . startswith ( \"_\" ): type_name = type_name [ 1 :] table . add_column ( type_name ) for row in rows [: - 1 ]: table . add_row ( * row ) table . columns [ n_non_treepart_cols ] . footer = Text . from_markup ( rows [ - 1 ][ n_non_treepart_cols ], justify = \"right\" ) for i in range ( len ( tree_part_types )): table . columns [ n_non_treepart_cols + 1 + i ] . footer = rows [ - 1 ][ n_non_treepart_cols + 1 + i ] table . caption_style = \"bold\" table . caption = \" \\n Total Parameters: \" + utils . _format_obj_size ( self , add_padding = False ) return utils . _get_rich_repr ( table ) to_dict ( self , * , private_fields = False , static_fields = True , type_info = False , field_info = False ) inherited to_dict is a wrapper over treeo.to_dict that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True type_info bool If True , type information is included. False field_info bool If True , field information is included. False Returns: Type Description Any A dict representation of the object. Source code in treex/nn/mlp.py def to_dict ( self , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : \"\"\" `to_dict` is a wrapper over `treeo.to_dict` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. type_info: If `True`, type information is included. field_info: If `True`, field information is included. Returns: A dict representation of the object. \"\"\" return api . to_dict ( self , private_fields = private_fields , static_fields = static_fields , type_info = type_info , field_info = field_info , ) to_string ( self , * , private_fields = False , static_fields = True , color = False ) inherited to_string is a wrapper over treeo.to_string that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True color bool If True , color is included. False Returns: Type Description str A string representation of the object. Source code in treex/nn/mlp.py def to_string ( self : A , * , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" `to_string` is a wrapper over `treeo.to_string` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. color: If `True`, color is included. Returns: A string representation of the object. \"\"\" return api . to_string ( self , private_fields = private_fields , static_fields = static_fields , color = color , ) train ( self , mode = True , inplace = False ) inherited Creates a new module with the same structure, but with Module.training set to the given value. Parameters: Name Type Description Default mode bool The new training mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~M The new module in with the training mode is set to the given value, if inplace is True then self is returned. Source code in treex/nn/mlp.py def train ( self : M , mode : bool = True , inplace : bool = False ) -> M : \"\"\" Creates a new module with the same structure, but with `Module.training` set to the given value. Arguments: mode: The new training mode. inplace: Whether to update the module inplace. Returns: The new module in with the training mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_training ( module : Module ): if isinstance ( module , Module ): module . _training = mode return to . apply ( set_training , self , inplace = inplace ) unfreeze ( self , inplace = False ) inherited Creates a new module with .frozen set to False, equivalent to calling freeze(False) . Parameters: Name Type Description Default inplace bool Whether to update the module inplace. False Returns: Type Description ~M The new module with .frozen set to False, if inplace is True then self is returned. Source code in treex/nn/mlp.py def unfreeze ( self : M , inplace : bool = False ) -> M : \"\"\" Creates a new module with `.frozen` set to False, equivalent to calling `freeze(False)`. Arguments: inplace: Whether to update the module inplace. Returns: The new module with `.frozen` set to False, if `inplace` is `True` then `self` is returned. \"\"\" return self . freeze ( False , inplace = inplace )","title":"MLP"},{"location":"api/MLP/#treexmlp","text":"A Multi-Layer Perceptron (MLP) that applies a sequence of linear layers with a given activation (relu by default), the last layer is linear.","title":"treex.MLP"},{"location":"api/MLP/#treex.nn.mlp.MLP.first_run","text":"Returns: Type Description bool True if its currently the first run of a compact method.","title":"first_run"},{"location":"api/MLP/#treex.nn.mlp.MLP.__class__","text":"","title":"__class__"},{"location":"api/MLP/#treex.nn.mlp.MLP.__class__.__base__","text":"Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()).","title":"__base__"},{"location":"api/MLP/#treex.nn.mlp.MLP.__class__.__base__.__instancecheck__","text":"Override for isinstance(instance, cls). Source code in treex/nn/mlp.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance )","title":"__instancecheck__()"},{"location":"api/MLP/#treex.nn.mlp.MLP.__class__.__base__.__new__","text":"Create and return a new object. See help(type) for accurate signature. Source code in treex/nn/mlp.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls","title":"__new__()"},{"location":"api/MLP/#treex.nn.mlp.MLP.__class__.__base__.__subclasscheck__","text":"Override for issubclass(subclass, cls). Source code in treex/nn/mlp.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass )","title":"__subclasscheck__()"},{"location":"api/MLP/#treex.nn.mlp.MLP.__class__.__base__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/mlp.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/MLP/#treex.nn.mlp.MLP.__class__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/mlp.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/MLP/#treex.nn.mlp.MLP.__call__","text":"Applies the MLP to the input. Parameters: Name Type Description Default x ndarray input array. required Returns: Type Description ndarray The output of the MLP. Source code in treex/nn/mlp.py def __call__ ( self , x : np . ndarray ) -> jnp . ndarray : \"\"\" Applies the MLP to the input. Arguments: x: input array. Returns: The output of the MLP. \"\"\" for layer in self . layers [: - 1 ]: x = self . activation ( layer ( x )) return self . layers [ - 1 ]( x )","title":"__call__()"},{"location":"api/MLP/#treex.nn.mlp.MLP.__init__","text":"Parameters: Name Type Description Default features Sequence[int] a sequence of L+1 integers, where L is the number of layers, the first integer is the number of input features and all subsequent integers are the number of output features of the respective layer. required activation Callable[[jax._src.numpy.lax_numpy.ndarray], jax._src.numpy.lax_numpy.ndarray] the activation function to use. <jax._src.custom_derivatives.custom_jvp object at 0x7fc07ed48130> use_bias bool whether to add a bias to the output (default: True). True dtype Any the dtype of the computation (default: float32). <class 'jax._src.numpy.lax_numpy.float32'> precision Any numerical precision of the computation see jax.lax.Precision for details. None kernel_init Callable[[Any, Iterable[int], Any], Any] initializer function for the weight matrix. <function variance_scaling.<locals>.init at 0x7fc075c2ed30> bias_init Callable[[Any, Iterable[int], Any], Any] initializer function for the bias. <function zeros at 0x7fc07ed80ca0> Source code in treex/nn/mlp.py def __init__ ( self , features : tp . Sequence [ int ], activation : tp . Callable [[ jnp . ndarray ], jnp . ndarray ] = jax . nn . relu , use_bias : bool = True , dtype : tp . Any = jnp . float32 , precision : tp . Any = None , kernel_init : tp . Callable [ [ flax_module . PRNGKey , flax_module . Shape , flax_module . Dtype ], flax_module . Array , ] = flax_module . default_kernel_init , bias_init : tp . Callable [ [ flax_module . PRNGKey , flax_module . Shape , flax_module . Dtype ], flax_module . Array , ] = flax_module . zeros , ): \"\"\" Arguments: features: a sequence of L+1 integers, where L is the number of layers, the first integer is the number of input features and all subsequent integers are the number of output features of the respective layer. activation: the activation function to use. use_bias: whether to add a bias to the output (default: True). dtype: the dtype of the computation (default: float32). precision: numerical precision of the computation see `jax.lax.Precision` for details. kernel_init: initializer function for the weight matrix. bias_init: initializer function for the bias. \"\"\" if len ( features ) < 2 : raise ValueError ( \"features must have at least 2 elements\" ) self . features = features self . activation = activation self . layers = [ Linear ( features_in = features_in , features_out = features_out , use_bias = use_bias , dtype = dtype , precision = precision , kernel_init = kernel_init , bias_init = bias_init , ) for features_in , features_out in zip ( features [: - 1 ], features [ 1 :]) ]","title":"__init__()"},{"location":"api/MLP/#treex.nn.mlp.MLP.apply","text":"apply is a wrapper over treeo.apply that passes self as the second argument. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treex/nn/mlp.py def apply ( self : A , f : tp . Callable [ ... , None ], * rest : A , inplace : bool = False ) -> A : \"\"\" `apply` is a wrapper over `treeo.apply` that passes `self` as the second argument. Arguments: f: The function to apply. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" return api . apply ( f , self , * rest , inplace = inplace )","title":"apply()"},{"location":"api/MLP/#treex.nn.mlp.MLP.batch_stats","text":"Returns a copy of the Module with only tx.BatchStat TreeParts, alias for filter(tx.BatchStat) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/mlp.py def batch_stats ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.BatchStat TreeParts, alias for `filter(tx.BatchStat)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . BatchStat , * filters )","title":"batch_stats()"},{"location":"api/MLP/#treex.nn.mlp.MLP.check_metadata_updates","text":"Checks for new fields, if found, adds them to the metadata. Source code in treex/nn/mlp.py def check_metadata_updates ( self ): \"\"\" Checks for new fields, if found, adds them to the metadata. \"\"\" with _CONTEXT . update ( flatten_mode = FlattenMode . all_fields ): jax . tree_flatten ( self )","title":"check_metadata_updates()"},{"location":"api/MLP/#treex.nn.mlp.MLP.copy","text":"copy is a wrapper over treeo.copy that passes self as the first argument. Source code in treex/nn/mlp.py def copy ( self : A ) -> A : \"\"\" `copy` is a wrapper over `treeo.copy` that passes `self` as the first argument. \"\"\" return tree_m . copy ( self )","title":"copy()"},{"location":"api/MLP/#treex.nn.mlp.MLP.eval","text":"Creates a new module with the training mode set to False, equivalent to calling train(False) . Returns: Type Description ~M The new module with the training mode set to False. Source code in treex/nn/mlp.py def eval ( self : M , inplace : bool = False ) -> M : \"\"\" Creates a new module with the training mode set to False, equivalent to calling `train(False)`. Returns: The new module with the training mode set to False. \"\"\" return self . train ( False , inplace = inplace )","title":"eval()"},{"location":"api/MLP/#treex.nn.mlp.MLP.filter","text":"filter is a wrapper over treeo.filter that passes self as the first argument. Parameters: Name Type Description Default *filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treex/nn/mlp.py def filter ( self : A , * filters : api . Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ) -> A : \"\"\" `filter` is a wrapper over `treeo.filter` that passes `self` as the first argument. Arguments: *filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" return api . filter ( self , * filters , inplace = inplace , flatten_mode = flatten_mode )","title":"filter()"},{"location":"api/MLP/#treex.nn.mlp.MLP.freeze","text":"Creates a new module with the same structure, but with Module.frozen set to the given value. Parameters: Name Type Description Default mode bool The new frozen mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~M The new module in with the frozen mode is set to the given value, if inplace is True then self is returned. Source code in treex/nn/mlp.py def freeze ( self : M , mode : bool = True , inplace : bool = False ) -> M : \"\"\" Creates a new module with the same structure, but with `Module.frozen` set to the given value. Arguments: mode: The new `frozen` mode. inplace: Whether to update the module inplace. Returns: The new module in with the `frozen` mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_frozen ( module : Module ): if isinstance ( module , Module ): module . _frozen = mode return to . apply ( set_frozen , self , inplace = inplace )","title":"freeze()"},{"location":"api/MLP/#treex.nn.mlp.MLP.get_field","text":"A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: The field must be declared in the class definition. The method can only be called inside a compact context. Parameters: Name Type Description Default field_name str The name of the field to get. required initializer Callable[[], ~A] The function to initialize the field if it does not exist. required Returns: Type Description ~A The field value. Source code in treex/nn/mlp.py def get_field ( self , field_name : str , initializer : tp . Callable [[], A ], ) -> A : \"\"\" A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: * The field must be declared in the class definition. * The method can only be called inside a `compact` context. Arguments: field_name: The name of the field to get. initializer: The function to initialize the field if it does not exist. Returns: The field value. \"\"\" value : A if field_name not in self . _field_metadata : raise ValueError ( f \"Metadata for field ' { field_name } ' does not exist.\" ) if tree_m . _COMPACT_CONTEXT . current_tree is not self : raise RuntimeError ( f \"Object ' { type ( self ) . __name__ } ' is not the current tree, found ' { type ( tree_m . _COMPACT_CONTEXT . current_tree ) . __name__ } ', did you forget the @compact decorator?\" ) if field_name in vars ( self ): value = getattr ( self , field_name ) else : if tree_m . _COMPACT_CONTEXT . in_compact and not self . first_run : raise RuntimeError ( f \"Trying to initialize field ' { field_name } ' after the first run of `compact`.\" ) value = initializer () setattr ( self , field_name , value ) return value","title":"get_field()"},{"location":"api/MLP/#treex.nn.mlp.MLP.init","text":"Method version of tx.init , it applies self as first argument. init creates a new module with the same structure, but with its fields initialized given a seed key . The following procedure is used: The input key is split and iteratively updated before passing a derived value to any process that requires initialization. Initializer s are called and applied to the module first. Module.rng_init methods are called last. Parameters: Name Type Description Default key Union[int, jax._src.numpy.lax_numpy.ndarray] The seed to use for initialization. required Returns: Type Description ~M The new module with the fields initialized. Source code in treex/nn/mlp.py def init ( self : M , key : tp . Union [ int , jnp . ndarray ], inplace : bool = False ) -> M : \"\"\" Method version of `tx.init`, it applies `self` as first argument. `init` creates a new module with the same structure, but with its fields initialized given a seed `key`. The following procedure is used: 1. The input `key` is split and iteratively updated before passing a derived value to any process that requires initialization. 2. `Initializer`s are called and applied to the module first. 3. `Module.rng_init` methods are called last. Arguments: key: The seed to use for initialization. Returns: The new module with the fields initialized. \"\"\" if isinstance ( key , int ): key = jax . random . PRNGKey ( key ) def next_key () -> jnp . ndarray : nonlocal key assert isinstance ( key , ( np . ndarray , jnp . ndarray )) next_key , key = utils . iter_split ( key ) return next_key tree_out : M = jax . tree_map ( lambda initializer : ( initializer ( next_key ()) if isinstance ( initializer , types . Initializer ) else initializer ), self , is_leaf = lambda x : isinstance ( x , types . Initializer ), ) if inplace : # here we update initialized fields by the above tree_map tree_out = to . merge ( self , tree_out , inplace = True ) def call_module_init ( module : Module ): if isinstance ( module , Module ) and not module . _initialized : module . rng_init ( next_key ()) module . _initialized = True return to . apply ( call_module_init , tree_out , inplace = inplace )","title":"init()"},{"location":"api/MLP/#treex.nn.mlp.MLP.logs","text":"Returns a copy of the Module with only tx.Log TreeParts, alias for filter(tx.Log) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/mlp.py def logs ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Log TreeParts, alias for `filter(tx.Log)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . Log , * filters )","title":"logs()"},{"location":"api/MLP/#treex.nn.mlp.MLP.losses","text":"Returns a copy of the Module with only tx.Loss TreeParts, alias for filter(tx.Loss) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/mlp.py def losses ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Loss TreeParts, alias for `filter(tx.Loss)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . LossLog , * filters )","title":"losses()"},{"location":"api/MLP/#treex.nn.mlp.MLP.map","text":"map is a wrapper over treeo.map that passes self as the second argument. Parameters: Name Type Description Default f Callable The function to apply to the leaves. required *filters Filter The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treex/nn/mlp.py def map ( self : A , f : tp . Callable , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , is_leaf : tp . Callable [[ tp . Any ], bool ] = None , ) -> A : \"\"\" `map` is a wrapper over `treeo.map` that passes `self` as the second argument. Arguments: f: The function to apply to the leaves. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" return api . map ( f , self , * filters , inplace = inplace , flatten_mode = flatten_mode , is_leaf = is_leaf , )","title":"map()"},{"location":"api/MLP/#treex.nn.mlp.MLP.merge","text":"merge is a wrapper over treeo.merge that passes self as the first argument. Parameters: Name Type Description Default other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the merged values. If inplace is True , obj is returned. Source code in treex/nn/mlp.py def merge ( self : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" `merge` is a wrapper over `treeo.merge` that passes `self` as the first argument. Arguments: other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the merged values. If `inplace` is `True`, `obj` is returned. \"\"\" return api . merge ( self , other , * rest , inplace = inplace , flatten_mode = flatten_mode , ignore_static = ignore_static , )","title":"merge()"},{"location":"api/MLP/#treex.nn.mlp.MLP.metrics","text":"Returns a copy of the Module with only tx.Metric TreeParts, alias for filter(tx.Metric) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/mlp.py def metrics ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Metric TreeParts, alias for `filter(tx.Metric)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . MetricLog , * filters )","title":"metrics()"},{"location":"api/MLP/#treex.nn.mlp.MLP.model_states","text":"Returns a copy of the Module with only tx.ModelState TreeParts, alias for filter(tx.ModelState) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/mlp.py def model_states ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.ModelState TreeParts, alias for `filter(tx.ModelState)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . ModelState , * filters )","title":"model_states()"},{"location":"api/MLP/#treex.nn.mlp.MLP.parameters","text":"Returns a copy of the Module with only tx.Parameter TreeParts, alias for filter(tx.Parameter) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/mlp.py def parameters ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Parameter TreeParts, alias for `filter(tx.Parameter)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . Parameter , * filters )","title":"parameters()"},{"location":"api/MLP/#treex.nn.mlp.MLP.rngs","text":"Returns a copy of the Module with only tx.Rng TreeParts, alias for filter(tx.Rng) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/mlp.py def rngs ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Rng TreeParts, alias for `filter(tx.Rng)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . Rng , * filters )","title":"rngs()"},{"location":"api/MLP/#treex.nn.mlp.MLP.states","text":"Returns a copy of the Module with only tx.State TreeParts, alias for filter(tx.State) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/mlp.py def states ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.State TreeParts, alias for `filter(tx.State)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . State , * filters )","title":"states()"},{"location":"api/MLP/#treex.nn.mlp.MLP.tabulate","text":"Returns a tabular representation of the module. Parameters: Name Type Description Default depth int The maximum depth of the representation in terms of nested Modules, -1 means no limit. -1 signature bool Whether to show the signature of the Module. False param_types bool Whether to show the types of the parameters. True Returns: Type Description str A string containing the tabular representation. Source code in treex/nn/mlp.py def tabulate ( self , inputs : tp . Union [ tp . Any , types . Inputs , None ] = None , depth : int = - 1 , signature : bool = False , param_types : bool = True , ) -> str : \"\"\" Returns a tabular representation of the module. Arguments: depth: The maximum depth of the representation in terms of nested Modules, -1 means no limit. signature: Whether to show the signature of the Module. param_types: Whether to show the types of the parameters. Returns: A string containing the tabular representation. \"\"\" self = to . copy ( self ) if inputs is not None : if not isinstance ( inputs , types . Inputs ): inputs = types . Inputs ( inputs ) inputs = tp . cast ( types . Inputs , inputs ) if not isinstance ( self , tp . Callable ): raise TypeError ( \"`inputs` can only be specified if the module is a callable.\" ) with _Context ( call_info = {}): # call using self to preserve references def eval_call ( args , kwargs ): assert isinstance ( self , tp . Callable ) return self ( * args , ** kwargs ) jax . eval_shape ( eval_call , inputs . args , inputs . kwargs , ) call_info = _CONTEXT . call_info else : call_info = None with to . add_field_info (): flat : tp . List [ to . FieldInfo ] flat , _ = jax . tree_flatten ( self ) tree_part_types : tp . Tuple [ tp . Type [ types . TreePart ], ... ] = tuple ( { field_info . kind for field_info in flat if utils . _generic_issubclass ( field_info . kind , types . TreePart ) } ) path = () rows = list ( utils . _get_tabulate_rows ( path , self , depth , tree_part_types , signature , param_types ) ) modules = [ row [ 0 ] for row in rows ] rows = [ row [ 1 :] for row in rows ] if call_info is not None : for module , row in zip ( modules , rows ): if module in call_info : inputs , outputs = call_info [ module ] simplified_inputs = ( inputs . args [ 0 ] if len ( inputs . kwargs ) == 0 and len ( inputs . args ) == 1 else inputs . kwargs if len ( inputs . kwargs ) == 0 else inputs . kwargs if len ( inputs . args ) == 0 else ( inputs . args , inputs . kwargs ) ) inputs_repr = utils . _format_param_tree ( simplified_inputs ) outputs_repr = utils . _format_param_tree ( outputs ) else : inputs_repr = \"\" outputs_repr = \"\" row . insert ( 3 , outputs_repr ) row . insert ( 3 , inputs_repr ) n_non_treepart_cols = 2 if call_info is None else 4 rows [ 0 ][ 0 ] = \"*\" rows . append ( [ \"\" ] * n_non_treepart_cols + [ \"Total:\" ] + [ utils . _format_obj_size ( self . filter ( kind ), add_padding = True ) for kind in tree_part_types ] ) utils . _add_padding ( rows ) table = Table ( show_header = True , show_lines = True , show_footer = True , # box=rich.box.HORIZONTALS, ) table . add_column ( \"path\" ) table . add_column ( \"module\" ) table . add_column ( \"params\" ) if call_info is not None : table . add_column ( \"inputs\" ) table . add_column ( \"outputs\" ) for tree_part_type in tree_part_types : type_name = tree_part_type . __name__ if type_name . startswith ( \"_\" ): type_name = type_name [ 1 :] table . add_column ( type_name ) for row in rows [: - 1 ]: table . add_row ( * row ) table . columns [ n_non_treepart_cols ] . footer = Text . from_markup ( rows [ - 1 ][ n_non_treepart_cols ], justify = \"right\" ) for i in range ( len ( tree_part_types )): table . columns [ n_non_treepart_cols + 1 + i ] . footer = rows [ - 1 ][ n_non_treepart_cols + 1 + i ] table . caption_style = \"bold\" table . caption = \" \\n Total Parameters: \" + utils . _format_obj_size ( self , add_padding = False ) return utils . _get_rich_repr ( table )","title":"tabulate()"},{"location":"api/MLP/#treex.nn.mlp.MLP.to_dict","text":"to_dict is a wrapper over treeo.to_dict that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True type_info bool If True , type information is included. False field_info bool If True , field information is included. False Returns: Type Description Any A dict representation of the object. Source code in treex/nn/mlp.py def to_dict ( self , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : \"\"\" `to_dict` is a wrapper over `treeo.to_dict` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. type_info: If `True`, type information is included. field_info: If `True`, field information is included. Returns: A dict representation of the object. \"\"\" return api . to_dict ( self , private_fields = private_fields , static_fields = static_fields , type_info = type_info , field_info = field_info , )","title":"to_dict()"},{"location":"api/MLP/#treex.nn.mlp.MLP.to_string","text":"to_string is a wrapper over treeo.to_string that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True color bool If True , color is included. False Returns: Type Description str A string representation of the object. Source code in treex/nn/mlp.py def to_string ( self : A , * , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" `to_string` is a wrapper over `treeo.to_string` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. color: If `True`, color is included. Returns: A string representation of the object. \"\"\" return api . to_string ( self , private_fields = private_fields , static_fields = static_fields , color = color , )","title":"to_string()"},{"location":"api/MLP/#treex.nn.mlp.MLP.train","text":"Creates a new module with the same structure, but with Module.training set to the given value. Parameters: Name Type Description Default mode bool The new training mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~M The new module in with the training mode is set to the given value, if inplace is True then self is returned. Source code in treex/nn/mlp.py def train ( self : M , mode : bool = True , inplace : bool = False ) -> M : \"\"\" Creates a new module with the same structure, but with `Module.training` set to the given value. Arguments: mode: The new training mode. inplace: Whether to update the module inplace. Returns: The new module in with the training mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_training ( module : Module ): if isinstance ( module , Module ): module . _training = mode return to . apply ( set_training , self , inplace = inplace )","title":"train()"},{"location":"api/MLP/#treex.nn.mlp.MLP.unfreeze","text":"Creates a new module with .frozen set to False, equivalent to calling freeze(False) . Parameters: Name Type Description Default inplace bool Whether to update the module inplace. False Returns: Type Description ~M The new module with .frozen set to False, if inplace is True then self is returned. Source code in treex/nn/mlp.py def unfreeze ( self : M , inplace : bool = False ) -> M : \"\"\" Creates a new module with `.frozen` set to False, equivalent to calling `freeze(False)`. Arguments: inplace: Whether to update the module inplace. Returns: The new module with `.frozen` set to False, if `inplace` is `True` then `self` is returned. \"\"\" return self . freeze ( False , inplace = inplace )","title":"unfreeze()"},{"location":"api/Map/","text":"treex.Map Mixin that adds a .map() method to the class. map ( self , f , * filters , * , inplace = False , flatten_mode = None , is_leaf = None ) map is a wrapper over treeo.map that passes self as the second argument. Parameters: Name Type Description Default f Callable The function to apply to the leaves. required *filters Filter The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treeo/mixins.py def map ( self : A , f : tp . Callable , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , is_leaf : tp . Callable [[ tp . Any ], bool ] = None , ) -> A : \"\"\" `map` is a wrapper over `treeo.map` that passes `self` as the second argument. Arguments: f: The function to apply to the leaves. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" return api . map ( f , self , * filters , inplace = inplace , flatten_mode = flatten_mode , is_leaf = is_leaf , )","title":"Map"},{"location":"api/Map/#treexmap","text":"Mixin that adds a .map() method to the class.","title":"treex.Map"},{"location":"api/Map/#treeo.mixins.Map.map","text":"map is a wrapper over treeo.map that passes self as the second argument. Parameters: Name Type Description Default f Callable The function to apply to the leaves. required *filters Filter The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treeo/mixins.py def map ( self : A , f : tp . Callable , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , is_leaf : tp . Callable [[ tp . Any ], bool ] = None , ) -> A : \"\"\" `map` is a wrapper over `treeo.map` that passes `self` as the second argument. Arguments: f: The function to apply to the leaves. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" return api . map ( f , self , * filters , inplace = inplace , flatten_mode = flatten_mode , is_leaf = is_leaf , )","title":"map()"},{"location":"api/Merge/","text":"treex.Merge Mixin that adds a .merge() method to the class. merge ( self , other , * rest , * , inplace = False , flatten_mode = None , ignore_static = False ) merge is a wrapper over treeo.merge that passes self as the first argument. Parameters: Name Type Description Default other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the merged values. If inplace is True , obj is returned. Source code in treeo/mixins.py def merge ( self : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" `merge` is a wrapper over `treeo.merge` that passes `self` as the first argument. Arguments: other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the merged values. If `inplace` is `True`, `obj` is returned. \"\"\" return api . merge ( self , other , * rest , inplace = inplace , flatten_mode = flatten_mode , ignore_static = ignore_static , )","title":"Merge"},{"location":"api/Merge/#treexmerge","text":"Mixin that adds a .merge() method to the class.","title":"treex.Merge"},{"location":"api/Merge/#treeo.mixins.Merge.merge","text":"merge is a wrapper over treeo.merge that passes self as the first argument. Parameters: Name Type Description Default other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the merged values. If inplace is True , obj is returned. Source code in treeo/mixins.py def merge ( self : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" `merge` is a wrapper over `treeo.merge` that passes `self` as the first argument. Arguments: other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the merged values. If `inplace` is `True`, `obj` is returned. \"\"\" return api . merge ( self , other , * rest , inplace = inplace , flatten_mode = flatten_mode , ignore_static = ignore_static , )","title":"merge()"},{"location":"api/Metric/","text":"treex.Metric Encapsulates metric logic and state. Metrics accumulate state between calls such that their output value reflect the metric as if calculated on the whole data given up to that point. first_run : bool inherited property readonly Returns: Type Description bool True if its currently the first run of a compact method. __class__ inherited __base__ inherited __base__ inherited Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()). __instancecheck__ ( cls , instance ) special Override for isinstance(instance, cls). Source code in treex/metrics/metric.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance ) __new__ ( mcls , name , bases , namespace , ** kwargs ) special staticmethod Create and return a new object. See help(type) for accurate signature. Source code in treex/metrics/metric.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls __subclasscheck__ ( cls , subclass ) special Override for issubclass(subclass, cls). Source code in treex/metrics/metric.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass ) register ( cls , subclass ) Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/metrics/metric.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) register ( cls , subclass ) inherited Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/metrics/metric.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) register ( cls , subclass ) inherited Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/metrics/metric.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) __init__ ( self , on = None , name = None , dtype = None ) special Parameters: Name Type Description Default on Union[str, int, Sequence[Union[str, int]]] A string or integer, or iterable of string or integers, that indicate how to index/filter the y_true and y_pred arguments before passing them to call . For example if on = \"a\" then y_true = y_true[\"a\"] . If on is an iterable the structures will be indexed iteratively, for example if on = [\"a\", 0, \"b\"] then y_true = y_true[\"a\"][0][\"b\"] , same for y_pred . For more information check out Keras-like behavior . None Source code in treex/metrics/metric.py def __init__ ( self , on : tp . Optional [ types . IndexLike ] = None , name : tp . Optional [ str ] = None , dtype : tp . Optional [ jnp . dtype ] = None , ): \"\"\" Arguments: on: A string or integer, or iterable of string or integers, that indicate how to index/filter the `y_true` and `y_pred` arguments before passing them to `call`. For example if `on = \"a\"` then `y_true = y_true[\"a\"]`. If `on` is an iterable the structures will be indexed iteratively, for example if `on = [\"a\", 0, \"b\"]` then `y_true = y_true[\"a\"][0][\"b\"]`, same for `y_pred`. For more information check out [Keras-like behavior](https://poets-ai.github.io/elegy/guides/modules-losses-metrics/#keras-like-behavior). \"\"\" self . _labels_filter = ( on ,) if isinstance ( on , ( str , int )) else on self . name = name if name is not None else utils . _get_name ( self ) self . dtype = dtype if dtype is not None else jnp . float32 __init_subclass__ () classmethod special This method is called when a class is subclassed. The default implementation does nothing. It may be overridden to extend subclasses. Source code in treex/metrics/metric.py def __init_subclass__ ( cls ): super () . __init_subclass__ () # add call signature old_call = cls . __call__ @functools . wraps ( cls . update ) def new_call ( self : M , * args , ** kwargs ) -> M : if len ( args ) > 0 : raise TypeError ( f \"All arguments to { cls . __name__ } .__call__ should be passed as keyword arguments.\" ) return old_call ( self , * args , ** kwargs ) cls . __call__ = new_call apply ( self , f , * rest , * , inplace = False ) inherited apply is a wrapper over treeo.apply that passes self as the second argument. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treex/metrics/metric.py def apply ( self : A , f : tp . Callable [ ... , None ], * rest : A , inplace : bool = False ) -> A : \"\"\" `apply` is a wrapper over `treeo.apply` that passes `self` as the second argument. Arguments: f: The function to apply. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" return api . apply ( f , self , * rest , inplace = inplace ) check_metadata_updates ( self ) inherited Checks for new fields, if found, adds them to the metadata. Source code in treex/metrics/metric.py def check_metadata_updates ( self ): \"\"\" Checks for new fields, if found, adds them to the metadata. \"\"\" with _CONTEXT . update ( flatten_mode = FlattenMode . all_fields ): jax . tree_flatten ( self ) copy ( self ) inherited copy is a wrapper over treeo.copy that passes self as the first argument. Source code in treex/metrics/metric.py def copy ( self : A ) -> A : \"\"\" `copy` is a wrapper over `treeo.copy` that passes `self` as the first argument. \"\"\" return tree_m . copy ( self ) filter ( self , * filters , * , inplace = False , flatten_mode = None ) inherited filter is a wrapper over treeo.filter that passes self as the first argument. Parameters: Name Type Description Default *filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treex/metrics/metric.py def filter ( self : A , * filters : api . Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ) -> A : \"\"\" `filter` is a wrapper over `treeo.filter` that passes `self` as the first argument. Arguments: *filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" return api . filter ( self , * filters , inplace = inplace , flatten_mode = flatten_mode ) get_field ( self , field_name , initializer ) inherited A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: The field must be declared in the class definition. The method can only be called inside a compact context. Parameters: Name Type Description Default field_name str The name of the field to get. required initializer Callable[[], ~A] The function to initialize the field if it does not exist. required Returns: Type Description ~A The field value. Source code in treex/metrics/metric.py def get_field ( self , field_name : str , initializer : tp . Callable [[], A ], ) -> A : \"\"\" A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: * The field must be declared in the class definition. * The method can only be called inside a `compact` context. Arguments: field_name: The name of the field to get. initializer: The function to initialize the field if it does not exist. Returns: The field value. \"\"\" value : A if field_name not in self . _field_metadata : raise ValueError ( f \"Metadata for field ' { field_name } ' does not exist.\" ) if tree_m . _COMPACT_CONTEXT . current_tree is not self : raise RuntimeError ( f \"Object ' { type ( self ) . __name__ } ' is not the current tree, found ' { type ( tree_m . _COMPACT_CONTEXT . current_tree ) . __name__ } ', did you forget the @compact decorator?\" ) if field_name in vars ( self ): value = getattr ( self , field_name ) else : if tree_m . _COMPACT_CONTEXT . in_compact and not self . first_run : raise RuntimeError ( f \"Trying to initialize field ' { field_name } ' after the first run of `compact`.\" ) value = initializer () setattr ( self , field_name , value ) return value map ( self , f , * filters , * , inplace = False , flatten_mode = None , is_leaf = None ) inherited map is a wrapper over treeo.map that passes self as the second argument. Parameters: Name Type Description Default f Callable The function to apply to the leaves. required *filters Filter The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treex/metrics/metric.py def map ( self : A , f : tp . Callable , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , is_leaf : tp . Callable [[ tp . Any ], bool ] = None , ) -> A : \"\"\" `map` is a wrapper over `treeo.map` that passes `self` as the second argument. Arguments: f: The function to apply to the leaves. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" return api . map ( f , self , * filters , inplace = inplace , flatten_mode = flatten_mode , is_leaf = is_leaf , ) merge ( self , other , * rest , * , inplace = False , flatten_mode = None , ignore_static = False ) inherited merge is a wrapper over treeo.merge that passes self as the first argument. Parameters: Name Type Description Default other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the merged values. If inplace is True , obj is returned. Source code in treex/metrics/metric.py def merge ( self : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" `merge` is a wrapper over `treeo.merge` that passes `self` as the first argument. Arguments: other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the merged values. If `inplace` is `True`, `obj` is returned. \"\"\" return api . merge ( self , other , * rest , inplace = inplace , flatten_mode = flatten_mode , ignore_static = ignore_static , ) to_dict ( self , * , private_fields = False , static_fields = True , type_info = False , field_info = False ) inherited to_dict is a wrapper over treeo.to_dict that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True type_info bool If True , type information is included. False field_info bool If True , field information is included. False Returns: Type Description Any A dict representation of the object. Source code in treex/metrics/metric.py def to_dict ( self , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : \"\"\" `to_dict` is a wrapper over `treeo.to_dict` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. type_info: If `True`, type information is included. field_info: If `True`, field information is included. Returns: A dict representation of the object. \"\"\" return api . to_dict ( self , private_fields = private_fields , static_fields = static_fields , type_info = type_info , field_info = field_info , ) to_string ( self , * , private_fields = False , static_fields = True , color = False ) inherited to_string is a wrapper over treeo.to_string that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True color bool If True , color is included. False Returns: Type Description str A string representation of the object. Source code in treex/metrics/metric.py def to_string ( self : A , * , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" `to_string` is a wrapper over `treeo.to_string` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. color: If `True`, color is included. Returns: A string representation of the object. \"\"\" return api . to_string ( self , private_fields = private_fields , static_fields = static_fields , color = color , )","title":"Metric"},{"location":"api/Metric/#treexmetric","text":"Encapsulates metric logic and state. Metrics accumulate state between calls such that their output value reflect the metric as if calculated on the whole data given up to that point.","title":"treex.Metric"},{"location":"api/Metric/#treex.metrics.metric.Metric.first_run","text":"Returns: Type Description bool True if its currently the first run of a compact method.","title":"first_run"},{"location":"api/Metric/#treex.metrics.metric.Metric.__class__","text":"","title":"__class__"},{"location":"api/Metric/#treex.metrics.metric.Metric.__class__.__base__","text":"","title":"__base__"},{"location":"api/Metric/#treex.metrics.metric.Metric.__class__.__base__.__base__","text":"Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()).","title":"__base__"},{"location":"api/Metric/#treex.metrics.metric.Metric.__class__.__base__.__base__.__instancecheck__","text":"Override for isinstance(instance, cls). Source code in treex/metrics/metric.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance )","title":"__instancecheck__()"},{"location":"api/Metric/#treex.metrics.metric.Metric.__class__.__base__.__base__.__new__","text":"Create and return a new object. See help(type) for accurate signature. Source code in treex/metrics/metric.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls","title":"__new__()"},{"location":"api/Metric/#treex.metrics.metric.Metric.__class__.__base__.__base__.__subclasscheck__","text":"Override for issubclass(subclass, cls). Source code in treex/metrics/metric.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass )","title":"__subclasscheck__()"},{"location":"api/Metric/#treex.metrics.metric.Metric.__class__.__base__.__base__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/metrics/metric.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/Metric/#treex.metrics.metric.Metric.__class__.__base__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/metrics/metric.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/Metric/#treex.metrics.metric.Metric.__class__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/metrics/metric.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/Metric/#treex.metrics.metric.Metric.__init__","text":"Parameters: Name Type Description Default on Union[str, int, Sequence[Union[str, int]]] A string or integer, or iterable of string or integers, that indicate how to index/filter the y_true and y_pred arguments before passing them to call . For example if on = \"a\" then y_true = y_true[\"a\"] . If on is an iterable the structures will be indexed iteratively, for example if on = [\"a\", 0, \"b\"] then y_true = y_true[\"a\"][0][\"b\"] , same for y_pred . For more information check out Keras-like behavior . None Source code in treex/metrics/metric.py def __init__ ( self , on : tp . Optional [ types . IndexLike ] = None , name : tp . Optional [ str ] = None , dtype : tp . Optional [ jnp . dtype ] = None , ): \"\"\" Arguments: on: A string or integer, or iterable of string or integers, that indicate how to index/filter the `y_true` and `y_pred` arguments before passing them to `call`. For example if `on = \"a\"` then `y_true = y_true[\"a\"]`. If `on` is an iterable the structures will be indexed iteratively, for example if `on = [\"a\", 0, \"b\"]` then `y_true = y_true[\"a\"][0][\"b\"]`, same for `y_pred`. For more information check out [Keras-like behavior](https://poets-ai.github.io/elegy/guides/modules-losses-metrics/#keras-like-behavior). \"\"\" self . _labels_filter = ( on ,) if isinstance ( on , ( str , int )) else on self . name = name if name is not None else utils . _get_name ( self ) self . dtype = dtype if dtype is not None else jnp . float32","title":"__init__()"},{"location":"api/Metric/#treex.metrics.metric.Metric.__init_subclass__","text":"This method is called when a class is subclassed. The default implementation does nothing. It may be overridden to extend subclasses. Source code in treex/metrics/metric.py def __init_subclass__ ( cls ): super () . __init_subclass__ () # add call signature old_call = cls . __call__ @functools . wraps ( cls . update ) def new_call ( self : M , * args , ** kwargs ) -> M : if len ( args ) > 0 : raise TypeError ( f \"All arguments to { cls . __name__ } .__call__ should be passed as keyword arguments.\" ) return old_call ( self , * args , ** kwargs ) cls . __call__ = new_call","title":"__init_subclass__()"},{"location":"api/Metric/#treex.metrics.metric.Metric.apply","text":"apply is a wrapper over treeo.apply that passes self as the second argument. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treex/metrics/metric.py def apply ( self : A , f : tp . Callable [ ... , None ], * rest : A , inplace : bool = False ) -> A : \"\"\" `apply` is a wrapper over `treeo.apply` that passes `self` as the second argument. Arguments: f: The function to apply. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" return api . apply ( f , self , * rest , inplace = inplace )","title":"apply()"},{"location":"api/Metric/#treex.metrics.metric.Metric.check_metadata_updates","text":"Checks for new fields, if found, adds them to the metadata. Source code in treex/metrics/metric.py def check_metadata_updates ( self ): \"\"\" Checks for new fields, if found, adds them to the metadata. \"\"\" with _CONTEXT . update ( flatten_mode = FlattenMode . all_fields ): jax . tree_flatten ( self )","title":"check_metadata_updates()"},{"location":"api/Metric/#treex.metrics.metric.Metric.copy","text":"copy is a wrapper over treeo.copy that passes self as the first argument. Source code in treex/metrics/metric.py def copy ( self : A ) -> A : \"\"\" `copy` is a wrapper over `treeo.copy` that passes `self` as the first argument. \"\"\" return tree_m . copy ( self )","title":"copy()"},{"location":"api/Metric/#treex.metrics.metric.Metric.filter","text":"filter is a wrapper over treeo.filter that passes self as the first argument. Parameters: Name Type Description Default *filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treex/metrics/metric.py def filter ( self : A , * filters : api . Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ) -> A : \"\"\" `filter` is a wrapper over `treeo.filter` that passes `self` as the first argument. Arguments: *filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" return api . filter ( self , * filters , inplace = inplace , flatten_mode = flatten_mode )","title":"filter()"},{"location":"api/Metric/#treex.metrics.metric.Metric.get_field","text":"A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: The field must be declared in the class definition. The method can only be called inside a compact context. Parameters: Name Type Description Default field_name str The name of the field to get. required initializer Callable[[], ~A] The function to initialize the field if it does not exist. required Returns: Type Description ~A The field value. Source code in treex/metrics/metric.py def get_field ( self , field_name : str , initializer : tp . Callable [[], A ], ) -> A : \"\"\" A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: * The field must be declared in the class definition. * The method can only be called inside a `compact` context. Arguments: field_name: The name of the field to get. initializer: The function to initialize the field if it does not exist. Returns: The field value. \"\"\" value : A if field_name not in self . _field_metadata : raise ValueError ( f \"Metadata for field ' { field_name } ' does not exist.\" ) if tree_m . _COMPACT_CONTEXT . current_tree is not self : raise RuntimeError ( f \"Object ' { type ( self ) . __name__ } ' is not the current tree, found ' { type ( tree_m . _COMPACT_CONTEXT . current_tree ) . __name__ } ', did you forget the @compact decorator?\" ) if field_name in vars ( self ): value = getattr ( self , field_name ) else : if tree_m . _COMPACT_CONTEXT . in_compact and not self . first_run : raise RuntimeError ( f \"Trying to initialize field ' { field_name } ' after the first run of `compact`.\" ) value = initializer () setattr ( self , field_name , value ) return value","title":"get_field()"},{"location":"api/Metric/#treex.metrics.metric.Metric.map","text":"map is a wrapper over treeo.map that passes self as the second argument. Parameters: Name Type Description Default f Callable The function to apply to the leaves. required *filters Filter The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treex/metrics/metric.py def map ( self : A , f : tp . Callable , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , is_leaf : tp . Callable [[ tp . Any ], bool ] = None , ) -> A : \"\"\" `map` is a wrapper over `treeo.map` that passes `self` as the second argument. Arguments: f: The function to apply to the leaves. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" return api . map ( f , self , * filters , inplace = inplace , flatten_mode = flatten_mode , is_leaf = is_leaf , )","title":"map()"},{"location":"api/Metric/#treex.metrics.metric.Metric.merge","text":"merge is a wrapper over treeo.merge that passes self as the first argument. Parameters: Name Type Description Default other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the merged values. If inplace is True , obj is returned. Source code in treex/metrics/metric.py def merge ( self : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" `merge` is a wrapper over `treeo.merge` that passes `self` as the first argument. Arguments: other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the merged values. If `inplace` is `True`, `obj` is returned. \"\"\" return api . merge ( self , other , * rest , inplace = inplace , flatten_mode = flatten_mode , ignore_static = ignore_static , )","title":"merge()"},{"location":"api/Metric/#treex.metrics.metric.Metric.to_dict","text":"to_dict is a wrapper over treeo.to_dict that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True type_info bool If True , type information is included. False field_info bool If True , field information is included. False Returns: Type Description Any A dict representation of the object. Source code in treex/metrics/metric.py def to_dict ( self , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : \"\"\" `to_dict` is a wrapper over `treeo.to_dict` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. type_info: If `True`, type information is included. field_info: If `True`, field information is included. Returns: A dict representation of the object. \"\"\" return api . to_dict ( self , private_fields = private_fields , static_fields = static_fields , type_info = type_info , field_info = field_info , )","title":"to_dict()"},{"location":"api/Metric/#treex.metrics.metric.Metric.to_string","text":"to_string is a wrapper over treeo.to_string that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True color bool If True , color is included. False Returns: Type Description str A string representation of the object. Source code in treex/metrics/metric.py def to_string ( self : A , * , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" `to_string` is a wrapper over `treeo.to_string` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. color: If `True`, color is included. Returns: A string representation of the object. \"\"\" return api . to_string ( self , private_fields = private_fields , static_fields = static_fields , color = color , )","title":"to_string()"},{"location":"api/MetricLog/","text":"treex.MetricLog","title":"MetricLog"},{"location":"api/MetricLog/#treexmetriclog","text":"","title":"treex.MetricLog"},{"location":"api/MetricState/","text":"treex.MetricState","title":"MetricState"},{"location":"api/MetricState/#treexmetricstate","text":"","title":"treex.MetricState"},{"location":"api/Missing/","text":"treex.Missing","title":"Missing"},{"location":"api/Missing/#treexmissing","text":"","title":"treex.Missing"},{"location":"api/ModelState/","text":"treex.ModelState","title":"ModelState"},{"location":"api/ModelState/#treexmodelstate","text":"","title":"treex.ModelState"},{"location":"api/Module/","text":"treex.Module first_run : bool inherited property readonly Returns: Type Description bool True if its currently the first run of a compact method. __class__ inherited __base__ inherited Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()). __instancecheck__ ( cls , instance ) special Override for isinstance(instance, cls). Source code in treex/module.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance ) __new__ ( mcls , name , bases , namespace , ** kwargs ) special staticmethod Create and return a new object. See help(type) for accurate signature. Source code in treex/module.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls __subclasscheck__ ( cls , subclass ) special Override for issubclass(subclass, cls). Source code in treex/module.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass ) register ( cls , subclass ) Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/module.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) register ( cls , subclass ) inherited Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/module.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) __init_subclass__ () classmethod special This method is called when a class is subclassed. The default implementation does nothing. It may be overridden to extend subclasses. Source code in treex/module.py def __init_subclass__ ( cls ): if issubclass ( cls , tp . Callable ): orig_call = cls . __call__ @functools . wraps ( cls . __call__ ) def new_call ( self : Module , * args , ** kwargs ): outputs = orig_call ( self , * args , ** kwargs ) if _CONTEXT . call_info is not None and self not in _CONTEXT . call_info : inputs = types . Inputs ( * args , ** kwargs ) _CONTEXT . call_info [ self ] = ( inputs , outputs ) return outputs cls . __call__ = new_call return super () . __init_subclass__ () apply ( self , f , * rest , * , inplace = False ) inherited apply is a wrapper over treeo.apply that passes self as the second argument. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treex/module.py def apply ( self : A , f : tp . Callable [ ... , None ], * rest : A , inplace : bool = False ) -> A : \"\"\" `apply` is a wrapper over `treeo.apply` that passes `self` as the second argument. Arguments: f: The function to apply. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" return api . apply ( f , self , * rest , inplace = inplace ) batch_stats ( self , * filters ) Returns a copy of the Module with only tx.BatchStat TreeParts, alias for filter(tx.BatchStat) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/module.py def batch_stats ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.BatchStat TreeParts, alias for `filter(tx.BatchStat)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . BatchStat , * filters ) check_metadata_updates ( self ) inherited Checks for new fields, if found, adds them to the metadata. Source code in treex/module.py def check_metadata_updates ( self ): \"\"\" Checks for new fields, if found, adds them to the metadata. \"\"\" with _CONTEXT . update ( flatten_mode = FlattenMode . all_fields ): jax . tree_flatten ( self ) copy ( self ) inherited copy is a wrapper over treeo.copy that passes self as the first argument. Source code in treex/module.py def copy ( self : A ) -> A : \"\"\" `copy` is a wrapper over `treeo.copy` that passes `self` as the first argument. \"\"\" return tree_m . copy ( self ) eval ( self , inplace = False ) Creates a new module with the training mode set to False, equivalent to calling train(False) . Returns: Type Description ~M The new module with the training mode set to False. Source code in treex/module.py def eval ( self : M , inplace : bool = False ) -> M : \"\"\" Creates a new module with the training mode set to False, equivalent to calling `train(False)`. Returns: The new module with the training mode set to False. \"\"\" return self . train ( False , inplace = inplace ) filter ( self , * filters , * , inplace = False , flatten_mode = None ) inherited filter is a wrapper over treeo.filter that passes self as the first argument. Parameters: Name Type Description Default *filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treex/module.py def filter ( self : A , * filters : api . Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ) -> A : \"\"\" `filter` is a wrapper over `treeo.filter` that passes `self` as the first argument. Arguments: *filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" return api . filter ( self , * filters , inplace = inplace , flatten_mode = flatten_mode ) freeze ( self , mode = True , inplace = False ) Creates a new module with the same structure, but with Module.frozen set to the given value. Parameters: Name Type Description Default mode bool The new frozen mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~M The new module in with the frozen mode is set to the given value, if inplace is True then self is returned. Source code in treex/module.py def freeze ( self : M , mode : bool = True , inplace : bool = False ) -> M : \"\"\" Creates a new module with the same structure, but with `Module.frozen` set to the given value. Arguments: mode: The new `frozen` mode. inplace: Whether to update the module inplace. Returns: The new module in with the `frozen` mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_frozen ( module : Module ): if isinstance ( module , Module ): module . _frozen = mode return to . apply ( set_frozen , self , inplace = inplace ) get_field ( self , field_name , initializer ) inherited A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: The field must be declared in the class definition. The method can only be called inside a compact context. Parameters: Name Type Description Default field_name str The name of the field to get. required initializer Callable[[], ~A] The function to initialize the field if it does not exist. required Returns: Type Description ~A The field value. Source code in treex/module.py def get_field ( self , field_name : str , initializer : tp . Callable [[], A ], ) -> A : \"\"\" A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: * The field must be declared in the class definition. * The method can only be called inside a `compact` context. Arguments: field_name: The name of the field to get. initializer: The function to initialize the field if it does not exist. Returns: The field value. \"\"\" value : A if field_name not in self . _field_metadata : raise ValueError ( f \"Metadata for field ' { field_name } ' does not exist.\" ) if tree_m . _COMPACT_CONTEXT . current_tree is not self : raise RuntimeError ( f \"Object ' { type ( self ) . __name__ } ' is not the current tree, found ' { type ( tree_m . _COMPACT_CONTEXT . current_tree ) . __name__ } ', did you forget the @compact decorator?\" ) if field_name in vars ( self ): value = getattr ( self , field_name ) else : if tree_m . _COMPACT_CONTEXT . in_compact and not self . first_run : raise RuntimeError ( f \"Trying to initialize field ' { field_name } ' after the first run of `compact`.\" ) value = initializer () setattr ( self , field_name , value ) return value init ( self , key , inplace = False ) Method version of tx.init , it applies self as first argument. init creates a new module with the same structure, but with its fields initialized given a seed key . The following procedure is used: The input key is split and iteratively updated before passing a derived value to any process that requires initialization. Initializer s are called and applied to the module first. Module.rng_init methods are called last. Parameters: Name Type Description Default key Union[int, jax._src.numpy.lax_numpy.ndarray] The seed to use for initialization. required Returns: Type Description ~M The new module with the fields initialized. Source code in treex/module.py def init ( self : M , key : tp . Union [ int , jnp . ndarray ], inplace : bool = False ) -> M : \"\"\" Method version of `tx.init`, it applies `self` as first argument. `init` creates a new module with the same structure, but with its fields initialized given a seed `key`. The following procedure is used: 1. The input `key` is split and iteratively updated before passing a derived value to any process that requires initialization. 2. `Initializer`s are called and applied to the module first. 3. `Module.rng_init` methods are called last. Arguments: key: The seed to use for initialization. Returns: The new module with the fields initialized. \"\"\" if isinstance ( key , int ): key = jax . random . PRNGKey ( key ) def next_key () -> jnp . ndarray : nonlocal key assert isinstance ( key , ( np . ndarray , jnp . ndarray )) next_key , key = utils . iter_split ( key ) return next_key tree_out : M = jax . tree_map ( lambda initializer : ( initializer ( next_key ()) if isinstance ( initializer , types . Initializer ) else initializer ), self , is_leaf = lambda x : isinstance ( x , types . Initializer ), ) if inplace : # here we update initialized fields by the above tree_map tree_out = to . merge ( self , tree_out , inplace = True ) def call_module_init ( module : Module ): if isinstance ( module , Module ) and not module . _initialized : module . rng_init ( next_key ()) module . _initialized = True return to . apply ( call_module_init , tree_out , inplace = inplace ) logs ( self , * filters ) Returns a copy of the Module with only tx.Log TreeParts, alias for filter(tx.Log) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/module.py def logs ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Log TreeParts, alias for `filter(tx.Log)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . Log , * filters ) losses ( self , * filters ) Returns a copy of the Module with only tx.Loss TreeParts, alias for filter(tx.Loss) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/module.py def losses ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Loss TreeParts, alias for `filter(tx.Loss)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . LossLog , * filters ) map ( self , f , * filters , * , inplace = False , flatten_mode = None , is_leaf = None ) inherited map is a wrapper over treeo.map that passes self as the second argument. Parameters: Name Type Description Default f Callable The function to apply to the leaves. required *filters Filter The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treex/module.py def map ( self : A , f : tp . Callable , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , is_leaf : tp . Callable [[ tp . Any ], bool ] = None , ) -> A : \"\"\" `map` is a wrapper over `treeo.map` that passes `self` as the second argument. Arguments: f: The function to apply to the leaves. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" return api . map ( f , self , * filters , inplace = inplace , flatten_mode = flatten_mode , is_leaf = is_leaf , ) merge ( self , other , * rest , * , inplace = False , flatten_mode = None , ignore_static = False ) inherited merge is a wrapper over treeo.merge that passes self as the first argument. Parameters: Name Type Description Default other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the merged values. If inplace is True , obj is returned. Source code in treex/module.py def merge ( self : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" `merge` is a wrapper over `treeo.merge` that passes `self` as the first argument. Arguments: other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the merged values. If `inplace` is `True`, `obj` is returned. \"\"\" return api . merge ( self , other , * rest , inplace = inplace , flatten_mode = flatten_mode , ignore_static = ignore_static , ) metrics ( self , * filters ) Returns a copy of the Module with only tx.Metric TreeParts, alias for filter(tx.Metric) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/module.py def metrics ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Metric TreeParts, alias for `filter(tx.Metric)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . MetricLog , * filters ) model_states ( self , * filters ) Returns a copy of the Module with only tx.ModelState TreeParts, alias for filter(tx.ModelState) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/module.py def model_states ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.ModelState TreeParts, alias for `filter(tx.ModelState)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . ModelState , * filters ) parameters ( self , * filters ) Returns a copy of the Module with only tx.Parameter TreeParts, alias for filter(tx.Parameter) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/module.py def parameters ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Parameter TreeParts, alias for `filter(tx.Parameter)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . Parameter , * filters ) rngs ( self , * filters ) Returns a copy of the Module with only tx.Rng TreeParts, alias for filter(tx.Rng) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/module.py def rngs ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Rng TreeParts, alias for `filter(tx.Rng)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . Rng , * filters ) states ( self , * filters ) Returns a copy of the Module with only tx.State TreeParts, alias for filter(tx.State) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/module.py def states ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.State TreeParts, alias for `filter(tx.State)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . State , * filters ) tabulate ( self , inputs = None , depth =- 1 , signature = False , param_types = True ) Returns a tabular representation of the module. Parameters: Name Type Description Default depth int The maximum depth of the representation in terms of nested Modules, -1 means no limit. -1 signature bool Whether to show the signature of the Module. False param_types bool Whether to show the types of the parameters. True Returns: Type Description str A string containing the tabular representation. Source code in treex/module.py def tabulate ( self , inputs : tp . Union [ tp . Any , types . Inputs , None ] = None , depth : int = - 1 , signature : bool = False , param_types : bool = True , ) -> str : \"\"\" Returns a tabular representation of the module. Arguments: depth: The maximum depth of the representation in terms of nested Modules, -1 means no limit. signature: Whether to show the signature of the Module. param_types: Whether to show the types of the parameters. Returns: A string containing the tabular representation. \"\"\" self = to . copy ( self ) if inputs is not None : if not isinstance ( inputs , types . Inputs ): inputs = types . Inputs ( inputs ) inputs = tp . cast ( types . Inputs , inputs ) if not isinstance ( self , tp . Callable ): raise TypeError ( \"`inputs` can only be specified if the module is a callable.\" ) with _Context ( call_info = {}): # call using self to preserve references def eval_call ( args , kwargs ): assert isinstance ( self , tp . Callable ) return self ( * args , ** kwargs ) jax . eval_shape ( eval_call , inputs . args , inputs . kwargs , ) call_info = _CONTEXT . call_info else : call_info = None with to . add_field_info (): flat : tp . List [ to . FieldInfo ] flat , _ = jax . tree_flatten ( self ) tree_part_types : tp . Tuple [ tp . Type [ types . TreePart ], ... ] = tuple ( { field_info . kind for field_info in flat if utils . _generic_issubclass ( field_info . kind , types . TreePart ) } ) path = () rows = list ( utils . _get_tabulate_rows ( path , self , depth , tree_part_types , signature , param_types ) ) modules = [ row [ 0 ] for row in rows ] rows = [ row [ 1 :] for row in rows ] if call_info is not None : for module , row in zip ( modules , rows ): if module in call_info : inputs , outputs = call_info [ module ] simplified_inputs = ( inputs . args [ 0 ] if len ( inputs . kwargs ) == 0 and len ( inputs . args ) == 1 else inputs . kwargs if len ( inputs . kwargs ) == 0 else inputs . kwargs if len ( inputs . args ) == 0 else ( inputs . args , inputs . kwargs ) ) inputs_repr = utils . _format_param_tree ( simplified_inputs ) outputs_repr = utils . _format_param_tree ( outputs ) else : inputs_repr = \"\" outputs_repr = \"\" row . insert ( 3 , outputs_repr ) row . insert ( 3 , inputs_repr ) n_non_treepart_cols = 2 if call_info is None else 4 rows [ 0 ][ 0 ] = \"*\" rows . append ( [ \"\" ] * n_non_treepart_cols + [ \"Total:\" ] + [ utils . _format_obj_size ( self . filter ( kind ), add_padding = True ) for kind in tree_part_types ] ) utils . _add_padding ( rows ) table = Table ( show_header = True , show_lines = True , show_footer = True , # box=rich.box.HORIZONTALS, ) table . add_column ( \"path\" ) table . add_column ( \"module\" ) table . add_column ( \"params\" ) if call_info is not None : table . add_column ( \"inputs\" ) table . add_column ( \"outputs\" ) for tree_part_type in tree_part_types : type_name = tree_part_type . __name__ if type_name . startswith ( \"_\" ): type_name = type_name [ 1 :] table . add_column ( type_name ) for row in rows [: - 1 ]: table . add_row ( * row ) table . columns [ n_non_treepart_cols ] . footer = Text . from_markup ( rows [ - 1 ][ n_non_treepart_cols ], justify = \"right\" ) for i in range ( len ( tree_part_types )): table . columns [ n_non_treepart_cols + 1 + i ] . footer = rows [ - 1 ][ n_non_treepart_cols + 1 + i ] table . caption_style = \"bold\" table . caption = \" \\n Total Parameters: \" + utils . _format_obj_size ( self , add_padding = False ) return utils . _get_rich_repr ( table ) to_dict ( self , * , private_fields = False , static_fields = True , type_info = False , field_info = False ) inherited to_dict is a wrapper over treeo.to_dict that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True type_info bool If True , type information is included. False field_info bool If True , field information is included. False Returns: Type Description Any A dict representation of the object. Source code in treex/module.py def to_dict ( self , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : \"\"\" `to_dict` is a wrapper over `treeo.to_dict` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. type_info: If `True`, type information is included. field_info: If `True`, field information is included. Returns: A dict representation of the object. \"\"\" return api . to_dict ( self , private_fields = private_fields , static_fields = static_fields , type_info = type_info , field_info = field_info , ) to_string ( self , * , private_fields = False , static_fields = True , color = False ) inherited to_string is a wrapper over treeo.to_string that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True color bool If True , color is included. False Returns: Type Description str A string representation of the object. Source code in treex/module.py def to_string ( self : A , * , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" `to_string` is a wrapper over `treeo.to_string` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. color: If `True`, color is included. Returns: A string representation of the object. \"\"\" return api . to_string ( self , private_fields = private_fields , static_fields = static_fields , color = color , ) train ( self , mode = True , inplace = False ) Creates a new module with the same structure, but with Module.training set to the given value. Parameters: Name Type Description Default mode bool The new training mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~M The new module in with the training mode is set to the given value, if inplace is True then self is returned. Source code in treex/module.py def train ( self : M , mode : bool = True , inplace : bool = False ) -> M : \"\"\" Creates a new module with the same structure, but with `Module.training` set to the given value. Arguments: mode: The new training mode. inplace: Whether to update the module inplace. Returns: The new module in with the training mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_training ( module : Module ): if isinstance ( module , Module ): module . _training = mode return to . apply ( set_training , self , inplace = inplace ) unfreeze ( self , inplace = False ) Creates a new module with .frozen set to False, equivalent to calling freeze(False) . Parameters: Name Type Description Default inplace bool Whether to update the module inplace. False Returns: Type Description ~M The new module with .frozen set to False, if inplace is True then self is returned. Source code in treex/module.py def unfreeze ( self : M , inplace : bool = False ) -> M : \"\"\" Creates a new module with `.frozen` set to False, equivalent to calling `freeze(False)`. Arguments: inplace: Whether to update the module inplace. Returns: The new module with `.frozen` set to False, if `inplace` is `True` then `self` is returned. \"\"\" return self . freeze ( False , inplace = inplace )","title":"Module"},{"location":"api/Module/#treexmodule","text":"","title":"treex.Module"},{"location":"api/Module/#treex.module.Module.first_run","text":"Returns: Type Description bool True if its currently the first run of a compact method.","title":"first_run"},{"location":"api/Module/#treex.module.Module.__class__","text":"","title":"__class__"},{"location":"api/Module/#treex.module.Module.__class__.__base__","text":"Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()).","title":"__base__"},{"location":"api/Module/#treex.module.Module.__class__.__base__.__instancecheck__","text":"Override for isinstance(instance, cls). Source code in treex/module.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance )","title":"__instancecheck__()"},{"location":"api/Module/#treex.module.Module.__class__.__base__.__new__","text":"Create and return a new object. See help(type) for accurate signature. Source code in treex/module.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls","title":"__new__()"},{"location":"api/Module/#treex.module.Module.__class__.__base__.__subclasscheck__","text":"Override for issubclass(subclass, cls). Source code in treex/module.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass )","title":"__subclasscheck__()"},{"location":"api/Module/#treex.module.Module.__class__.__base__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/module.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/Module/#treex.module.Module.__class__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/module.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/Module/#treex.module.Module.__init_subclass__","text":"This method is called when a class is subclassed. The default implementation does nothing. It may be overridden to extend subclasses. Source code in treex/module.py def __init_subclass__ ( cls ): if issubclass ( cls , tp . Callable ): orig_call = cls . __call__ @functools . wraps ( cls . __call__ ) def new_call ( self : Module , * args , ** kwargs ): outputs = orig_call ( self , * args , ** kwargs ) if _CONTEXT . call_info is not None and self not in _CONTEXT . call_info : inputs = types . Inputs ( * args , ** kwargs ) _CONTEXT . call_info [ self ] = ( inputs , outputs ) return outputs cls . __call__ = new_call return super () . __init_subclass__ ()","title":"__init_subclass__()"},{"location":"api/Module/#treex.module.Module.apply","text":"apply is a wrapper over treeo.apply that passes self as the second argument. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treex/module.py def apply ( self : A , f : tp . Callable [ ... , None ], * rest : A , inplace : bool = False ) -> A : \"\"\" `apply` is a wrapper over `treeo.apply` that passes `self` as the second argument. Arguments: f: The function to apply. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" return api . apply ( f , self , * rest , inplace = inplace )","title":"apply()"},{"location":"api/Module/#treex.module.Module.batch_stats","text":"Returns a copy of the Module with only tx.BatchStat TreeParts, alias for filter(tx.BatchStat) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/module.py def batch_stats ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.BatchStat TreeParts, alias for `filter(tx.BatchStat)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . BatchStat , * filters )","title":"batch_stats()"},{"location":"api/Module/#treex.module.Module.check_metadata_updates","text":"Checks for new fields, if found, adds them to the metadata. Source code in treex/module.py def check_metadata_updates ( self ): \"\"\" Checks for new fields, if found, adds them to the metadata. \"\"\" with _CONTEXT . update ( flatten_mode = FlattenMode . all_fields ): jax . tree_flatten ( self )","title":"check_metadata_updates()"},{"location":"api/Module/#treex.module.Module.copy","text":"copy is a wrapper over treeo.copy that passes self as the first argument. Source code in treex/module.py def copy ( self : A ) -> A : \"\"\" `copy` is a wrapper over `treeo.copy` that passes `self` as the first argument. \"\"\" return tree_m . copy ( self )","title":"copy()"},{"location":"api/Module/#treex.module.Module.eval","text":"Creates a new module with the training mode set to False, equivalent to calling train(False) . Returns: Type Description ~M The new module with the training mode set to False. Source code in treex/module.py def eval ( self : M , inplace : bool = False ) -> M : \"\"\" Creates a new module with the training mode set to False, equivalent to calling `train(False)`. Returns: The new module with the training mode set to False. \"\"\" return self . train ( False , inplace = inplace )","title":"eval()"},{"location":"api/Module/#treex.module.Module.filter","text":"filter is a wrapper over treeo.filter that passes self as the first argument. Parameters: Name Type Description Default *filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treex/module.py def filter ( self : A , * filters : api . Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ) -> A : \"\"\" `filter` is a wrapper over `treeo.filter` that passes `self` as the first argument. Arguments: *filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" return api . filter ( self , * filters , inplace = inplace , flatten_mode = flatten_mode )","title":"filter()"},{"location":"api/Module/#treex.module.Module.freeze","text":"Creates a new module with the same structure, but with Module.frozen set to the given value. Parameters: Name Type Description Default mode bool The new frozen mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~M The new module in with the frozen mode is set to the given value, if inplace is True then self is returned. Source code in treex/module.py def freeze ( self : M , mode : bool = True , inplace : bool = False ) -> M : \"\"\" Creates a new module with the same structure, but with `Module.frozen` set to the given value. Arguments: mode: The new `frozen` mode. inplace: Whether to update the module inplace. Returns: The new module in with the `frozen` mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_frozen ( module : Module ): if isinstance ( module , Module ): module . _frozen = mode return to . apply ( set_frozen , self , inplace = inplace )","title":"freeze()"},{"location":"api/Module/#treex.module.Module.get_field","text":"A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: The field must be declared in the class definition. The method can only be called inside a compact context. Parameters: Name Type Description Default field_name str The name of the field to get. required initializer Callable[[], ~A] The function to initialize the field if it does not exist. required Returns: Type Description ~A The field value. Source code in treex/module.py def get_field ( self , field_name : str , initializer : tp . Callable [[], A ], ) -> A : \"\"\" A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: * The field must be declared in the class definition. * The method can only be called inside a `compact` context. Arguments: field_name: The name of the field to get. initializer: The function to initialize the field if it does not exist. Returns: The field value. \"\"\" value : A if field_name not in self . _field_metadata : raise ValueError ( f \"Metadata for field ' { field_name } ' does not exist.\" ) if tree_m . _COMPACT_CONTEXT . current_tree is not self : raise RuntimeError ( f \"Object ' { type ( self ) . __name__ } ' is not the current tree, found ' { type ( tree_m . _COMPACT_CONTEXT . current_tree ) . __name__ } ', did you forget the @compact decorator?\" ) if field_name in vars ( self ): value = getattr ( self , field_name ) else : if tree_m . _COMPACT_CONTEXT . in_compact and not self . first_run : raise RuntimeError ( f \"Trying to initialize field ' { field_name } ' after the first run of `compact`.\" ) value = initializer () setattr ( self , field_name , value ) return value","title":"get_field()"},{"location":"api/Module/#treex.module.Module.init","text":"Method version of tx.init , it applies self as first argument. init creates a new module with the same structure, but with its fields initialized given a seed key . The following procedure is used: The input key is split and iteratively updated before passing a derived value to any process that requires initialization. Initializer s are called and applied to the module first. Module.rng_init methods are called last. Parameters: Name Type Description Default key Union[int, jax._src.numpy.lax_numpy.ndarray] The seed to use for initialization. required Returns: Type Description ~M The new module with the fields initialized. Source code in treex/module.py def init ( self : M , key : tp . Union [ int , jnp . ndarray ], inplace : bool = False ) -> M : \"\"\" Method version of `tx.init`, it applies `self` as first argument. `init` creates a new module with the same structure, but with its fields initialized given a seed `key`. The following procedure is used: 1. The input `key` is split and iteratively updated before passing a derived value to any process that requires initialization. 2. `Initializer`s are called and applied to the module first. 3. `Module.rng_init` methods are called last. Arguments: key: The seed to use for initialization. Returns: The new module with the fields initialized. \"\"\" if isinstance ( key , int ): key = jax . random . PRNGKey ( key ) def next_key () -> jnp . ndarray : nonlocal key assert isinstance ( key , ( np . ndarray , jnp . ndarray )) next_key , key = utils . iter_split ( key ) return next_key tree_out : M = jax . tree_map ( lambda initializer : ( initializer ( next_key ()) if isinstance ( initializer , types . Initializer ) else initializer ), self , is_leaf = lambda x : isinstance ( x , types . Initializer ), ) if inplace : # here we update initialized fields by the above tree_map tree_out = to . merge ( self , tree_out , inplace = True ) def call_module_init ( module : Module ): if isinstance ( module , Module ) and not module . _initialized : module . rng_init ( next_key ()) module . _initialized = True return to . apply ( call_module_init , tree_out , inplace = inplace )","title":"init()"},{"location":"api/Module/#treex.module.Module.logs","text":"Returns a copy of the Module with only tx.Log TreeParts, alias for filter(tx.Log) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/module.py def logs ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Log TreeParts, alias for `filter(tx.Log)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . Log , * filters )","title":"logs()"},{"location":"api/Module/#treex.module.Module.losses","text":"Returns a copy of the Module with only tx.Loss TreeParts, alias for filter(tx.Loss) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/module.py def losses ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Loss TreeParts, alias for `filter(tx.Loss)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . LossLog , * filters )","title":"losses()"},{"location":"api/Module/#treex.module.Module.map","text":"map is a wrapper over treeo.map that passes self as the second argument. Parameters: Name Type Description Default f Callable The function to apply to the leaves. required *filters Filter The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treex/module.py def map ( self : A , f : tp . Callable , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , is_leaf : tp . Callable [[ tp . Any ], bool ] = None , ) -> A : \"\"\" `map` is a wrapper over `treeo.map` that passes `self` as the second argument. Arguments: f: The function to apply to the leaves. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" return api . map ( f , self , * filters , inplace = inplace , flatten_mode = flatten_mode , is_leaf = is_leaf , )","title":"map()"},{"location":"api/Module/#treex.module.Module.merge","text":"merge is a wrapper over treeo.merge that passes self as the first argument. Parameters: Name Type Description Default other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the merged values. If inplace is True , obj is returned. Source code in treex/module.py def merge ( self : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" `merge` is a wrapper over `treeo.merge` that passes `self` as the first argument. Arguments: other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the merged values. If `inplace` is `True`, `obj` is returned. \"\"\" return api . merge ( self , other , * rest , inplace = inplace , flatten_mode = flatten_mode , ignore_static = ignore_static , )","title":"merge()"},{"location":"api/Module/#treex.module.Module.metrics","text":"Returns a copy of the Module with only tx.Metric TreeParts, alias for filter(tx.Metric) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/module.py def metrics ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Metric TreeParts, alias for `filter(tx.Metric)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . MetricLog , * filters )","title":"metrics()"},{"location":"api/Module/#treex.module.Module.model_states","text":"Returns a copy of the Module with only tx.ModelState TreeParts, alias for filter(tx.ModelState) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/module.py def model_states ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.ModelState TreeParts, alias for `filter(tx.ModelState)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . ModelState , * filters )","title":"model_states()"},{"location":"api/Module/#treex.module.Module.parameters","text":"Returns a copy of the Module with only tx.Parameter TreeParts, alias for filter(tx.Parameter) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/module.py def parameters ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Parameter TreeParts, alias for `filter(tx.Parameter)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . Parameter , * filters )","title":"parameters()"},{"location":"api/Module/#treex.module.Module.rngs","text":"Returns a copy of the Module with only tx.Rng TreeParts, alias for filter(tx.Rng) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/module.py def rngs ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Rng TreeParts, alias for `filter(tx.Rng)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . Rng , * filters )","title":"rngs()"},{"location":"api/Module/#treex.module.Module.states","text":"Returns a copy of the Module with only tx.State TreeParts, alias for filter(tx.State) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/module.py def states ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.State TreeParts, alias for `filter(tx.State)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . State , * filters )","title":"states()"},{"location":"api/Module/#treex.module.Module.tabulate","text":"Returns a tabular representation of the module. Parameters: Name Type Description Default depth int The maximum depth of the representation in terms of nested Modules, -1 means no limit. -1 signature bool Whether to show the signature of the Module. False param_types bool Whether to show the types of the parameters. True Returns: Type Description str A string containing the tabular representation. Source code in treex/module.py def tabulate ( self , inputs : tp . Union [ tp . Any , types . Inputs , None ] = None , depth : int = - 1 , signature : bool = False , param_types : bool = True , ) -> str : \"\"\" Returns a tabular representation of the module. Arguments: depth: The maximum depth of the representation in terms of nested Modules, -1 means no limit. signature: Whether to show the signature of the Module. param_types: Whether to show the types of the parameters. Returns: A string containing the tabular representation. \"\"\" self = to . copy ( self ) if inputs is not None : if not isinstance ( inputs , types . Inputs ): inputs = types . Inputs ( inputs ) inputs = tp . cast ( types . Inputs , inputs ) if not isinstance ( self , tp . Callable ): raise TypeError ( \"`inputs` can only be specified if the module is a callable.\" ) with _Context ( call_info = {}): # call using self to preserve references def eval_call ( args , kwargs ): assert isinstance ( self , tp . Callable ) return self ( * args , ** kwargs ) jax . eval_shape ( eval_call , inputs . args , inputs . kwargs , ) call_info = _CONTEXT . call_info else : call_info = None with to . add_field_info (): flat : tp . List [ to . FieldInfo ] flat , _ = jax . tree_flatten ( self ) tree_part_types : tp . Tuple [ tp . Type [ types . TreePart ], ... ] = tuple ( { field_info . kind for field_info in flat if utils . _generic_issubclass ( field_info . kind , types . TreePart ) } ) path = () rows = list ( utils . _get_tabulate_rows ( path , self , depth , tree_part_types , signature , param_types ) ) modules = [ row [ 0 ] for row in rows ] rows = [ row [ 1 :] for row in rows ] if call_info is not None : for module , row in zip ( modules , rows ): if module in call_info : inputs , outputs = call_info [ module ] simplified_inputs = ( inputs . args [ 0 ] if len ( inputs . kwargs ) == 0 and len ( inputs . args ) == 1 else inputs . kwargs if len ( inputs . kwargs ) == 0 else inputs . kwargs if len ( inputs . args ) == 0 else ( inputs . args , inputs . kwargs ) ) inputs_repr = utils . _format_param_tree ( simplified_inputs ) outputs_repr = utils . _format_param_tree ( outputs ) else : inputs_repr = \"\" outputs_repr = \"\" row . insert ( 3 , outputs_repr ) row . insert ( 3 , inputs_repr ) n_non_treepart_cols = 2 if call_info is None else 4 rows [ 0 ][ 0 ] = \"*\" rows . append ( [ \"\" ] * n_non_treepart_cols + [ \"Total:\" ] + [ utils . _format_obj_size ( self . filter ( kind ), add_padding = True ) for kind in tree_part_types ] ) utils . _add_padding ( rows ) table = Table ( show_header = True , show_lines = True , show_footer = True , # box=rich.box.HORIZONTALS, ) table . add_column ( \"path\" ) table . add_column ( \"module\" ) table . add_column ( \"params\" ) if call_info is not None : table . add_column ( \"inputs\" ) table . add_column ( \"outputs\" ) for tree_part_type in tree_part_types : type_name = tree_part_type . __name__ if type_name . startswith ( \"_\" ): type_name = type_name [ 1 :] table . add_column ( type_name ) for row in rows [: - 1 ]: table . add_row ( * row ) table . columns [ n_non_treepart_cols ] . footer = Text . from_markup ( rows [ - 1 ][ n_non_treepart_cols ], justify = \"right\" ) for i in range ( len ( tree_part_types )): table . columns [ n_non_treepart_cols + 1 + i ] . footer = rows [ - 1 ][ n_non_treepart_cols + 1 + i ] table . caption_style = \"bold\" table . caption = \" \\n Total Parameters: \" + utils . _format_obj_size ( self , add_padding = False ) return utils . _get_rich_repr ( table )","title":"tabulate()"},{"location":"api/Module/#treex.module.Module.to_dict","text":"to_dict is a wrapper over treeo.to_dict that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True type_info bool If True , type information is included. False field_info bool If True , field information is included. False Returns: Type Description Any A dict representation of the object. Source code in treex/module.py def to_dict ( self , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : \"\"\" `to_dict` is a wrapper over `treeo.to_dict` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. type_info: If `True`, type information is included. field_info: If `True`, field information is included. Returns: A dict representation of the object. \"\"\" return api . to_dict ( self , private_fields = private_fields , static_fields = static_fields , type_info = type_info , field_info = field_info , )","title":"to_dict()"},{"location":"api/Module/#treex.module.Module.to_string","text":"to_string is a wrapper over treeo.to_string that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True color bool If True , color is included. False Returns: Type Description str A string representation of the object. Source code in treex/module.py def to_string ( self : A , * , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" `to_string` is a wrapper over `treeo.to_string` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. color: If `True`, color is included. Returns: A string representation of the object. \"\"\" return api . to_string ( self , private_fields = private_fields , static_fields = static_fields , color = color , )","title":"to_string()"},{"location":"api/Module/#treex.module.Module.train","text":"Creates a new module with the same structure, but with Module.training set to the given value. Parameters: Name Type Description Default mode bool The new training mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~M The new module in with the training mode is set to the given value, if inplace is True then self is returned. Source code in treex/module.py def train ( self : M , mode : bool = True , inplace : bool = False ) -> M : \"\"\" Creates a new module with the same structure, but with `Module.training` set to the given value. Arguments: mode: The new training mode. inplace: Whether to update the module inplace. Returns: The new module in with the training mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_training ( module : Module ): if isinstance ( module , Module ): module . _training = mode return to . apply ( set_training , self , inplace = inplace )","title":"train()"},{"location":"api/Module/#treex.module.Module.unfreeze","text":"Creates a new module with .frozen set to False, equivalent to calling freeze(False) . Parameters: Name Type Description Default inplace bool Whether to update the module inplace. False Returns: Type Description ~M The new module with .frozen set to False, if inplace is True then self is returned. Source code in treex/module.py def unfreeze ( self : M , inplace : bool = False ) -> M : \"\"\" Creates a new module with `.frozen` set to False, equivalent to calling `freeze(False)`. Arguments: inplace: Whether to update the module inplace. Returns: The new module with `.frozen` set to False, if `inplace` is `True` then `self` is returned. \"\"\" return self . freeze ( False , inplace = inplace )","title":"unfreeze()"},{"location":"api/Named/","text":"treex.Named Named( args, *kwargs) __class__ inherited __base__ inherited Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()). __instancecheck__ ( cls , instance ) special Override for isinstance(instance, cls). Source code in treex/types.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance ) __new__ ( mcls , name , bases , namespace , ** kwargs ) special staticmethod Create and return a new object. See help(type) for accurate signature. Source code in treex/types.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls __subclasscheck__ ( cls , subclass ) special Override for issubclass(subclass, cls). Source code in treex/types.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass ) register ( cls , subclass ) Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/types.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) register ( cls , subclass ) inherited Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/types.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) check_metadata_updates ( self ) inherited Checks for new fields, if found, adds them to the metadata. Source code in treex/types.py def check_metadata_updates ( self ): \"\"\" Checks for new fields, if found, adds them to the metadata. \"\"\" with _CONTEXT . update ( flatten_mode = FlattenMode . all_fields ): jax . tree_flatten ( self )","title":"Named"},{"location":"api/Named/#treexnamed","text":"Named( args, *kwargs)","title":"treex.Named"},{"location":"api/Named/#treex.types.Named.__class__","text":"","title":"__class__"},{"location":"api/Named/#treex.types.Named.__class__.__base__","text":"Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()).","title":"__base__"},{"location":"api/Named/#treex.types.Named.__class__.__base__.__instancecheck__","text":"Override for isinstance(instance, cls). Source code in treex/types.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance )","title":"__instancecheck__()"},{"location":"api/Named/#treex.types.Named.__class__.__base__.__new__","text":"Create and return a new object. See help(type) for accurate signature. Source code in treex/types.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls","title":"__new__()"},{"location":"api/Named/#treex.types.Named.__class__.__base__.__subclasscheck__","text":"Override for issubclass(subclass, cls). Source code in treex/types.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass )","title":"__subclasscheck__()"},{"location":"api/Named/#treex.types.Named.__class__.__base__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/types.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/Named/#treex.types.Named.__class__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/types.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/Named/#treex.types.Named.check_metadata_updates","text":"Checks for new fields, if found, adds them to the metadata. Source code in treex/types.py def check_metadata_updates ( self ): \"\"\" Checks for new fields, if found, adds them to the metadata. \"\"\" with _CONTEXT . update ( flatten_mode = FlattenMode . all_fields ): jax . tree_flatten ( self )","title":"check_metadata_updates()"},{"location":"api/Nothing/","text":"treex.Nothing","title":"Nothing"},{"location":"api/Nothing/#treexnothing","text":"","title":"treex.Nothing"},{"location":"api/Opaque/","text":"treex.Opaque","title":"Opaque"},{"location":"api/Opaque/#treexopaque","text":"","title":"treex.Opaque"},{"location":"api/OptState/","text":"treex.OptState","title":"OptState"},{"location":"api/OptState/#treexoptstate","text":"","title":"treex.OptState"},{"location":"api/Optimizer/","text":"treex.Optimizer Wraps an optax optimizer and turn it into a Pytree while maintaining a similar API. The main difference with optax is that tx.Optimizer contains its own state, thus, there is no opt_state . Examples: def main (): ... optimizer = tx . Optimizer ( optax . adam ( 1e-3 )) optimizer = optimizer . init ( params ) ... jax . jit def train_step ( model , x , y , optimizer ): ... params = optimizer . update ( grads , params ) ... return model , loss , optimizer Notice that since the optimizer is a Pytree it can naturally pass through jit . Differences with Optax init return a new optimizer instance, there is no opt_state . update doesn't get opt_state as an argument, instead it performs updates to its internal state inplace. update applies the updates to the params and returns them by default, use update=False to to get the param updates instead. Parameters: Name Type Description Default optimizer An optax optimizer. required first_run : bool inherited property readonly Returns: Type Description bool True if its currently the first run of a compact method. __class__ inherited __base__ inherited Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()). __instancecheck__ ( cls , instance ) special Override for isinstance(instance, cls). Source code in treex/optimizer.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance ) __new__ ( mcls , name , bases , namespace , ** kwargs ) special staticmethod Create and return a new object. See help(type) for accurate signature. Source code in treex/optimizer.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls __subclasscheck__ ( cls , subclass ) special Override for issubclass(subclass, cls). Source code in treex/optimizer.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass ) register ( cls , subclass ) Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/optimizer.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) register ( cls , subclass ) inherited Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/optimizer.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) apply ( self , f , * rest , * , inplace = False ) inherited apply is a wrapper over treeo.apply that passes self as the second argument. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treex/optimizer.py def apply ( self : A , f : tp . Callable [ ... , None ], * rest : A , inplace : bool = False ) -> A : \"\"\" `apply` is a wrapper over `treeo.apply` that passes `self` as the second argument. Arguments: f: The function to apply. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" return api . apply ( f , self , * rest , inplace = inplace ) check_metadata_updates ( self ) inherited Checks for new fields, if found, adds them to the metadata. Source code in treex/optimizer.py def check_metadata_updates ( self ): \"\"\" Checks for new fields, if found, adds them to the metadata. \"\"\" with _CONTEXT . update ( flatten_mode = FlattenMode . all_fields ): jax . tree_flatten ( self ) copy ( self ) inherited copy is a wrapper over treeo.copy that passes self as the first argument. Source code in treex/optimizer.py def copy ( self : A ) -> A : \"\"\" `copy` is a wrapper over `treeo.copy` that passes `self` as the first argument. \"\"\" return tree_m . copy ( self ) filter ( self , * filters , * , inplace = False , flatten_mode = None ) inherited filter is a wrapper over treeo.filter that passes self as the first argument. Parameters: Name Type Description Default *filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treex/optimizer.py def filter ( self : A , * filters : api . Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ) -> A : \"\"\" `filter` is a wrapper over `treeo.filter` that passes `self` as the first argument. Arguments: *filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" return api . filter ( self , * filters , inplace = inplace , flatten_mode = flatten_mode ) get_field ( self , field_name , initializer ) inherited A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: The field must be declared in the class definition. The method can only be called inside a compact context. Parameters: Name Type Description Default field_name str The name of the field to get. required initializer Callable[[], ~A] The function to initialize the field if it does not exist. required Returns: Type Description ~A The field value. Source code in treex/optimizer.py def get_field ( self , field_name : str , initializer : tp . Callable [[], A ], ) -> A : \"\"\" A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: * The field must be declared in the class definition. * The method can only be called inside a `compact` context. Arguments: field_name: The name of the field to get. initializer: The function to initialize the field if it does not exist. Returns: The field value. \"\"\" value : A if field_name not in self . _field_metadata : raise ValueError ( f \"Metadata for field ' { field_name } ' does not exist.\" ) if tree_m . _COMPACT_CONTEXT . current_tree is not self : raise RuntimeError ( f \"Object ' { type ( self ) . __name__ } ' is not the current tree, found ' { type ( tree_m . _COMPACT_CONTEXT . current_tree ) . __name__ } ', did you forget the @compact decorator?\" ) if field_name in vars ( self ): value = getattr ( self , field_name ) else : if tree_m . _COMPACT_CONTEXT . in_compact and not self . first_run : raise RuntimeError ( f \"Trying to initialize field ' { field_name } ' after the first run of `compact`.\" ) value = initializer () setattr ( self , field_name , value ) return value init ( self , params ) Initialize the optimizer from an initial set of parameters. Parameters: Name Type Description Default params Any An initial set of parameters. required Returns: Type Description ~O A new optimizer instance. Source code in treex/optimizer.py def init ( self : O , params : tp . Any ) -> O : \"\"\" Initialize the optimizer from an initial set of parameters. Arguments: params: An initial set of parameters. Returns: A new optimizer instance. \"\"\" module = to . copy ( self ) params = jax . tree_leaves ( params ) module . opt_state = module . optimizer . init ( params ) module . _n_params = len ( params ) module . _initialized = True return module map ( self , f , * filters , * , inplace = False , flatten_mode = None , is_leaf = None ) inherited map is a wrapper over treeo.map that passes self as the second argument. Parameters: Name Type Description Default f Callable The function to apply to the leaves. required *filters Filter The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treex/optimizer.py def map ( self : A , f : tp . Callable , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , is_leaf : tp . Callable [[ tp . Any ], bool ] = None , ) -> A : \"\"\" `map` is a wrapper over `treeo.map` that passes `self` as the second argument. Arguments: f: The function to apply to the leaves. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" return api . map ( f , self , * filters , inplace = inplace , flatten_mode = flatten_mode , is_leaf = is_leaf , ) merge ( self , other , * rest , * , inplace = False , flatten_mode = None , ignore_static = False ) inherited merge is a wrapper over treeo.merge that passes self as the first argument. Parameters: Name Type Description Default other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the merged values. If inplace is True , obj is returned. Source code in treex/optimizer.py def merge ( self : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" `merge` is a wrapper over `treeo.merge` that passes `self` as the first argument. Arguments: other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the merged values. If `inplace` is `True`, `obj` is returned. \"\"\" return api . merge ( self , other , * rest , inplace = inplace , flatten_mode = flatten_mode , ignore_static = ignore_static , ) to_dict ( self , * , private_fields = False , static_fields = True , type_info = False , field_info = False ) inherited to_dict is a wrapper over treeo.to_dict that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True type_info bool If True , type information is included. False field_info bool If True , field information is included. False Returns: Type Description Any A dict representation of the object. Source code in treex/optimizer.py def to_dict ( self , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : \"\"\" `to_dict` is a wrapper over `treeo.to_dict` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. type_info: If `True`, type information is included. field_info: If `True`, field information is included. Returns: A dict representation of the object. \"\"\" return api . to_dict ( self , private_fields = private_fields , static_fields = static_fields , type_info = type_info , field_info = field_info , ) to_string ( self , * , private_fields = False , static_fields = True , color = False ) inherited to_string is a wrapper over treeo.to_string that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True color bool If True , color is included. False Returns: Type Description str A string representation of the object. Source code in treex/optimizer.py def to_string ( self : A , * , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" `to_string` is a wrapper over `treeo.to_string` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. color: If `True`, color is included. Returns: A string representation of the object. \"\"\" return api . to_string ( self , private_fields = private_fields , static_fields = static_fields , color = color , ) update ( self , grads , params = None , apply_updates = True ) Applies the parameters updates and updates the optimizers internal state inplace. Parameters: Name Type Description Default grads ~A the gradients to perform the update. required params Optional[~A] the parameters to update. If None then update has to be False . None apply_updates bool if False then the updates are returned instead of being applied. True Returns: Type Description ~A The updated parameters. If apply_updates is False then the updates are returned instead. Source code in treex/optimizer.py def update ( self , grads : A , params : tp . Optional [ A ] = None , apply_updates : bool = True ) -> A : \"\"\" Applies the parameters updates and updates the optimizers internal state inplace. Arguments: grads: the gradients to perform the update. params: the parameters to update. If `None` then `update` has to be `False`. apply_updates: if `False` then the updates are returned instead of being applied. Returns: The updated parameters. If `apply_updates` is `False` then the updates are returned instead. \"\"\" if not self . initialized : raise RuntimeError ( \"Optimizer is not initialized\" ) assert self . opt_state is not None if apply_updates and params is None : raise ValueError ( \"params must be provided if updates are being applied\" ) opt_grads , treedef = jax . tree_flatten ( grads ) opt_params = jax . tree_leaves ( params ) if len ( opt_params ) != self . _n_params : raise ValueError ( f \"params must have length { self . _n_params } , got { len ( opt_params ) } \" ) if len ( opt_grads ) != self . _n_params : raise ValueError ( f \"grads must have length { self . _n_params } , got { len ( opt_grads ) } \" ) param_updates : A param_updates , self . opt_state = self . optimizer . update ( opt_grads , self . opt_state , opt_params , ) output : A if apply_updates : output = optax . apply_updates ( opt_params , param_updates ) else : output = param_updates return jax . tree_unflatten ( treedef , output )","title":"Optimizer"},{"location":"api/Optimizer/#treexoptimizer","text":"Wraps an optax optimizer and turn it into a Pytree while maintaining a similar API. The main difference with optax is that tx.Optimizer contains its own state, thus, there is no opt_state . Examples: def main (): ... optimizer = tx . Optimizer ( optax . adam ( 1e-3 )) optimizer = optimizer . init ( params ) ... jax . jit def train_step ( model , x , y , optimizer ): ... params = optimizer . update ( grads , params ) ... return model , loss , optimizer Notice that since the optimizer is a Pytree it can naturally pass through jit .","title":"treex.Optimizer"},{"location":"api/Optimizer/#treex.optimizer.Optimizer--differences-with-optax","text":"init return a new optimizer instance, there is no opt_state . update doesn't get opt_state as an argument, instead it performs updates to its internal state inplace. update applies the updates to the params and returns them by default, use update=False to to get the param updates instead. Parameters: Name Type Description Default optimizer An optax optimizer. required","title":"Differences with Optax"},{"location":"api/Optimizer/#treex.optimizer.Optimizer.first_run","text":"Returns: Type Description bool True if its currently the first run of a compact method.","title":"first_run"},{"location":"api/Optimizer/#treex.optimizer.Optimizer.__class__","text":"","title":"__class__"},{"location":"api/Optimizer/#treex.optimizer.Optimizer.__class__.__base__","text":"Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()).","title":"__base__"},{"location":"api/Optimizer/#treex.optimizer.Optimizer.__class__.__base__.__instancecheck__","text":"Override for isinstance(instance, cls). Source code in treex/optimizer.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance )","title":"__instancecheck__()"},{"location":"api/Optimizer/#treex.optimizer.Optimizer.__class__.__base__.__new__","text":"Create and return a new object. See help(type) for accurate signature. Source code in treex/optimizer.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls","title":"__new__()"},{"location":"api/Optimizer/#treex.optimizer.Optimizer.__class__.__base__.__subclasscheck__","text":"Override for issubclass(subclass, cls). Source code in treex/optimizer.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass )","title":"__subclasscheck__()"},{"location":"api/Optimizer/#treex.optimizer.Optimizer.__class__.__base__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/optimizer.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/Optimizer/#treex.optimizer.Optimizer.__class__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/optimizer.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/Optimizer/#treex.optimizer.Optimizer.apply","text":"apply is a wrapper over treeo.apply that passes self as the second argument. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treex/optimizer.py def apply ( self : A , f : tp . Callable [ ... , None ], * rest : A , inplace : bool = False ) -> A : \"\"\" `apply` is a wrapper over `treeo.apply` that passes `self` as the second argument. Arguments: f: The function to apply. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" return api . apply ( f , self , * rest , inplace = inplace )","title":"apply()"},{"location":"api/Optimizer/#treex.optimizer.Optimizer.check_metadata_updates","text":"Checks for new fields, if found, adds them to the metadata. Source code in treex/optimizer.py def check_metadata_updates ( self ): \"\"\" Checks for new fields, if found, adds them to the metadata. \"\"\" with _CONTEXT . update ( flatten_mode = FlattenMode . all_fields ): jax . tree_flatten ( self )","title":"check_metadata_updates()"},{"location":"api/Optimizer/#treex.optimizer.Optimizer.copy","text":"copy is a wrapper over treeo.copy that passes self as the first argument. Source code in treex/optimizer.py def copy ( self : A ) -> A : \"\"\" `copy` is a wrapper over `treeo.copy` that passes `self` as the first argument. \"\"\" return tree_m . copy ( self )","title":"copy()"},{"location":"api/Optimizer/#treex.optimizer.Optimizer.filter","text":"filter is a wrapper over treeo.filter that passes self as the first argument. Parameters: Name Type Description Default *filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treex/optimizer.py def filter ( self : A , * filters : api . Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ) -> A : \"\"\" `filter` is a wrapper over `treeo.filter` that passes `self` as the first argument. Arguments: *filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" return api . filter ( self , * filters , inplace = inplace , flatten_mode = flatten_mode )","title":"filter()"},{"location":"api/Optimizer/#treex.optimizer.Optimizer.get_field","text":"A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: The field must be declared in the class definition. The method can only be called inside a compact context. Parameters: Name Type Description Default field_name str The name of the field to get. required initializer Callable[[], ~A] The function to initialize the field if it does not exist. required Returns: Type Description ~A The field value. Source code in treex/optimizer.py def get_field ( self , field_name : str , initializer : tp . Callable [[], A ], ) -> A : \"\"\" A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: * The field must be declared in the class definition. * The method can only be called inside a `compact` context. Arguments: field_name: The name of the field to get. initializer: The function to initialize the field if it does not exist. Returns: The field value. \"\"\" value : A if field_name not in self . _field_metadata : raise ValueError ( f \"Metadata for field ' { field_name } ' does not exist.\" ) if tree_m . _COMPACT_CONTEXT . current_tree is not self : raise RuntimeError ( f \"Object ' { type ( self ) . __name__ } ' is not the current tree, found ' { type ( tree_m . _COMPACT_CONTEXT . current_tree ) . __name__ } ', did you forget the @compact decorator?\" ) if field_name in vars ( self ): value = getattr ( self , field_name ) else : if tree_m . _COMPACT_CONTEXT . in_compact and not self . first_run : raise RuntimeError ( f \"Trying to initialize field ' { field_name } ' after the first run of `compact`.\" ) value = initializer () setattr ( self , field_name , value ) return value","title":"get_field()"},{"location":"api/Optimizer/#treex.optimizer.Optimizer.init","text":"Initialize the optimizer from an initial set of parameters. Parameters: Name Type Description Default params Any An initial set of parameters. required Returns: Type Description ~O A new optimizer instance. Source code in treex/optimizer.py def init ( self : O , params : tp . Any ) -> O : \"\"\" Initialize the optimizer from an initial set of parameters. Arguments: params: An initial set of parameters. Returns: A new optimizer instance. \"\"\" module = to . copy ( self ) params = jax . tree_leaves ( params ) module . opt_state = module . optimizer . init ( params ) module . _n_params = len ( params ) module . _initialized = True return module","title":"init()"},{"location":"api/Optimizer/#treex.optimizer.Optimizer.map","text":"map is a wrapper over treeo.map that passes self as the second argument. Parameters: Name Type Description Default f Callable The function to apply to the leaves. required *filters Filter The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treex/optimizer.py def map ( self : A , f : tp . Callable , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , is_leaf : tp . Callable [[ tp . Any ], bool ] = None , ) -> A : \"\"\" `map` is a wrapper over `treeo.map` that passes `self` as the second argument. Arguments: f: The function to apply to the leaves. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" return api . map ( f , self , * filters , inplace = inplace , flatten_mode = flatten_mode , is_leaf = is_leaf , )","title":"map()"},{"location":"api/Optimizer/#treex.optimizer.Optimizer.merge","text":"merge is a wrapper over treeo.merge that passes self as the first argument. Parameters: Name Type Description Default other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the merged values. If inplace is True , obj is returned. Source code in treex/optimizer.py def merge ( self : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" `merge` is a wrapper over `treeo.merge` that passes `self` as the first argument. Arguments: other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the merged values. If `inplace` is `True`, `obj` is returned. \"\"\" return api . merge ( self , other , * rest , inplace = inplace , flatten_mode = flatten_mode , ignore_static = ignore_static , )","title":"merge()"},{"location":"api/Optimizer/#treex.optimizer.Optimizer.to_dict","text":"to_dict is a wrapper over treeo.to_dict that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True type_info bool If True , type information is included. False field_info bool If True , field information is included. False Returns: Type Description Any A dict representation of the object. Source code in treex/optimizer.py def to_dict ( self , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : \"\"\" `to_dict` is a wrapper over `treeo.to_dict` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. type_info: If `True`, type information is included. field_info: If `True`, field information is included. Returns: A dict representation of the object. \"\"\" return api . to_dict ( self , private_fields = private_fields , static_fields = static_fields , type_info = type_info , field_info = field_info , )","title":"to_dict()"},{"location":"api/Optimizer/#treex.optimizer.Optimizer.to_string","text":"to_string is a wrapper over treeo.to_string that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True color bool If True , color is included. False Returns: Type Description str A string representation of the object. Source code in treex/optimizer.py def to_string ( self : A , * , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" `to_string` is a wrapper over `treeo.to_string` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. color: If `True`, color is included. Returns: A string representation of the object. \"\"\" return api . to_string ( self , private_fields = private_fields , static_fields = static_fields , color = color , )","title":"to_string()"},{"location":"api/Optimizer/#treex.optimizer.Optimizer.update","text":"Applies the parameters updates and updates the optimizers internal state inplace. Parameters: Name Type Description Default grads ~A the gradients to perform the update. required params Optional[~A] the parameters to update. If None then update has to be False . None apply_updates bool if False then the updates are returned instead of being applied. True Returns: Type Description ~A The updated parameters. If apply_updates is False then the updates are returned instead. Source code in treex/optimizer.py def update ( self , grads : A , params : tp . Optional [ A ] = None , apply_updates : bool = True ) -> A : \"\"\" Applies the parameters updates and updates the optimizers internal state inplace. Arguments: grads: the gradients to perform the update. params: the parameters to update. If `None` then `update` has to be `False`. apply_updates: if `False` then the updates are returned instead of being applied. Returns: The updated parameters. If `apply_updates` is `False` then the updates are returned instead. \"\"\" if not self . initialized : raise RuntimeError ( \"Optimizer is not initialized\" ) assert self . opt_state is not None if apply_updates and params is None : raise ValueError ( \"params must be provided if updates are being applied\" ) opt_grads , treedef = jax . tree_flatten ( grads ) opt_params = jax . tree_leaves ( params ) if len ( opt_params ) != self . _n_params : raise ValueError ( f \"params must have length { self . _n_params } , got { len ( opt_params ) } \" ) if len ( opt_grads ) != self . _n_params : raise ValueError ( f \"grads must have length { self . _n_params } , got { len ( opt_grads ) } \" ) param_updates : A param_updates , self . opt_state = self . optimizer . update ( opt_grads , self . opt_state , opt_params , ) output : A if apply_updates : output = optax . apply_updates ( opt_params , param_updates ) else : output = param_updates return jax . tree_unflatten ( treedef , output )","title":"update()"},{"location":"api/Parameter/","text":"treex.Parameter","title":"Parameter"},{"location":"api/Parameter/#treexparameter","text":"","title":"treex.Parameter"},{"location":"api/Repr/","text":"treex.Repr Mixin that adds a __repr__ method to the class. __repr__ ( self ) special Uses treeo.to_string to generate a string representation of the object. Source code in treeo/mixins.py def __repr__ ( self ) -> tp . Any : \"\"\" Uses `treeo.to_string` to generate a string representation of the object. \"\"\" return api . to_string ( self , private_fields = False , static_fields = True , color = False , )","title":"Repr"},{"location":"api/Repr/#treexrepr","text":"Mixin that adds a __repr__ method to the class.","title":"treex.Repr"},{"location":"api/Repr/#treeo.mixins.Repr.__repr__","text":"Uses treeo.to_string to generate a string representation of the object. Source code in treeo/mixins.py def __repr__ ( self ) -> tp . Any : \"\"\" Uses `treeo.to_string` to generate a string representation of the object. \"\"\" return api . to_string ( self , private_fields = False , static_fields = True , color = False , )","title":"__repr__()"},{"location":"api/Rng/","text":"treex.Rng","title":"Rng"},{"location":"api/Rng/#treexrng","text":"","title":"treex.Rng"},{"location":"api/Sequential/","text":"treex.Sequential A Module that applies a sequence of Modules or functions in order. Examples: mlp = tx . Sequential ( tx . Linear ( 2 , 32 ), jax . nn . relu , tx . Linear ( 32 , 8 ), jax . nn . relu , tx . Linear ( 8 , 4 ), ) . init ( 42 ) x = np . random . uniform ( size = ( 10 , 2 )) y = mlp ( x ) assert y . shape == ( 10 , 4 ) first_run : bool inherited property readonly Returns: Type Description bool True if its currently the first run of a compact method. __class__ inherited __base__ inherited Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()). __instancecheck__ ( cls , instance ) special Override for isinstance(instance, cls). Source code in treex/nn/sequential.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance ) __new__ ( mcls , name , bases , namespace , ** kwargs ) special staticmethod Create and return a new object. See help(type) for accurate signature. Source code in treex/nn/sequential.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls __subclasscheck__ ( cls , subclass ) special Override for issubclass(subclass, cls). Source code in treex/nn/sequential.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass ) register ( cls , subclass ) Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/sequential.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) register ( cls , subclass ) inherited Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/sequential.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) __init__ ( self , * layers ) special Parameters: Name Type Description Default *layers Union[Callable[..., jax._src.numpy.lax_numpy.ndarray], Callable[[jax._src.numpy.lax_numpy.ndarray], jax._src.numpy.lax_numpy.ndarray]] A list of layers or callables to apply to apply in sequence. () Source code in treex/nn/sequential.py def __init__ ( self , * layers : tp . Union [ CallableModule , tp . Callable [[ jnp . ndarray ], jnp . ndarray ]] ): \"\"\" Arguments: *layers: A list of layers or callables to apply to apply in sequence. \"\"\" self . layers = [ layer if isinstance ( layer , Module ) else Lambda ( layer ) for layer in layers ] apply ( self , f , * rest , * , inplace = False ) inherited apply is a wrapper over treeo.apply that passes self as the second argument. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treex/nn/sequential.py def apply ( self : A , f : tp . Callable [ ... , None ], * rest : A , inplace : bool = False ) -> A : \"\"\" `apply` is a wrapper over `treeo.apply` that passes `self` as the second argument. Arguments: f: The function to apply. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" return api . apply ( f , self , * rest , inplace = inplace ) batch_stats ( self , * filters ) inherited Returns a copy of the Module with only tx.BatchStat TreeParts, alias for filter(tx.BatchStat) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/sequential.py def batch_stats ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.BatchStat TreeParts, alias for `filter(tx.BatchStat)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . BatchStat , * filters ) check_metadata_updates ( self ) inherited Checks for new fields, if found, adds them to the metadata. Source code in treex/nn/sequential.py def check_metadata_updates ( self ): \"\"\" Checks for new fields, if found, adds them to the metadata. \"\"\" with _CONTEXT . update ( flatten_mode = FlattenMode . all_fields ): jax . tree_flatten ( self ) copy ( self ) inherited copy is a wrapper over treeo.copy that passes self as the first argument. Source code in treex/nn/sequential.py def copy ( self : A ) -> A : \"\"\" `copy` is a wrapper over `treeo.copy` that passes `self` as the first argument. \"\"\" return tree_m . copy ( self ) eval ( self , inplace = False ) inherited Creates a new module with the training mode set to False, equivalent to calling train(False) . Returns: Type Description ~M The new module with the training mode set to False. Source code in treex/nn/sequential.py def eval ( self : M , inplace : bool = False ) -> M : \"\"\" Creates a new module with the training mode set to False, equivalent to calling `train(False)`. Returns: The new module with the training mode set to False. \"\"\" return self . train ( False , inplace = inplace ) filter ( self , * filters , * , inplace = False , flatten_mode = None ) inherited filter is a wrapper over treeo.filter that passes self as the first argument. Parameters: Name Type Description Default *filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treex/nn/sequential.py def filter ( self : A , * filters : api . Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ) -> A : \"\"\" `filter` is a wrapper over `treeo.filter` that passes `self` as the first argument. Arguments: *filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" return api . filter ( self , * filters , inplace = inplace , flatten_mode = flatten_mode ) freeze ( self , mode = True , inplace = False ) inherited Creates a new module with the same structure, but with Module.frozen set to the given value. Parameters: Name Type Description Default mode bool The new frozen mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~M The new module in with the frozen mode is set to the given value, if inplace is True then self is returned. Source code in treex/nn/sequential.py def freeze ( self : M , mode : bool = True , inplace : bool = False ) -> M : \"\"\" Creates a new module with the same structure, but with `Module.frozen` set to the given value. Arguments: mode: The new `frozen` mode. inplace: Whether to update the module inplace. Returns: The new module in with the `frozen` mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_frozen ( module : Module ): if isinstance ( module , Module ): module . _frozen = mode return to . apply ( set_frozen , self , inplace = inplace ) get_field ( self , field_name , initializer ) inherited A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: The field must be declared in the class definition. The method can only be called inside a compact context. Parameters: Name Type Description Default field_name str The name of the field to get. required initializer Callable[[], ~A] The function to initialize the field if it does not exist. required Returns: Type Description ~A The field value. Source code in treex/nn/sequential.py def get_field ( self , field_name : str , initializer : tp . Callable [[], A ], ) -> A : \"\"\" A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: * The field must be declared in the class definition. * The method can only be called inside a `compact` context. Arguments: field_name: The name of the field to get. initializer: The function to initialize the field if it does not exist. Returns: The field value. \"\"\" value : A if field_name not in self . _field_metadata : raise ValueError ( f \"Metadata for field ' { field_name } ' does not exist.\" ) if tree_m . _COMPACT_CONTEXT . current_tree is not self : raise RuntimeError ( f \"Object ' { type ( self ) . __name__ } ' is not the current tree, found ' { type ( tree_m . _COMPACT_CONTEXT . current_tree ) . __name__ } ', did you forget the @compact decorator?\" ) if field_name in vars ( self ): value = getattr ( self , field_name ) else : if tree_m . _COMPACT_CONTEXT . in_compact and not self . first_run : raise RuntimeError ( f \"Trying to initialize field ' { field_name } ' after the first run of `compact`.\" ) value = initializer () setattr ( self , field_name , value ) return value init ( self , key , inplace = False ) inherited Method version of tx.init , it applies self as first argument. init creates a new module with the same structure, but with its fields initialized given a seed key . The following procedure is used: The input key is split and iteratively updated before passing a derived value to any process that requires initialization. Initializer s are called and applied to the module first. Module.rng_init methods are called last. Parameters: Name Type Description Default key Union[int, jax._src.numpy.lax_numpy.ndarray] The seed to use for initialization. required Returns: Type Description ~M The new module with the fields initialized. Source code in treex/nn/sequential.py def init ( self : M , key : tp . Union [ int , jnp . ndarray ], inplace : bool = False ) -> M : \"\"\" Method version of `tx.init`, it applies `self` as first argument. `init` creates a new module with the same structure, but with its fields initialized given a seed `key`. The following procedure is used: 1. The input `key` is split and iteratively updated before passing a derived value to any process that requires initialization. 2. `Initializer`s are called and applied to the module first. 3. `Module.rng_init` methods are called last. Arguments: key: The seed to use for initialization. Returns: The new module with the fields initialized. \"\"\" if isinstance ( key , int ): key = jax . random . PRNGKey ( key ) def next_key () -> jnp . ndarray : nonlocal key assert isinstance ( key , ( np . ndarray , jnp . ndarray )) next_key , key = utils . iter_split ( key ) return next_key tree_out : M = jax . tree_map ( lambda initializer : ( initializer ( next_key ()) if isinstance ( initializer , types . Initializer ) else initializer ), self , is_leaf = lambda x : isinstance ( x , types . Initializer ), ) if inplace : # here we update initialized fields by the above tree_map tree_out = to . merge ( self , tree_out , inplace = True ) def call_module_init ( module : Module ): if isinstance ( module , Module ) and not module . _initialized : module . rng_init ( next_key ()) module . _initialized = True return to . apply ( call_module_init , tree_out , inplace = inplace ) logs ( self , * filters ) inherited Returns a copy of the Module with only tx.Log TreeParts, alias for filter(tx.Log) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/sequential.py def logs ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Log TreeParts, alias for `filter(tx.Log)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . Log , * filters ) losses ( self , * filters ) inherited Returns a copy of the Module with only tx.Loss TreeParts, alias for filter(tx.Loss) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/sequential.py def losses ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Loss TreeParts, alias for `filter(tx.Loss)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . LossLog , * filters ) map ( self , f , * filters , * , inplace = False , flatten_mode = None , is_leaf = None ) inherited map is a wrapper over treeo.map that passes self as the second argument. Parameters: Name Type Description Default f Callable The function to apply to the leaves. required *filters Filter The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treex/nn/sequential.py def map ( self : A , f : tp . Callable , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , is_leaf : tp . Callable [[ tp . Any ], bool ] = None , ) -> A : \"\"\" `map` is a wrapper over `treeo.map` that passes `self` as the second argument. Arguments: f: The function to apply to the leaves. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" return api . map ( f , self , * filters , inplace = inplace , flatten_mode = flatten_mode , is_leaf = is_leaf , ) merge ( self , other , * rest , * , inplace = False , flatten_mode = None , ignore_static = False ) inherited merge is a wrapper over treeo.merge that passes self as the first argument. Parameters: Name Type Description Default other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the merged values. If inplace is True , obj is returned. Source code in treex/nn/sequential.py def merge ( self : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" `merge` is a wrapper over `treeo.merge` that passes `self` as the first argument. Arguments: other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the merged values. If `inplace` is `True`, `obj` is returned. \"\"\" return api . merge ( self , other , * rest , inplace = inplace , flatten_mode = flatten_mode , ignore_static = ignore_static , ) metrics ( self , * filters ) inherited Returns a copy of the Module with only tx.Metric TreeParts, alias for filter(tx.Metric) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/sequential.py def metrics ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Metric TreeParts, alias for `filter(tx.Metric)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . MetricLog , * filters ) model_states ( self , * filters ) inherited Returns a copy of the Module with only tx.ModelState TreeParts, alias for filter(tx.ModelState) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/sequential.py def model_states ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.ModelState TreeParts, alias for `filter(tx.ModelState)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . ModelState , * filters ) parameters ( self , * filters ) inherited Returns a copy of the Module with only tx.Parameter TreeParts, alias for filter(tx.Parameter) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/sequential.py def parameters ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Parameter TreeParts, alias for `filter(tx.Parameter)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . Parameter , * filters ) rngs ( self , * filters ) inherited Returns a copy of the Module with only tx.Rng TreeParts, alias for filter(tx.Rng) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/sequential.py def rngs ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Rng TreeParts, alias for `filter(tx.Rng)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . Rng , * filters ) states ( self , * filters ) inherited Returns a copy of the Module with only tx.State TreeParts, alias for filter(tx.State) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/sequential.py def states ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.State TreeParts, alias for `filter(tx.State)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . State , * filters ) tabulate ( self , inputs = None , depth =- 1 , signature = False , param_types = True ) inherited Returns a tabular representation of the module. Parameters: Name Type Description Default depth int The maximum depth of the representation in terms of nested Modules, -1 means no limit. -1 signature bool Whether to show the signature of the Module. False param_types bool Whether to show the types of the parameters. True Returns: Type Description str A string containing the tabular representation. Source code in treex/nn/sequential.py def tabulate ( self , inputs : tp . Union [ tp . Any , types . Inputs , None ] = None , depth : int = - 1 , signature : bool = False , param_types : bool = True , ) -> str : \"\"\" Returns a tabular representation of the module. Arguments: depth: The maximum depth of the representation in terms of nested Modules, -1 means no limit. signature: Whether to show the signature of the Module. param_types: Whether to show the types of the parameters. Returns: A string containing the tabular representation. \"\"\" self = to . copy ( self ) if inputs is not None : if not isinstance ( inputs , types . Inputs ): inputs = types . Inputs ( inputs ) inputs = tp . cast ( types . Inputs , inputs ) if not isinstance ( self , tp . Callable ): raise TypeError ( \"`inputs` can only be specified if the module is a callable.\" ) with _Context ( call_info = {}): # call using self to preserve references def eval_call ( args , kwargs ): assert isinstance ( self , tp . Callable ) return self ( * args , ** kwargs ) jax . eval_shape ( eval_call , inputs . args , inputs . kwargs , ) call_info = _CONTEXT . call_info else : call_info = None with to . add_field_info (): flat : tp . List [ to . FieldInfo ] flat , _ = jax . tree_flatten ( self ) tree_part_types : tp . Tuple [ tp . Type [ types . TreePart ], ... ] = tuple ( { field_info . kind for field_info in flat if utils . _generic_issubclass ( field_info . kind , types . TreePart ) } ) path = () rows = list ( utils . _get_tabulate_rows ( path , self , depth , tree_part_types , signature , param_types ) ) modules = [ row [ 0 ] for row in rows ] rows = [ row [ 1 :] for row in rows ] if call_info is not None : for module , row in zip ( modules , rows ): if module in call_info : inputs , outputs = call_info [ module ] simplified_inputs = ( inputs . args [ 0 ] if len ( inputs . kwargs ) == 0 and len ( inputs . args ) == 1 else inputs . kwargs if len ( inputs . kwargs ) == 0 else inputs . kwargs if len ( inputs . args ) == 0 else ( inputs . args , inputs . kwargs ) ) inputs_repr = utils . _format_param_tree ( simplified_inputs ) outputs_repr = utils . _format_param_tree ( outputs ) else : inputs_repr = \"\" outputs_repr = \"\" row . insert ( 3 , outputs_repr ) row . insert ( 3 , inputs_repr ) n_non_treepart_cols = 2 if call_info is None else 4 rows [ 0 ][ 0 ] = \"*\" rows . append ( [ \"\" ] * n_non_treepart_cols + [ \"Total:\" ] + [ utils . _format_obj_size ( self . filter ( kind ), add_padding = True ) for kind in tree_part_types ] ) utils . _add_padding ( rows ) table = Table ( show_header = True , show_lines = True , show_footer = True , # box=rich.box.HORIZONTALS, ) table . add_column ( \"path\" ) table . add_column ( \"module\" ) table . add_column ( \"params\" ) if call_info is not None : table . add_column ( \"inputs\" ) table . add_column ( \"outputs\" ) for tree_part_type in tree_part_types : type_name = tree_part_type . __name__ if type_name . startswith ( \"_\" ): type_name = type_name [ 1 :] table . add_column ( type_name ) for row in rows [: - 1 ]: table . add_row ( * row ) table . columns [ n_non_treepart_cols ] . footer = Text . from_markup ( rows [ - 1 ][ n_non_treepart_cols ], justify = \"right\" ) for i in range ( len ( tree_part_types )): table . columns [ n_non_treepart_cols + 1 + i ] . footer = rows [ - 1 ][ n_non_treepart_cols + 1 + i ] table . caption_style = \"bold\" table . caption = \" \\n Total Parameters: \" + utils . _format_obj_size ( self , add_padding = False ) return utils . _get_rich_repr ( table ) to_dict ( self , * , private_fields = False , static_fields = True , type_info = False , field_info = False ) inherited to_dict is a wrapper over treeo.to_dict that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True type_info bool If True , type information is included. False field_info bool If True , field information is included. False Returns: Type Description Any A dict representation of the object. Source code in treex/nn/sequential.py def to_dict ( self , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : \"\"\" `to_dict` is a wrapper over `treeo.to_dict` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. type_info: If `True`, type information is included. field_info: If `True`, field information is included. Returns: A dict representation of the object. \"\"\" return api . to_dict ( self , private_fields = private_fields , static_fields = static_fields , type_info = type_info , field_info = field_info , ) to_string ( self , * , private_fields = False , static_fields = True , color = False ) inherited to_string is a wrapper over treeo.to_string that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True color bool If True , color is included. False Returns: Type Description str A string representation of the object. Source code in treex/nn/sequential.py def to_string ( self : A , * , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" `to_string` is a wrapper over `treeo.to_string` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. color: If `True`, color is included. Returns: A string representation of the object. \"\"\" return api . to_string ( self , private_fields = private_fields , static_fields = static_fields , color = color , ) train ( self , mode = True , inplace = False ) inherited Creates a new module with the same structure, but with Module.training set to the given value. Parameters: Name Type Description Default mode bool The new training mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~M The new module in with the training mode is set to the given value, if inplace is True then self is returned. Source code in treex/nn/sequential.py def train ( self : M , mode : bool = True , inplace : bool = False ) -> M : \"\"\" Creates a new module with the same structure, but with `Module.training` set to the given value. Arguments: mode: The new training mode. inplace: Whether to update the module inplace. Returns: The new module in with the training mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_training ( module : Module ): if isinstance ( module , Module ): module . _training = mode return to . apply ( set_training , self , inplace = inplace ) unfreeze ( self , inplace = False ) inherited Creates a new module with .frozen set to False, equivalent to calling freeze(False) . Parameters: Name Type Description Default inplace bool Whether to update the module inplace. False Returns: Type Description ~M The new module with .frozen set to False, if inplace is True then self is returned. Source code in treex/nn/sequential.py def unfreeze ( self : M , inplace : bool = False ) -> M : \"\"\" Creates a new module with `.frozen` set to False, equivalent to calling `freeze(False)`. Arguments: inplace: Whether to update the module inplace. Returns: The new module with `.frozen` set to False, if `inplace` is `True` then `self` is returned. \"\"\" return self . freeze ( False , inplace = inplace )","title":"Sequential"},{"location":"api/Sequential/#treexsequential","text":"A Module that applies a sequence of Modules or functions in order. Examples: mlp = tx . Sequential ( tx . Linear ( 2 , 32 ), jax . nn . relu , tx . Linear ( 32 , 8 ), jax . nn . relu , tx . Linear ( 8 , 4 ), ) . init ( 42 ) x = np . random . uniform ( size = ( 10 , 2 )) y = mlp ( x ) assert y . shape == ( 10 , 4 )","title":"treex.Sequential"},{"location":"api/Sequential/#treex.nn.sequential.Sequential.first_run","text":"Returns: Type Description bool True if its currently the first run of a compact method.","title":"first_run"},{"location":"api/Sequential/#treex.nn.sequential.Sequential.__class__","text":"","title":"__class__"},{"location":"api/Sequential/#treex.nn.sequential.Sequential.__class__.__base__","text":"Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()).","title":"__base__"},{"location":"api/Sequential/#treex.nn.sequential.Sequential.__class__.__base__.__instancecheck__","text":"Override for isinstance(instance, cls). Source code in treex/nn/sequential.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance )","title":"__instancecheck__()"},{"location":"api/Sequential/#treex.nn.sequential.Sequential.__class__.__base__.__new__","text":"Create and return a new object. See help(type) for accurate signature. Source code in treex/nn/sequential.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls","title":"__new__()"},{"location":"api/Sequential/#treex.nn.sequential.Sequential.__class__.__base__.__subclasscheck__","text":"Override for issubclass(subclass, cls). Source code in treex/nn/sequential.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass )","title":"__subclasscheck__()"},{"location":"api/Sequential/#treex.nn.sequential.Sequential.__class__.__base__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/sequential.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/Sequential/#treex.nn.sequential.Sequential.__class__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/sequential.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/Sequential/#treex.nn.sequential.Sequential.__init__","text":"Parameters: Name Type Description Default *layers Union[Callable[..., jax._src.numpy.lax_numpy.ndarray], Callable[[jax._src.numpy.lax_numpy.ndarray], jax._src.numpy.lax_numpy.ndarray]] A list of layers or callables to apply to apply in sequence. () Source code in treex/nn/sequential.py def __init__ ( self , * layers : tp . Union [ CallableModule , tp . Callable [[ jnp . ndarray ], jnp . ndarray ]] ): \"\"\" Arguments: *layers: A list of layers or callables to apply to apply in sequence. \"\"\" self . layers = [ layer if isinstance ( layer , Module ) else Lambda ( layer ) for layer in layers ]","title":"__init__()"},{"location":"api/Sequential/#treex.nn.sequential.Sequential.apply","text":"apply is a wrapper over treeo.apply that passes self as the second argument. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treex/nn/sequential.py def apply ( self : A , f : tp . Callable [ ... , None ], * rest : A , inplace : bool = False ) -> A : \"\"\" `apply` is a wrapper over `treeo.apply` that passes `self` as the second argument. Arguments: f: The function to apply. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" return api . apply ( f , self , * rest , inplace = inplace )","title":"apply()"},{"location":"api/Sequential/#treex.nn.sequential.Sequential.batch_stats","text":"Returns a copy of the Module with only tx.BatchStat TreeParts, alias for filter(tx.BatchStat) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/sequential.py def batch_stats ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.BatchStat TreeParts, alias for `filter(tx.BatchStat)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . BatchStat , * filters )","title":"batch_stats()"},{"location":"api/Sequential/#treex.nn.sequential.Sequential.check_metadata_updates","text":"Checks for new fields, if found, adds them to the metadata. Source code in treex/nn/sequential.py def check_metadata_updates ( self ): \"\"\" Checks for new fields, if found, adds them to the metadata. \"\"\" with _CONTEXT . update ( flatten_mode = FlattenMode . all_fields ): jax . tree_flatten ( self )","title":"check_metadata_updates()"},{"location":"api/Sequential/#treex.nn.sequential.Sequential.copy","text":"copy is a wrapper over treeo.copy that passes self as the first argument. Source code in treex/nn/sequential.py def copy ( self : A ) -> A : \"\"\" `copy` is a wrapper over `treeo.copy` that passes `self` as the first argument. \"\"\" return tree_m . copy ( self )","title":"copy()"},{"location":"api/Sequential/#treex.nn.sequential.Sequential.eval","text":"Creates a new module with the training mode set to False, equivalent to calling train(False) . Returns: Type Description ~M The new module with the training mode set to False. Source code in treex/nn/sequential.py def eval ( self : M , inplace : bool = False ) -> M : \"\"\" Creates a new module with the training mode set to False, equivalent to calling `train(False)`. Returns: The new module with the training mode set to False. \"\"\" return self . train ( False , inplace = inplace )","title":"eval()"},{"location":"api/Sequential/#treex.nn.sequential.Sequential.filter","text":"filter is a wrapper over treeo.filter that passes self as the first argument. Parameters: Name Type Description Default *filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treex/nn/sequential.py def filter ( self : A , * filters : api . Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ) -> A : \"\"\" `filter` is a wrapper over `treeo.filter` that passes `self` as the first argument. Arguments: *filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" return api . filter ( self , * filters , inplace = inplace , flatten_mode = flatten_mode )","title":"filter()"},{"location":"api/Sequential/#treex.nn.sequential.Sequential.freeze","text":"Creates a new module with the same structure, but with Module.frozen set to the given value. Parameters: Name Type Description Default mode bool The new frozen mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~M The new module in with the frozen mode is set to the given value, if inplace is True then self is returned. Source code in treex/nn/sequential.py def freeze ( self : M , mode : bool = True , inplace : bool = False ) -> M : \"\"\" Creates a new module with the same structure, but with `Module.frozen` set to the given value. Arguments: mode: The new `frozen` mode. inplace: Whether to update the module inplace. Returns: The new module in with the `frozen` mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_frozen ( module : Module ): if isinstance ( module , Module ): module . _frozen = mode return to . apply ( set_frozen , self , inplace = inplace )","title":"freeze()"},{"location":"api/Sequential/#treex.nn.sequential.Sequential.get_field","text":"A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: The field must be declared in the class definition. The method can only be called inside a compact context. Parameters: Name Type Description Default field_name str The name of the field to get. required initializer Callable[[], ~A] The function to initialize the field if it does not exist. required Returns: Type Description ~A The field value. Source code in treex/nn/sequential.py def get_field ( self , field_name : str , initializer : tp . Callable [[], A ], ) -> A : \"\"\" A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: * The field must be declared in the class definition. * The method can only be called inside a `compact` context. Arguments: field_name: The name of the field to get. initializer: The function to initialize the field if it does not exist. Returns: The field value. \"\"\" value : A if field_name not in self . _field_metadata : raise ValueError ( f \"Metadata for field ' { field_name } ' does not exist.\" ) if tree_m . _COMPACT_CONTEXT . current_tree is not self : raise RuntimeError ( f \"Object ' { type ( self ) . __name__ } ' is not the current tree, found ' { type ( tree_m . _COMPACT_CONTEXT . current_tree ) . __name__ } ', did you forget the @compact decorator?\" ) if field_name in vars ( self ): value = getattr ( self , field_name ) else : if tree_m . _COMPACT_CONTEXT . in_compact and not self . first_run : raise RuntimeError ( f \"Trying to initialize field ' { field_name } ' after the first run of `compact`.\" ) value = initializer () setattr ( self , field_name , value ) return value","title":"get_field()"},{"location":"api/Sequential/#treex.nn.sequential.Sequential.init","text":"Method version of tx.init , it applies self as first argument. init creates a new module with the same structure, but with its fields initialized given a seed key . The following procedure is used: The input key is split and iteratively updated before passing a derived value to any process that requires initialization. Initializer s are called and applied to the module first. Module.rng_init methods are called last. Parameters: Name Type Description Default key Union[int, jax._src.numpy.lax_numpy.ndarray] The seed to use for initialization. required Returns: Type Description ~M The new module with the fields initialized. Source code in treex/nn/sequential.py def init ( self : M , key : tp . Union [ int , jnp . ndarray ], inplace : bool = False ) -> M : \"\"\" Method version of `tx.init`, it applies `self` as first argument. `init` creates a new module with the same structure, but with its fields initialized given a seed `key`. The following procedure is used: 1. The input `key` is split and iteratively updated before passing a derived value to any process that requires initialization. 2. `Initializer`s are called and applied to the module first. 3. `Module.rng_init` methods are called last. Arguments: key: The seed to use for initialization. Returns: The new module with the fields initialized. \"\"\" if isinstance ( key , int ): key = jax . random . PRNGKey ( key ) def next_key () -> jnp . ndarray : nonlocal key assert isinstance ( key , ( np . ndarray , jnp . ndarray )) next_key , key = utils . iter_split ( key ) return next_key tree_out : M = jax . tree_map ( lambda initializer : ( initializer ( next_key ()) if isinstance ( initializer , types . Initializer ) else initializer ), self , is_leaf = lambda x : isinstance ( x , types . Initializer ), ) if inplace : # here we update initialized fields by the above tree_map tree_out = to . merge ( self , tree_out , inplace = True ) def call_module_init ( module : Module ): if isinstance ( module , Module ) and not module . _initialized : module . rng_init ( next_key ()) module . _initialized = True return to . apply ( call_module_init , tree_out , inplace = inplace )","title":"init()"},{"location":"api/Sequential/#treex.nn.sequential.Sequential.logs","text":"Returns a copy of the Module with only tx.Log TreeParts, alias for filter(tx.Log) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/sequential.py def logs ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Log TreeParts, alias for `filter(tx.Log)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . Log , * filters )","title":"logs()"},{"location":"api/Sequential/#treex.nn.sequential.Sequential.losses","text":"Returns a copy of the Module with only tx.Loss TreeParts, alias for filter(tx.Loss) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/sequential.py def losses ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Loss TreeParts, alias for `filter(tx.Loss)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . LossLog , * filters )","title":"losses()"},{"location":"api/Sequential/#treex.nn.sequential.Sequential.map","text":"map is a wrapper over treeo.map that passes self as the second argument. Parameters: Name Type Description Default f Callable The function to apply to the leaves. required *filters Filter The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treex/nn/sequential.py def map ( self : A , f : tp . Callable , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , is_leaf : tp . Callable [[ tp . Any ], bool ] = None , ) -> A : \"\"\" `map` is a wrapper over `treeo.map` that passes `self` as the second argument. Arguments: f: The function to apply to the leaves. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" return api . map ( f , self , * filters , inplace = inplace , flatten_mode = flatten_mode , is_leaf = is_leaf , )","title":"map()"},{"location":"api/Sequential/#treex.nn.sequential.Sequential.merge","text":"merge is a wrapper over treeo.merge that passes self as the first argument. Parameters: Name Type Description Default other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the merged values. If inplace is True , obj is returned. Source code in treex/nn/sequential.py def merge ( self : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" `merge` is a wrapper over `treeo.merge` that passes `self` as the first argument. Arguments: other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the merged values. If `inplace` is `True`, `obj` is returned. \"\"\" return api . merge ( self , other , * rest , inplace = inplace , flatten_mode = flatten_mode , ignore_static = ignore_static , )","title":"merge()"},{"location":"api/Sequential/#treex.nn.sequential.Sequential.metrics","text":"Returns a copy of the Module with only tx.Metric TreeParts, alias for filter(tx.Metric) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/sequential.py def metrics ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Metric TreeParts, alias for `filter(tx.Metric)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . MetricLog , * filters )","title":"metrics()"},{"location":"api/Sequential/#treex.nn.sequential.Sequential.model_states","text":"Returns a copy of the Module with only tx.ModelState TreeParts, alias for filter(tx.ModelState) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/sequential.py def model_states ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.ModelState TreeParts, alias for `filter(tx.ModelState)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . ModelState , * filters )","title":"model_states()"},{"location":"api/Sequential/#treex.nn.sequential.Sequential.parameters","text":"Returns a copy of the Module with only tx.Parameter TreeParts, alias for filter(tx.Parameter) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/sequential.py def parameters ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Parameter TreeParts, alias for `filter(tx.Parameter)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . Parameter , * filters )","title":"parameters()"},{"location":"api/Sequential/#treex.nn.sequential.Sequential.rngs","text":"Returns a copy of the Module with only tx.Rng TreeParts, alias for filter(tx.Rng) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/sequential.py def rngs ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.Rng TreeParts, alias for `filter(tx.Rng)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . Rng , * filters )","title":"rngs()"},{"location":"api/Sequential/#treex.nn.sequential.Sequential.states","text":"Returns a copy of the Module with only tx.State TreeParts, alias for filter(tx.State) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/sequential.py def states ( self : M , * filters : Filter ) -> M : \"\"\" Returns a copy of the Module with only tx.State TreeParts, alias for `filter(tx.State)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return self . filter ( types . State , * filters )","title":"states()"},{"location":"api/Sequential/#treex.nn.sequential.Sequential.tabulate","text":"Returns a tabular representation of the module. Parameters: Name Type Description Default depth int The maximum depth of the representation in terms of nested Modules, -1 means no limit. -1 signature bool Whether to show the signature of the Module. False param_types bool Whether to show the types of the parameters. True Returns: Type Description str A string containing the tabular representation. Source code in treex/nn/sequential.py def tabulate ( self , inputs : tp . Union [ tp . Any , types . Inputs , None ] = None , depth : int = - 1 , signature : bool = False , param_types : bool = True , ) -> str : \"\"\" Returns a tabular representation of the module. Arguments: depth: The maximum depth of the representation in terms of nested Modules, -1 means no limit. signature: Whether to show the signature of the Module. param_types: Whether to show the types of the parameters. Returns: A string containing the tabular representation. \"\"\" self = to . copy ( self ) if inputs is not None : if not isinstance ( inputs , types . Inputs ): inputs = types . Inputs ( inputs ) inputs = tp . cast ( types . Inputs , inputs ) if not isinstance ( self , tp . Callable ): raise TypeError ( \"`inputs` can only be specified if the module is a callable.\" ) with _Context ( call_info = {}): # call using self to preserve references def eval_call ( args , kwargs ): assert isinstance ( self , tp . Callable ) return self ( * args , ** kwargs ) jax . eval_shape ( eval_call , inputs . args , inputs . kwargs , ) call_info = _CONTEXT . call_info else : call_info = None with to . add_field_info (): flat : tp . List [ to . FieldInfo ] flat , _ = jax . tree_flatten ( self ) tree_part_types : tp . Tuple [ tp . Type [ types . TreePart ], ... ] = tuple ( { field_info . kind for field_info in flat if utils . _generic_issubclass ( field_info . kind , types . TreePart ) } ) path = () rows = list ( utils . _get_tabulate_rows ( path , self , depth , tree_part_types , signature , param_types ) ) modules = [ row [ 0 ] for row in rows ] rows = [ row [ 1 :] for row in rows ] if call_info is not None : for module , row in zip ( modules , rows ): if module in call_info : inputs , outputs = call_info [ module ] simplified_inputs = ( inputs . args [ 0 ] if len ( inputs . kwargs ) == 0 and len ( inputs . args ) == 1 else inputs . kwargs if len ( inputs . kwargs ) == 0 else inputs . kwargs if len ( inputs . args ) == 0 else ( inputs . args , inputs . kwargs ) ) inputs_repr = utils . _format_param_tree ( simplified_inputs ) outputs_repr = utils . _format_param_tree ( outputs ) else : inputs_repr = \"\" outputs_repr = \"\" row . insert ( 3 , outputs_repr ) row . insert ( 3 , inputs_repr ) n_non_treepart_cols = 2 if call_info is None else 4 rows [ 0 ][ 0 ] = \"*\" rows . append ( [ \"\" ] * n_non_treepart_cols + [ \"Total:\" ] + [ utils . _format_obj_size ( self . filter ( kind ), add_padding = True ) for kind in tree_part_types ] ) utils . _add_padding ( rows ) table = Table ( show_header = True , show_lines = True , show_footer = True , # box=rich.box.HORIZONTALS, ) table . add_column ( \"path\" ) table . add_column ( \"module\" ) table . add_column ( \"params\" ) if call_info is not None : table . add_column ( \"inputs\" ) table . add_column ( \"outputs\" ) for tree_part_type in tree_part_types : type_name = tree_part_type . __name__ if type_name . startswith ( \"_\" ): type_name = type_name [ 1 :] table . add_column ( type_name ) for row in rows [: - 1 ]: table . add_row ( * row ) table . columns [ n_non_treepart_cols ] . footer = Text . from_markup ( rows [ - 1 ][ n_non_treepart_cols ], justify = \"right\" ) for i in range ( len ( tree_part_types )): table . columns [ n_non_treepart_cols + 1 + i ] . footer = rows [ - 1 ][ n_non_treepart_cols + 1 + i ] table . caption_style = \"bold\" table . caption = \" \\n Total Parameters: \" + utils . _format_obj_size ( self , add_padding = False ) return utils . _get_rich_repr ( table )","title":"tabulate()"},{"location":"api/Sequential/#treex.nn.sequential.Sequential.to_dict","text":"to_dict is a wrapper over treeo.to_dict that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True type_info bool If True , type information is included. False field_info bool If True , field information is included. False Returns: Type Description Any A dict representation of the object. Source code in treex/nn/sequential.py def to_dict ( self , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : \"\"\" `to_dict` is a wrapper over `treeo.to_dict` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. type_info: If `True`, type information is included. field_info: If `True`, field information is included. Returns: A dict representation of the object. \"\"\" return api . to_dict ( self , private_fields = private_fields , static_fields = static_fields , type_info = type_info , field_info = field_info , )","title":"to_dict()"},{"location":"api/Sequential/#treex.nn.sequential.Sequential.to_string","text":"to_string is a wrapper over treeo.to_string that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True color bool If True , color is included. False Returns: Type Description str A string representation of the object. Source code in treex/nn/sequential.py def to_string ( self : A , * , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" `to_string` is a wrapper over `treeo.to_string` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. color: If `True`, color is included. Returns: A string representation of the object. \"\"\" return api . to_string ( self , private_fields = private_fields , static_fields = static_fields , color = color , )","title":"to_string()"},{"location":"api/Sequential/#treex.nn.sequential.Sequential.train","text":"Creates a new module with the same structure, but with Module.training set to the given value. Parameters: Name Type Description Default mode bool The new training mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~M The new module in with the training mode is set to the given value, if inplace is True then self is returned. Source code in treex/nn/sequential.py def train ( self : M , mode : bool = True , inplace : bool = False ) -> M : \"\"\" Creates a new module with the same structure, but with `Module.training` set to the given value. Arguments: mode: The new training mode. inplace: Whether to update the module inplace. Returns: The new module in with the training mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_training ( module : Module ): if isinstance ( module , Module ): module . _training = mode return to . apply ( set_training , self , inplace = inplace )","title":"train()"},{"location":"api/Sequential/#treex.nn.sequential.Sequential.unfreeze","text":"Creates a new module with .frozen set to False, equivalent to calling freeze(False) . Parameters: Name Type Description Default inplace bool Whether to update the module inplace. False Returns: Type Description ~M The new module with .frozen set to False, if inplace is True then self is returned. Source code in treex/nn/sequential.py def unfreeze ( self : M , inplace : bool = False ) -> M : \"\"\" Creates a new module with `.frozen` set to False, equivalent to calling `freeze(False)`. Arguments: inplace: Whether to update the module inplace. Returns: The new module with `.frozen` set to False, if `inplace` is `True` then `self` is returned. \"\"\" return self . freeze ( False , inplace = inplace )","title":"unfreeze()"},{"location":"api/State/","text":"treex.State","title":"State"},{"location":"api/State/#treexstate","text":"","title":"treex.State"},{"location":"api/ToDict/","text":"treex.ToDict Mixin that adds a .to_dict() method to the class. to_dict ( self , * , private_fields = False , static_fields = True , type_info = False , field_info = False ) to_dict is a wrapper over treeo.to_dict that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True type_info bool If True , type information is included. False field_info bool If True , field information is included. False Returns: Type Description Any A dict representation of the object. Source code in treeo/mixins.py def to_dict ( self , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : \"\"\" `to_dict` is a wrapper over `treeo.to_dict` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. type_info: If `True`, type information is included. field_info: If `True`, field information is included. Returns: A dict representation of the object. \"\"\" return api . to_dict ( self , private_fields = private_fields , static_fields = static_fields , type_info = type_info , field_info = field_info , )","title":"ToDict"},{"location":"api/ToDict/#treextodict","text":"Mixin that adds a .to_dict() method to the class.","title":"treex.ToDict"},{"location":"api/ToDict/#treeo.mixins.ToDict.to_dict","text":"to_dict is a wrapper over treeo.to_dict that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True type_info bool If True , type information is included. False field_info bool If True , field information is included. False Returns: Type Description Any A dict representation of the object. Source code in treeo/mixins.py def to_dict ( self , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : \"\"\" `to_dict` is a wrapper over `treeo.to_dict` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. type_info: If `True`, type information is included. field_info: If `True`, field information is included. Returns: A dict representation of the object. \"\"\" return api . to_dict ( self , private_fields = private_fields , static_fields = static_fields , type_info = type_info , field_info = field_info , )","title":"to_dict()"},{"location":"api/ToString/","text":"treex.ToString Mixin that adds a .to_string() method to the class. to_string ( self , * , private_fields = False , static_fields = True , color = False ) to_string is a wrapper over treeo.to_string that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True color bool If True , color is included. False Returns: Type Description str A string representation of the object. Source code in treeo/mixins.py def to_string ( self : A , * , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" `to_string` is a wrapper over `treeo.to_string` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. color: If `True`, color is included. Returns: A string representation of the object. \"\"\" return api . to_string ( self , private_fields = private_fields , static_fields = static_fields , color = color , )","title":"ToString"},{"location":"api/ToString/#treextostring","text":"Mixin that adds a .to_string() method to the class.","title":"treex.ToString"},{"location":"api/ToString/#treeo.mixins.ToString.to_string","text":"to_string is a wrapper over treeo.to_string that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True color bool If True , color is included. False Returns: Type Description str A string representation of the object. Source code in treeo/mixins.py def to_string ( self : A , * , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" `to_string` is a wrapper over `treeo.to_string` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. color: If `True`, color is included. Returns: A string representation of the object. \"\"\" return api . to_string ( self , private_fields = private_fields , static_fields = static_fields , color = color , )","title":"to_string()"},{"location":"api/Tree/","text":"treex.Tree __class__ inherited __base__ inherited Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()). __instancecheck__ ( cls , instance ) special Override for isinstance(instance, cls). Source code in treeo/tree.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance ) __new__ ( mcls , name , bases , namespace , ** kwargs ) special staticmethod Create and return a new object. See help(type) for accurate signature. Source code in treeo/tree.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls __subclasscheck__ ( cls , subclass ) special Override for issubclass(subclass, cls). Source code in treeo/tree.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass ) register ( cls , subclass ) Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treeo/tree.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) register ( cls , subclass ) inherited Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treeo/tree.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) __init_subclass__ () classmethod special This method is called when a class is subclassed. The default implementation does nothing. It may be overridden to extend subclasses. Source code in treeo/tree.py def __init_subclass__ ( cls ): jax . tree_util . register_pytree_node_class ( cls ) # Restore the signature sig = inspect . signature ( cls . __init__ ) parameters = tuple ( sig . parameters . values ()) cls . __signature__ = sig . replace ( parameters = parameters [ 1 :]) annotations = utils . _get_all_annotations ( cls ) class_vars = utils . _get_all_vars ( cls ) # init class variables cls . _field_metadata = {} cls . _factory_fields = {} cls . _default_field_values = {} cls . _subtrees = None for field , value in class_vars . items (): if isinstance ( value , dataclasses . Field ): # save defaults if value . default is not dataclasses . MISSING : cls . _default_field_values [ field ] = value . default elif value . default_factory is not dataclasses . MISSING : cls . _factory_fields [ field ] = value . default_factory # extract metadata if value . metadata is not None and \"node\" in value . metadata : cls . _field_metadata [ field ] = types . FieldMetadata ( node = value . metadata [ \"node\" ], kind = value . metadata [ \"kind\" ], opaque = value . metadata [ \"opaque\" ], ) for field , value in annotations . items (): if field not in cls . _field_metadata : is_node = any ( issubclass ( t , Tree ) for t in utils . _all_types ( value )) cls . _field_metadata [ field ] = types . FieldMetadata ( node = is_node , kind = type ( None ), opaque = False , ) check_metadata_updates ( self ) Checks for new fields, if found, adds them to the metadata. Source code in treeo/tree.py def check_metadata_updates ( self ): \"\"\" Checks for new fields, if found, adds them to the metadata. \"\"\" with _CONTEXT . update ( flatten_mode = FlattenMode . all_fields ): jax . tree_flatten ( self )","title":"Tree"},{"location":"api/Tree/#treextree","text":"","title":"treex.Tree"},{"location":"api/Tree/#treeo.tree.Tree.__class__","text":"","title":"__class__"},{"location":"api/Tree/#treeo.tree.Tree.__class__.__base__","text":"Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()).","title":"__base__"},{"location":"api/Tree/#treeo.tree.Tree.__class__.__base__.__instancecheck__","text":"Override for isinstance(instance, cls). Source code in treeo/tree.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance )","title":"__instancecheck__()"},{"location":"api/Tree/#treeo.tree.Tree.__class__.__base__.__new__","text":"Create and return a new object. See help(type) for accurate signature. Source code in treeo/tree.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls","title":"__new__()"},{"location":"api/Tree/#treeo.tree.Tree.__class__.__base__.__subclasscheck__","text":"Override for issubclass(subclass, cls). Source code in treeo/tree.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass )","title":"__subclasscheck__()"},{"location":"api/Tree/#treeo.tree.Tree.__class__.__base__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treeo/tree.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/Tree/#treeo.tree.Tree.__class__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treeo/tree.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/Tree/#treeo.tree.Tree.__init_subclass__","text":"This method is called when a class is subclassed. The default implementation does nothing. It may be overridden to extend subclasses. Source code in treeo/tree.py def __init_subclass__ ( cls ): jax . tree_util . register_pytree_node_class ( cls ) # Restore the signature sig = inspect . signature ( cls . __init__ ) parameters = tuple ( sig . parameters . values ()) cls . __signature__ = sig . replace ( parameters = parameters [ 1 :]) annotations = utils . _get_all_annotations ( cls ) class_vars = utils . _get_all_vars ( cls ) # init class variables cls . _field_metadata = {} cls . _factory_fields = {} cls . _default_field_values = {} cls . _subtrees = None for field , value in class_vars . items (): if isinstance ( value , dataclasses . Field ): # save defaults if value . default is not dataclasses . MISSING : cls . _default_field_values [ field ] = value . default elif value . default_factory is not dataclasses . MISSING : cls . _factory_fields [ field ] = value . default_factory # extract metadata if value . metadata is not None and \"node\" in value . metadata : cls . _field_metadata [ field ] = types . FieldMetadata ( node = value . metadata [ \"node\" ], kind = value . metadata [ \"kind\" ], opaque = value . metadata [ \"opaque\" ], ) for field , value in annotations . items (): if field not in cls . _field_metadata : is_node = any ( issubclass ( t , Tree ) for t in utils . _all_types ( value )) cls . _field_metadata [ field ] = types . FieldMetadata ( node = is_node , kind = type ( None ), opaque = False , )","title":"__init_subclass__()"},{"location":"api/Tree/#treeo.tree.Tree.check_metadata_updates","text":"Checks for new fields, if found, adds them to the metadata. Source code in treeo/tree.py def check_metadata_updates ( self ): \"\"\" Checks for new fields, if found, adds them to the metadata. \"\"\" with _CONTEXT . update ( flatten_mode = FlattenMode . all_fields ): jax . tree_flatten ( self )","title":"check_metadata_updates()"},{"location":"api/TreeMeta/","text":"treex.TreeMeta __base__ inherited Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()). __instancecheck__ ( cls , instance ) special Override for isinstance(instance, cls). Source code in treeo/tree.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance ) __new__ ( mcls , name , bases , namespace , ** kwargs ) special staticmethod Create and return a new object. See help(type) for accurate signature. Source code in treeo/tree.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls __subclasscheck__ ( cls , subclass ) special Override for issubclass(subclass, cls). Source code in treeo/tree.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass ) register ( cls , subclass ) Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treeo/tree.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) register ( cls , subclass ) inherited Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treeo/tree.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"TreeMeta"},{"location":"api/TreeMeta/#treextreemeta","text":"","title":"treex.TreeMeta"},{"location":"api/TreeMeta/#treeo.tree.TreeMeta.__base__","text":"Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()).","title":"__base__"},{"location":"api/TreeMeta/#treeo.tree.TreeMeta.__base__.__instancecheck__","text":"Override for isinstance(instance, cls). Source code in treeo/tree.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance )","title":"__instancecheck__()"},{"location":"api/TreeMeta/#treeo.tree.TreeMeta.__base__.__new__","text":"Create and return a new object. See help(type) for accurate signature. Source code in treeo/tree.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls","title":"__new__()"},{"location":"api/TreeMeta/#treeo.tree.TreeMeta.__base__.__subclasscheck__","text":"Override for issubclass(subclass, cls). Source code in treeo/tree.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass )","title":"__subclasscheck__()"},{"location":"api/TreeMeta/#treeo.tree.TreeMeta.__base__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treeo/tree.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/TreeMeta/#treeo.tree.TreeMeta.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treeo/tree.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/TreePart/","text":"treex.TreePart","title":"TreePart"},{"location":"api/TreePart/#treextreepart","text":"","title":"treex.TreePart"},{"location":"api/Treex/","text":"treex.Treex A Tree class with all Mixin Extensions. Base class for all Treex classes. first_run : bool inherited property readonly Returns: Type Description bool True if its currently the first run of a compact method. __class__ inherited __base__ inherited Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()). __instancecheck__ ( cls , instance ) special Override for isinstance(instance, cls). Source code in treex/treex.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance ) __new__ ( mcls , name , bases , namespace , ** kwargs ) special staticmethod Create and return a new object. See help(type) for accurate signature. Source code in treex/treex.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls __subclasscheck__ ( cls , subclass ) special Override for issubclass(subclass, cls). Source code in treex/treex.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass ) register ( cls , subclass ) Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/treex.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) register ( cls , subclass ) inherited Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/treex.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) __repr__ ( self ) inherited special Uses treeo.to_string to generate a string representation of the object. Source code in treex/treex.py def __repr__ ( self ) -> tp . Any : \"\"\" Uses `treeo.to_string` to generate a string representation of the object. \"\"\" return api . to_string ( self , private_fields = False , static_fields = True , color = False , ) apply ( self , f , * rest , * , inplace = False ) inherited apply is a wrapper over treeo.apply that passes self as the second argument. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treex/treex.py def apply ( self : A , f : tp . Callable [ ... , None ], * rest : A , inplace : bool = False ) -> A : \"\"\" `apply` is a wrapper over `treeo.apply` that passes `self` as the second argument. Arguments: f: The function to apply. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" return api . apply ( f , self , * rest , inplace = inplace ) check_metadata_updates ( self ) inherited Checks for new fields, if found, adds them to the metadata. Source code in treex/treex.py def check_metadata_updates ( self ): \"\"\" Checks for new fields, if found, adds them to the metadata. \"\"\" with _CONTEXT . update ( flatten_mode = FlattenMode . all_fields ): jax . tree_flatten ( self ) copy ( self ) inherited copy is a wrapper over treeo.copy that passes self as the first argument. Source code in treex/treex.py def copy ( self : A ) -> A : \"\"\" `copy` is a wrapper over `treeo.copy` that passes `self` as the first argument. \"\"\" return tree_m . copy ( self ) filter ( self , * filters , * , inplace = False , flatten_mode = None ) inherited filter is a wrapper over treeo.filter that passes self as the first argument. Parameters: Name Type Description Default *filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treex/treex.py def filter ( self : A , * filters : api . Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ) -> A : \"\"\" `filter` is a wrapper over `treeo.filter` that passes `self` as the first argument. Arguments: *filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" return api . filter ( self , * filters , inplace = inplace , flatten_mode = flatten_mode ) get_field ( self , field_name , initializer ) inherited A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: The field must be declared in the class definition. The method can only be called inside a compact context. Parameters: Name Type Description Default field_name str The name of the field to get. required initializer Callable[[], ~A] The function to initialize the field if it does not exist. required Returns: Type Description ~A The field value. Source code in treex/treex.py def get_field ( self , field_name : str , initializer : tp . Callable [[], A ], ) -> A : \"\"\" A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: * The field must be declared in the class definition. * The method can only be called inside a `compact` context. Arguments: field_name: The name of the field to get. initializer: The function to initialize the field if it does not exist. Returns: The field value. \"\"\" value : A if field_name not in self . _field_metadata : raise ValueError ( f \"Metadata for field ' { field_name } ' does not exist.\" ) if tree_m . _COMPACT_CONTEXT . current_tree is not self : raise RuntimeError ( f \"Object ' { type ( self ) . __name__ } ' is not the current tree, found ' { type ( tree_m . _COMPACT_CONTEXT . current_tree ) . __name__ } ', did you forget the @compact decorator?\" ) if field_name in vars ( self ): value = getattr ( self , field_name ) else : if tree_m . _COMPACT_CONTEXT . in_compact and not self . first_run : raise RuntimeError ( f \"Trying to initialize field ' { field_name } ' after the first run of `compact`.\" ) value = initializer () setattr ( self , field_name , value ) return value map ( self , f , * filters , * , inplace = False , flatten_mode = None , is_leaf = None ) inherited map is a wrapper over treeo.map that passes self as the second argument. Parameters: Name Type Description Default f Callable The function to apply to the leaves. required *filters Filter The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treex/treex.py def map ( self : A , f : tp . Callable , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , is_leaf : tp . Callable [[ tp . Any ], bool ] = None , ) -> A : \"\"\" `map` is a wrapper over `treeo.map` that passes `self` as the second argument. Arguments: f: The function to apply to the leaves. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" return api . map ( f , self , * filters , inplace = inplace , flatten_mode = flatten_mode , is_leaf = is_leaf , ) merge ( self , other , * rest , * , inplace = False , flatten_mode = None , ignore_static = False ) inherited merge is a wrapper over treeo.merge that passes self as the first argument. Parameters: Name Type Description Default other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the merged values. If inplace is True , obj is returned. Source code in treex/treex.py def merge ( self : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" `merge` is a wrapper over `treeo.merge` that passes `self` as the first argument. Arguments: other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the merged values. If `inplace` is `True`, `obj` is returned. \"\"\" return api . merge ( self , other , * rest , inplace = inplace , flatten_mode = flatten_mode , ignore_static = ignore_static , ) to_dict ( self , * , private_fields = False , static_fields = True , type_info = False , field_info = False ) inherited to_dict is a wrapper over treeo.to_dict that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True type_info bool If True , type information is included. False field_info bool If True , field information is included. False Returns: Type Description Any A dict representation of the object. Source code in treex/treex.py def to_dict ( self , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : \"\"\" `to_dict` is a wrapper over `treeo.to_dict` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. type_info: If `True`, type information is included. field_info: If `True`, field information is included. Returns: A dict representation of the object. \"\"\" return api . to_dict ( self , private_fields = private_fields , static_fields = static_fields , type_info = type_info , field_info = field_info , ) to_string ( self , * , private_fields = False , static_fields = True , color = False ) inherited to_string is a wrapper over treeo.to_string that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True color bool If True , color is included. False Returns: Type Description str A string representation of the object. Source code in treex/treex.py def to_string ( self : A , * , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" `to_string` is a wrapper over `treeo.to_string` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. color: If `True`, color is included. Returns: A string representation of the object. \"\"\" return api . to_string ( self , private_fields = private_fields , static_fields = static_fields , color = color , )","title":"Treex"},{"location":"api/Treex/#treextreex","text":"A Tree class with all Mixin Extensions. Base class for all Treex classes.","title":"treex.Treex"},{"location":"api/Treex/#treex.treex.Treex.first_run","text":"Returns: Type Description bool True if its currently the first run of a compact method.","title":"first_run"},{"location":"api/Treex/#treex.treex.Treex.__class__","text":"","title":"__class__"},{"location":"api/Treex/#treex.treex.Treex.__class__.__base__","text":"Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()).","title":"__base__"},{"location":"api/Treex/#treex.treex.Treex.__class__.__base__.__instancecheck__","text":"Override for isinstance(instance, cls). Source code in treex/treex.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance )","title":"__instancecheck__()"},{"location":"api/Treex/#treex.treex.Treex.__class__.__base__.__new__","text":"Create and return a new object. See help(type) for accurate signature. Source code in treex/treex.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls","title":"__new__()"},{"location":"api/Treex/#treex.treex.Treex.__class__.__base__.__subclasscheck__","text":"Override for issubclass(subclass, cls). Source code in treex/treex.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass )","title":"__subclasscheck__()"},{"location":"api/Treex/#treex.treex.Treex.__class__.__base__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/treex.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/Treex/#treex.treex.Treex.__class__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/treex.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/Treex/#treex.treex.Treex.__repr__","text":"Uses treeo.to_string to generate a string representation of the object. Source code in treex/treex.py def __repr__ ( self ) -> tp . Any : \"\"\" Uses `treeo.to_string` to generate a string representation of the object. \"\"\" return api . to_string ( self , private_fields = False , static_fields = True , color = False , )","title":"__repr__()"},{"location":"api/Treex/#treex.treex.Treex.apply","text":"apply is a wrapper over treeo.apply that passes self as the second argument. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treex/treex.py def apply ( self : A , f : tp . Callable [ ... , None ], * rest : A , inplace : bool = False ) -> A : \"\"\" `apply` is a wrapper over `treeo.apply` that passes `self` as the second argument. Arguments: f: The function to apply. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" return api . apply ( f , self , * rest , inplace = inplace )","title":"apply()"},{"location":"api/Treex/#treex.treex.Treex.check_metadata_updates","text":"Checks for new fields, if found, adds them to the metadata. Source code in treex/treex.py def check_metadata_updates ( self ): \"\"\" Checks for new fields, if found, adds them to the metadata. \"\"\" with _CONTEXT . update ( flatten_mode = FlattenMode . all_fields ): jax . tree_flatten ( self )","title":"check_metadata_updates()"},{"location":"api/Treex/#treex.treex.Treex.copy","text":"copy is a wrapper over treeo.copy that passes self as the first argument. Source code in treex/treex.py def copy ( self : A ) -> A : \"\"\" `copy` is a wrapper over `treeo.copy` that passes `self` as the first argument. \"\"\" return tree_m . copy ( self )","title":"copy()"},{"location":"api/Treex/#treex.treex.Treex.filter","text":"filter is a wrapper over treeo.filter that passes self as the first argument. Parameters: Name Type Description Default *filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treex/treex.py def filter ( self : A , * filters : api . Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ) -> A : \"\"\" `filter` is a wrapper over `treeo.filter` that passes `self` as the first argument. Arguments: *filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" return api . filter ( self , * filters , inplace = inplace , flatten_mode = flatten_mode )","title":"filter()"},{"location":"api/Treex/#treex.treex.Treex.get_field","text":"A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: The field must be declared in the class definition. The method can only be called inside a compact context. Parameters: Name Type Description Default field_name str The name of the field to get. required initializer Callable[[], ~A] The function to initialize the field if it does not exist. required Returns: Type Description ~A The field value. Source code in treex/treex.py def get_field ( self , field_name : str , initializer : tp . Callable [[], A ], ) -> A : \"\"\" A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: * The field must be declared in the class definition. * The method can only be called inside a `compact` context. Arguments: field_name: The name of the field to get. initializer: The function to initialize the field if it does not exist. Returns: The field value. \"\"\" value : A if field_name not in self . _field_metadata : raise ValueError ( f \"Metadata for field ' { field_name } ' does not exist.\" ) if tree_m . _COMPACT_CONTEXT . current_tree is not self : raise RuntimeError ( f \"Object ' { type ( self ) . __name__ } ' is not the current tree, found ' { type ( tree_m . _COMPACT_CONTEXT . current_tree ) . __name__ } ', did you forget the @compact decorator?\" ) if field_name in vars ( self ): value = getattr ( self , field_name ) else : if tree_m . _COMPACT_CONTEXT . in_compact and not self . first_run : raise RuntimeError ( f \"Trying to initialize field ' { field_name } ' after the first run of `compact`.\" ) value = initializer () setattr ( self , field_name , value ) return value","title":"get_field()"},{"location":"api/Treex/#treex.treex.Treex.map","text":"map is a wrapper over treeo.map that passes self as the second argument. Parameters: Name Type Description Default f Callable The function to apply to the leaves. required *filters Filter The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treex/treex.py def map ( self : A , f : tp . Callable , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , is_leaf : tp . Callable [[ tp . Any ], bool ] = None , ) -> A : \"\"\" `map` is a wrapper over `treeo.map` that passes `self` as the second argument. Arguments: f: The function to apply to the leaves. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" return api . map ( f , self , * filters , inplace = inplace , flatten_mode = flatten_mode , is_leaf = is_leaf , )","title":"map()"},{"location":"api/Treex/#treex.treex.Treex.merge","text":"merge is a wrapper over treeo.merge that passes self as the first argument. Parameters: Name Type Description Default other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the merged values. If inplace is True , obj is returned. Source code in treex/treex.py def merge ( self : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" `merge` is a wrapper over `treeo.merge` that passes `self` as the first argument. Arguments: other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the merged values. If `inplace` is `True`, `obj` is returned. \"\"\" return api . merge ( self , other , * rest , inplace = inplace , flatten_mode = flatten_mode , ignore_static = ignore_static , )","title":"merge()"},{"location":"api/Treex/#treex.treex.Treex.to_dict","text":"to_dict is a wrapper over treeo.to_dict that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True type_info bool If True , type information is included. False field_info bool If True , field information is included. False Returns: Type Description Any A dict representation of the object. Source code in treex/treex.py def to_dict ( self , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : \"\"\" `to_dict` is a wrapper over `treeo.to_dict` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. type_info: If `True`, type information is included. field_info: If `True`, field information is included. Returns: A dict representation of the object. \"\"\" return api . to_dict ( self , private_fields = private_fields , static_fields = static_fields , type_info = type_info , field_info = field_info , )","title":"to_dict()"},{"location":"api/Treex/#treex.treex.Treex.to_string","text":"to_string is a wrapper over treeo.to_string that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True color bool If True , color is included. False Returns: Type Description str A string representation of the object. Source code in treex/treex.py def to_string ( self : A , * , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" `to_string` is a wrapper over `treeo.to_string` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. color: If `True`, color is included. Returns: A string representation of the object. \"\"\" return api . to_string ( self , private_fields = private_fields , static_fields = static_fields , color = color , )","title":"to_string()"},{"location":"api/add_field_info/","text":"treex.add_field_info A context manager that makes Tree s produce leaves as FieldInfo when flattening. Source code in treeo/api.py @contextmanager def add_field_info (): \"\"\" A context manager that makes `Tree`s produce leaves as `FieldInfo` when flattening. \"\"\" with tree_m . _CONTEXT . update ( add_field_info = True ): yield","title":"add_field_info"},{"location":"api/add_field_info/#treexadd_field_info","text":"A context manager that makes Tree s produce leaves as FieldInfo when flattening. Source code in treeo/api.py @contextmanager def add_field_info (): \"\"\" A context manager that makes `Tree`s produce leaves as `FieldInfo` when flattening. \"\"\" with tree_m . _CONTEXT . update ( add_field_info = True ): yield","title":"treex.add_field_info"},{"location":"api/apply/","text":"treex.apply Applies a function to all to.Tree s in a Pytree. Works very similar to jax.tree_map , but its values are to.Tree s instead of leaves, also f should apply the changes inplace to Tree object. If inplace is False , a copy of the first object is returned with the changes applied. The rest of the objects are always copied. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required obj ~A a pytree possibly containing Trees. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treeo/api.py def apply ( f : tp . Callable [ ... , None ], obj : A , * rest : A , inplace : bool = False ) -> A : \"\"\" Applies a function to all `to.Tree`s in a Pytree. Works very similar to `jax.tree_map`, but its values are `to.Tree`s instead of leaves, also `f` should apply the changes inplace to Tree object. If `inplace` is `False`, a copy of the first object is returned with the changes applied. The `rest` of the objects are always copied. Arguments: f: The function to apply. obj: a pytree possibly containing Trees. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" rest = tree_m . copy ( rest ) if not inplace : obj = tree_m . copy ( obj ) objs = ( obj ,) + rest def nested_fn ( obj , * rest ): if isinstance ( obj , Tree ): apply ( f , obj , * rest , inplace = True ) jax . tree_map ( nested_fn , * objs , is_leaf = lambda x : isinstance ( x , Tree ) and not x in objs , ) if isinstance ( obj , Tree ): f ( obj , * rest ) return obj","title":"apply"},{"location":"api/apply/#treexapply","text":"Applies a function to all to.Tree s in a Pytree. Works very similar to jax.tree_map , but its values are to.Tree s instead of leaves, also f should apply the changes inplace to Tree object. If inplace is False , a copy of the first object is returned with the changes applied. The rest of the objects are always copied. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required obj ~A a pytree possibly containing Trees. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treeo/api.py def apply ( f : tp . Callable [ ... , None ], obj : A , * rest : A , inplace : bool = False ) -> A : \"\"\" Applies a function to all `to.Tree`s in a Pytree. Works very similar to `jax.tree_map`, but its values are `to.Tree`s instead of leaves, also `f` should apply the changes inplace to Tree object. If `inplace` is `False`, a copy of the first object is returned with the changes applied. The `rest` of the objects are always copied. Arguments: f: The function to apply. obj: a pytree possibly containing Trees. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" rest = tree_m . copy ( rest ) if not inplace : obj = tree_m . copy ( obj ) objs = ( obj ,) + rest def nested_fn ( obj , * rest ): if isinstance ( obj , Tree ): apply ( f , obj , * rest , inplace = True ) jax . tree_map ( nested_fn , * objs , is_leaf = lambda x : isinstance ( x , Tree ) and not x in objs , ) if isinstance ( obj , Tree ): f ( obj , * rest ) return obj","title":"treex.apply"},{"location":"api/compact/","text":"treex.compact A decorator that enable the definition of Tree subnodes at runtime. Source code in treeo/api.py def compact ( f ): \"\"\" A decorator that enable the definition of Tree subnodes at runtime. \"\"\" @functools . wraps ( f ) def wrapper ( tree , * args , ** kwargs ): with tree_m . _COMPACT_CONTEXT . compact ( f , tree ): return f ( tree , * args , ** kwargs ) wrapper . _treeo_compact = True return wrapper","title":"compact"},{"location":"api/compact/#treexcompact","text":"A decorator that enable the definition of Tree subnodes at runtime. Source code in treeo/api.py def compact ( f ): \"\"\" A decorator that enable the definition of Tree subnodes at runtime. \"\"\" @functools . wraps ( f ) def wrapper ( tree , * args , ** kwargs ): with tree_m . _COMPACT_CONTEXT . compact ( f , tree ): return f ( tree , * args , ** kwargs ) wrapper . _treeo_compact = True return wrapper","title":"treex.compact"},{"location":"api/field/","text":"treex.field Source code in treeo/utils.py def field ( default : tp . Any = dataclasses . MISSING , * , node : bool , kind : type = type ( None ), default_factory : tp . Optional [ tp . Callable [[], tp . Any ]] = None , init : bool = True , repr : bool = True , hash : tp . Optional [ bool ] = None , compare : bool = True , opaque : tp . Union [ bool , OpaquePredicate ] = False , ) -> tp . Any : return dataclasses . field ( default = default , metadata = { \"node\" : node , \"kind\" : kind , \"opaque\" : opaque , }, default_factory = default_factory if default_factory is not None else dataclasses . MISSING , init = init , repr = repr , hash = hash , compare = compare , )","title":"field"},{"location":"api/field/#treexfield","text":"Source code in treeo/utils.py def field ( default : tp . Any = dataclasses . MISSING , * , node : bool , kind : type = type ( None ), default_factory : tp . Optional [ tp . Callable [[], tp . Any ]] = None , init : bool = True , repr : bool = True , hash : tp . Optional [ bool ] = None , compare : bool = True , opaque : tp . Union [ bool , OpaquePredicate ] = False , ) -> tp . Any : return dataclasses . field ( default = default , metadata = { \"node\" : node , \"kind\" : kind , \"opaque\" : opaque , }, default_factory = default_factory if default_factory is not None else dataclasses . MISSING , init = init , repr = repr , hash = hash , compare = compare , )","title":"treex.field"},{"location":"api/filter/","text":"treex.filter The filter function allows you to select a subtree by filtering based on a predicate or kind type, leaves that pass all filters are kept, the rest are set to Nothing . For more information see filter's user guide . Parameters: Name Type Description Default obj ~A A pytree (possibly containing to.Tree s) to be filtered. required *filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treeo/api.py def filter ( obj : A , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ FlattenMode , str , None ] = None , ) -> A : \"\"\" The `filter` function allows you to select a subtree by filtering based on a predicate or `kind` type, leaves that pass all filters are kept, the rest are set to `Nothing`. For more information see [filter's user guide](https://cgarciae.github.io/treeo/user-guide/api/filter). Arguments: obj: A pytree (possibly containing `to.Tree`s) to be filtered. *filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" if inplace and not hasattr ( obj , \"__dict__\" ): raise ValueError ( f \"Cannot filter inplace on objects with no __dict__ property, got { obj } \" ) input_obj = obj filters = tuple ( _get_kind_filter ( f ) if isinstance ( f , tp . Type ) else f for f in filters ) def apply_filters ( info : tp . Any ) -> tp . Any : if not isinstance ( info , FieldInfo ): info = FieldInfo ( name = None , value = info , kind = type ( None ), module = None , ) assert isinstance ( info , FieldInfo ) return info . value if all ( f ( info ) for f in filters ) else types . NOTHING with tree_m . _CONTEXT . update ( add_field_info = True ), _flatten_context ( flatten_mode ): obj = jax . tree_map ( apply_filters , obj ) if inplace : input_obj . __dict__ . update ( obj . __dict__ ) return input_obj else : return obj","title":"filter"},{"location":"api/filter/#treexfilter","text":"The filter function allows you to select a subtree by filtering based on a predicate or kind type, leaves that pass all filters are kept, the rest are set to Nothing . For more information see filter's user guide . Parameters: Name Type Description Default obj ~A A pytree (possibly containing to.Tree s) to be filtered. required *filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treeo/api.py def filter ( obj : A , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ FlattenMode , str , None ] = None , ) -> A : \"\"\" The `filter` function allows you to select a subtree by filtering based on a predicate or `kind` type, leaves that pass all filters are kept, the rest are set to `Nothing`. For more information see [filter's user guide](https://cgarciae.github.io/treeo/user-guide/api/filter). Arguments: obj: A pytree (possibly containing `to.Tree`s) to be filtered. *filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" if inplace and not hasattr ( obj , \"__dict__\" ): raise ValueError ( f \"Cannot filter inplace on objects with no __dict__ property, got { obj } \" ) input_obj = obj filters = tuple ( _get_kind_filter ( f ) if isinstance ( f , tp . Type ) else f for f in filters ) def apply_filters ( info : tp . Any ) -> tp . Any : if not isinstance ( info , FieldInfo ): info = FieldInfo ( name = None , value = info , kind = type ( None ), module = None , ) assert isinstance ( info , FieldInfo ) return info . value if all ( f ( info ) for f in filters ) else types . NOTHING with tree_m . _CONTEXT . update ( add_field_info = True ), _flatten_context ( flatten_mode ): obj = jax . tree_map ( apply_filters , obj ) if inplace : input_obj . __dict__ . update ( obj . __dict__ ) return input_obj else : return obj","title":"treex.filter"},{"location":"api/iter_split/","text":"treex.iter_split Source code in treex/utils.py def iter_split ( key : tp . Any , num : int = 2 ) -> tp . Tuple [ tp . Any , ... ]: splits = jax . random . split ( key , num ) return tuple ( splits [ i ] for i in range ( num ))","title":"iter_split"},{"location":"api/iter_split/#treexiter_split","text":"Source code in treex/utils.py def iter_split ( key : tp . Any , num : int = 2 ) -> tp . Tuple [ tp . Any , ... ]: splits = jax . random . split ( key , num ) return tuple ( splits [ i ] for i in range ( num ))","title":"treex.iter_split"},{"location":"api/map/","text":"treex.map Applies a function to all leaves in a pytree using jax.tree_map , if filters are given then the function will be applied only to the subset of leaves that match the filters. For more information see map's user guide . Parameters: Name Type Description Default f Callable The function to apply to the leaves. required obj ~A a pytree possibly containing to.Tree s. required *filters Union[Type[Any], Callable[[FieldInfo], bool]] The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treeo/api.py def map ( f : tp . Callable , obj : A , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ FlattenMode , str , None ] = None , is_leaf : tp . Callable [[ tp . Any ], bool ] = None , ) -> A : \"\"\" Applies a function to all leaves in a pytree using `jax.tree_map`, if `filters` are given then the function will be applied only to the subset of leaves that match the filters. For more information see [map's user guide](https://cgarciae.github.io/treeo/user-guide/api/map). Arguments: f: The function to apply to the leaves. obj: a pytree possibly containing `to.Tree`s. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" if inplace and not hasattr ( obj , \"__dict__\" ): raise ValueError ( f \"Cannot map inplace on objects with no __dict__ property, got { obj } \" ) input_obj = obj has_filters = len ( filters ) > 0 with _flatten_context ( flatten_mode ): if has_filters : new_obj = filter ( obj , * filters ) else : new_obj = obj new_obj : A = jax . tree_map ( f , new_obj , is_leaf = is_leaf ) if has_filters : new_obj = merge ( obj , new_obj ) if inplace : input_obj . __dict__ . update ( new_obj . __dict__ ) return input_obj else : return new_obj","title":"map"},{"location":"api/map/#treexmap","text":"Applies a function to all leaves in a pytree using jax.tree_map , if filters are given then the function will be applied only to the subset of leaves that match the filters. For more information see map's user guide . Parameters: Name Type Description Default f Callable The function to apply to the leaves. required obj ~A a pytree possibly containing to.Tree s. required *filters Union[Type[Any], Callable[[FieldInfo], bool]] The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treeo/api.py def map ( f : tp . Callable , obj : A , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ FlattenMode , str , None ] = None , is_leaf : tp . Callable [[ tp . Any ], bool ] = None , ) -> A : \"\"\" Applies a function to all leaves in a pytree using `jax.tree_map`, if `filters` are given then the function will be applied only to the subset of leaves that match the filters. For more information see [map's user guide](https://cgarciae.github.io/treeo/user-guide/api/map). Arguments: f: The function to apply to the leaves. obj: a pytree possibly containing `to.Tree`s. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" if inplace and not hasattr ( obj , \"__dict__\" ): raise ValueError ( f \"Cannot map inplace on objects with no __dict__ property, got { obj } \" ) input_obj = obj has_filters = len ( filters ) > 0 with _flatten_context ( flatten_mode ): if has_filters : new_obj = filter ( obj , * filters ) else : new_obj = obj new_obj : A = jax . tree_map ( f , new_obj , is_leaf = is_leaf ) if has_filters : new_obj = merge ( obj , new_obj ) if inplace : input_obj . __dict__ . update ( new_obj . __dict__ ) return input_obj else : return new_obj","title":"treex.map"},{"location":"api/merge/","text":"treex.merge Creates a new Tree with the same structure but its values merged based on the values from the incoming Trees. For more information see merge's user guide . Parameters: Name Type Description Default obj ~A Main pytree to merge. required other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the updated values. If inplace is True , obj is returned. Source code in treeo/api.py def merge ( obj : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" Creates a new Tree with the same structure but its values merged based on the values from the incoming Trees. For more information see [merge's user guide](https://cgarciae.github.io/treeo/user-guide/api/merge). Arguments: obj: Main pytree to merge. other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the updated values. If `inplace` is `True`, `obj` is returned. \"\"\" if inplace and not hasattr ( obj , \"__dict__\" ): raise TypeError ( f \"Cannot update inplace on objects with no __dict__ property, got { obj } \" ) if flatten_mode is None and tree_m . _CONTEXT . flatten_mode is None : flatten_mode = FlattenMode . all_fields input_obj = obj def merge_fn ( * xs ): for x in reversed ( xs ): if not isinstance ( x , types . Nothing ): return x return types . NOTHING tree_map_fn = _looser_tree_map if ignore_static else jax . tree_map with _flatten_context ( flatten_mode ): obj = tree_map_fn ( merge_fn , obj , other , * rest , is_leaf = lambda x : isinstance ( x , LEAF_TYPES ), ) if inplace : input_obj . __dict__ . update ( obj . __dict__ ) return input_obj else : return obj","title":"merge"},{"location":"api/merge/#treexmerge","text":"Creates a new Tree with the same structure but its values merged based on the values from the incoming Trees. For more information see merge's user guide . Parameters: Name Type Description Default obj ~A Main pytree to merge. required other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the updated values. If inplace is True , obj is returned. Source code in treeo/api.py def merge ( obj : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" Creates a new Tree with the same structure but its values merged based on the values from the incoming Trees. For more information see [merge's user guide](https://cgarciae.github.io/treeo/user-guide/api/merge). Arguments: obj: Main pytree to merge. other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the updated values. If `inplace` is `True`, `obj` is returned. \"\"\" if inplace and not hasattr ( obj , \"__dict__\" ): raise TypeError ( f \"Cannot update inplace on objects with no __dict__ property, got { obj } \" ) if flatten_mode is None and tree_m . _CONTEXT . flatten_mode is None : flatten_mode = FlattenMode . all_fields input_obj = obj def merge_fn ( * xs ): for x in reversed ( xs ): if not isinstance ( x , types . Nothing ): return x return types . NOTHING tree_map_fn = _looser_tree_map if ignore_static else jax . tree_map with _flatten_context ( flatten_mode ): obj = tree_map_fn ( merge_fn , obj , other , * rest , is_leaf = lambda x : isinstance ( x , LEAF_TYPES ), ) if inplace : input_obj . __dict__ . update ( obj . __dict__ ) return input_obj else : return obj","title":"treex.merge"},{"location":"api/node/","text":"treex.node Source code in treeo/utils.py def node ( default = dataclasses . MISSING , * , kind : type = type ( None ), default_factory : tp . Optional [ tp . Callable [[], tp . Any ]] = None , init : bool = True , repr : bool = True , hash : tp . Optional [ bool ] = None , compare : bool = True , opaque : tp . Union [ bool , OpaquePredicate ] = False , ) -> tp . Any : return field ( default = default , node = True , kind = kind , default_factory = default_factory , init = init , repr = repr , hash = hash , compare = compare , opaque = opaque , )","title":"node"},{"location":"api/node/#treexnode","text":"Source code in treeo/utils.py def node ( default = dataclasses . MISSING , * , kind : type = type ( None ), default_factory : tp . Optional [ tp . Callable [[], tp . Any ]] = None , init : bool = True , repr : bool = True , hash : tp . Optional [ bool ] = None , compare : bool = True , opaque : tp . Union [ bool , OpaquePredicate ] = False , ) -> tp . Any : return field ( default = default , node = True , kind = kind , default_factory = default_factory , init = init , repr = repr , hash = hash , compare = compare , opaque = opaque , )","title":"treex.node"},{"location":"api/sequence/","text":"treex.sequence Creates a function that applies a sequence of callables to an input. Examples: class Block ( tx . Module ): linear : tx . Linear batch_norm : tx . BatchNorm dropout : tx . Dropout ... def __call__ ( self , x : jnp . ndarray ) -> jnp . ndarray : return tx . sequence ( self . linear , self . batch_norm , self . dropout , jax . nn . relu , )( x ) Parameters: Name Type Description Default *layers Callable[..., jax._src.numpy.lax_numpy.ndarray] A sequence of callables to apply. () Source code in treex/nn/sequential.py def sequence ( * layers : CallableModule ) -> CallableModule : \"\"\" Creates a function that applies a sequence of callables to an input. Example: ```python class Block(tx.Module): linear: tx.Linear batch_norm: tx.BatchNorm dropout: tx.Dropout ... def __call__(self, x: jnp.ndarray) -> jnp.ndarray: return tx.sequence( self.linear, self.batch_norm, self.dropout, jax.nn.relu, )(x) ``` Arguments: *layers: A sequence of callables to apply. \"\"\" def _sequence ( x : jnp . ndarray ) -> jnp . ndarray : for layer in layers : x = layer ( x ) return x return _sequence","title":"sequence"},{"location":"api/sequence/#treexsequence","text":"Creates a function that applies a sequence of callables to an input. Examples: class Block ( tx . Module ): linear : tx . Linear batch_norm : tx . BatchNorm dropout : tx . Dropout ... def __call__ ( self , x : jnp . ndarray ) -> jnp . ndarray : return tx . sequence ( self . linear , self . batch_norm , self . dropout , jax . nn . relu , )( x ) Parameters: Name Type Description Default *layers Callable[..., jax._src.numpy.lax_numpy.ndarray] A sequence of callables to apply. () Source code in treex/nn/sequential.py def sequence ( * layers : CallableModule ) -> CallableModule : \"\"\" Creates a function that applies a sequence of callables to an input. Example: ```python class Block(tx.Module): linear: tx.Linear batch_norm: tx.BatchNorm dropout: tx.Dropout ... def __call__(self, x: jnp.ndarray) -> jnp.ndarray: return tx.sequence( self.linear, self.batch_norm, self.dropout, jax.nn.relu, )(x) ``` Arguments: *layers: A sequence of callables to apply. \"\"\" def _sequence ( x : jnp . ndarray ) -> jnp . ndarray : for layer in layers : x = layer ( x ) return x return _sequence","title":"treex.sequence"},{"location":"api/static/","text":"treex.static Source code in treeo/utils.py def static ( default = dataclasses . MISSING , * , kind : type = type ( None ), default_factory : tp . Optional [ tp . Callable [[], tp . Any ]] = None , init : bool = True , repr : bool = True , hash : tp . Optional [ bool ] = None , compare : bool = True , opaque : tp . Union [ bool , OpaquePredicate ] = False , ) -> tp . Any : return field ( default , node = False , kind = kind , default_factory = default_factory , init = init , repr = repr , hash = hash , compare = compare , opaque = opaque , )","title":"static"},{"location":"api/static/#treexstatic","text":"Source code in treeo/utils.py def static ( default = dataclasses . MISSING , * , kind : type = type ( None ), default_factory : tp . Optional [ tp . Callable [[], tp . Any ]] = None , init : bool = True , repr : bool = True , hash : tp . Optional [ bool ] = None , compare : bool = True , opaque : tp . Union [ bool , OpaquePredicate ] = False , ) -> tp . Any : return field ( default , node = False , kind = kind , default_factory = default_factory , init = init , repr = repr , hash = hash , compare = compare , opaque = opaque , )","title":"treex.static"},{"location":"api/to_dict/","text":"treex.to_dict Source code in treeo/api.py def to_dict ( obj : tp . Any , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : if field_info : with add_field_info (), flatten_mode ( FlattenMode . all_fields ): flat , treedef = jax . tree_flatten ( obj ) obj = jax . tree_unflatten ( treedef , flat ) obj = apply ( _remove_field_info_from_metadata , obj ) return _to_dict ( obj , private_fields , static_fields , type_info )","title":"to_dict"},{"location":"api/to_dict/#treexto_dict","text":"Source code in treeo/api.py def to_dict ( obj : tp . Any , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : if field_info : with add_field_info (), flatten_mode ( FlattenMode . all_fields ): flat , treedef = jax . tree_flatten ( obj ) obj = jax . tree_unflatten ( treedef , flat ) obj = apply ( _remove_field_info_from_metadata , obj ) return _to_dict ( obj , private_fields , static_fields , type_info )","title":"treex.to_dict"},{"location":"api/to_string/","text":"treex.to_string Converts a pytree to a string representation. Parameters: Name Type Description Default obj Any The pytree to convert. required private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True Returns: Type Description str A string representation of the pytree. Source code in treeo/api.py def to_string ( obj : tp . Any , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" Converts a pytree to a string representation. Arguments: obj: The pytree to convert. private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. Returns: A string representation of the pytree. \"\"\" dict_ = to_dict ( obj , private_fields = private_fields , static_fields = static_fields , type_info = True , field_info = True , ) global RICH_WARNING_COUNT rep = _to_string ( dict_ , level = 0 , inline = False , color = color , space = \" \" ) rep = _add_padding ( rep ) if color : if Console is None or Text is None : if RICH_WARNING_COUNT < 1 : RICH_WARNING_COUNT += 1 logging . warning ( f \"'rich' library not available, install `rich` to get colors.\" ) else : rep = _get_rich_repr ( Text . from_markup ( rep )) return rep","title":"to_string"},{"location":"api/to_string/#treexto_string","text":"Converts a pytree to a string representation. Parameters: Name Type Description Default obj Any The pytree to convert. required private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True Returns: Type Description str A string representation of the pytree. Source code in treeo/api.py def to_string ( obj : tp . Any , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" Converts a pytree to a string representation. Arguments: obj: The pytree to convert. private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. Returns: A string representation of the pytree. \"\"\" dict_ = to_dict ( obj , private_fields = private_fields , static_fields = static_fields , type_info = True , field_info = True , ) global RICH_WARNING_COUNT rep = _to_string ( dict_ , level = 0 , inline = False , color = color , space = \" \" ) rep = _add_padding ( rep ) if color : if Console is None or Text is None : if RICH_WARNING_COUNT < 1 : RICH_WARNING_COUNT += 1 logging . warning ( f \"'rich' library not available, install `rich` to get colors.\" ) else : rep = _get_rich_repr ( Text . from_markup ( rep )) return rep","title":"treex.to_string"},{"location":"user-guide/defining-modules/","text":"Modules in Treex usually follow this recipe: They inherit from tx.Module . Parameter-like fields are declared with a tx.TreePart subclass kind e.g. tx.Parameter.node() Hyper-parameters fields usually don't contain a declaration so they are static. Submodules fields are usually not declared, instead they are infered by the type annotations or runtime values. Modules can be defined as dataclasses or regular classes without any limitations. For example, a basic Module will tend to look like this: class Linear ( tx . Module ): # din: int # annotation not needed, inferred as static w : Union [ tx . Initializer , jnp . ndarray ] = tx . Parameter . node () # node field b : jnp . ndarray = tx . Parameter . node () # node field def __init__ ( self , din , dout ): self . w = tx . Initializer ( lambda key : jax . random . uniform ( key , shape = ( din , dout )) ) self . b = jnp . zeros ( shape = ( dout ,)) def __call__ ( self , x ): return jnp . dot ( x , self . w ) + self . b linear = Linear ( 3 , 5 ) . init ( 42 ) y = linear ( x ) While composite Module will tend to look like this: class MLP ( tx . Module ): # features: Sequence[int], annotation not needed, infered as static layers : List [ tx . Linear ] # mandatory annotation, infered as node because Modules are treeo.Trees def __init__ ( self , features : Sequence [ int ]): self . layers = [ tx . Linear ( din , dout ) for din , dout in zip ( features [: - 1 ], features [ 1 :]) ] def __call__ ( self , x ): for linear in self . layers [: - 1 ]: x = jax . nn . relu ( linear ( x )) return self . layers [ - 1 ]( x ) mlp = MLP ([ 3 , 5 , 2 ]) . init ( 42 )","title":"Defining Modules"},{"location":"user-guide/freezing-modules/","text":"Freezing Modules Module s have a .frozen property that specifies whether the module is frozen or not, Modules such as Dropout and BatchNorm which will behave differently based on its value. To switch between modes, use the .freeze() and .unfreeze() methods, they return a new Module whose frozen state and the state of all of its submodules (recursively) are set to the desired value. class ConvBlock ( tx . Module ): ... model = tx . Sequential ( ConvBlock ( 3 , 32 ), ConvBlock ( 32 , 64 ), ConvBlock ( 64 , 128 ), ... ) # train model ... # freeze some layers for layer in model . layers [: - 1 ]: layer . freeze ( inplace = True ) # fine-tune the model ... In this example we can leveraged the fact that Sequential has its submodules in .layers to freeze all but the last layers. Freezing modules is useful for tasks such as Transfer Learning where you want to keep most of the weights in a model unchange and train only a few of them on a new dataset. If you have a backbone you can just freeze the entire model. backbone = get_pretrained_model () backbone = backbone . freeze () model = tx . Sequential ( backbone , tx . Linear ( backbone . output_features , 10 ) ) . init ( 42 ) ... @jax . jit def train_step ( model , x , y , optimizer ): # only differentiate w.r.t. parameters whose module is not frozen params = model . filter ( tx . Parameter , lambda field : not field . module . frozen , ) ( loss , model ), grads = loss_fn ( params , model , x , y ) ... Notice that here we used a custom callback to filter to select only parameters from Modules that are not frozen.","title":"Freezing Modules"},{"location":"user-guide/freezing-modules/#freezing-modules","text":"Module s have a .frozen property that specifies whether the module is frozen or not, Modules such as Dropout and BatchNorm which will behave differently based on its value. To switch between modes, use the .freeze() and .unfreeze() methods, they return a new Module whose frozen state and the state of all of its submodules (recursively) are set to the desired value. class ConvBlock ( tx . Module ): ... model = tx . Sequential ( ConvBlock ( 3 , 32 ), ConvBlock ( 32 , 64 ), ConvBlock ( 64 , 128 ), ... ) # train model ... # freeze some layers for layer in model . layers [: - 1 ]: layer . freeze ( inplace = True ) # fine-tune the model ... In this example we can leveraged the fact that Sequential has its submodules in .layers to freeze all but the last layers. Freezing modules is useful for tasks such as Transfer Learning where you want to keep most of the weights in a model unchange and train only a few of them on a new dataset. If you have a backbone you can just freeze the entire model. backbone = get_pretrained_model () backbone = backbone . freeze () model = tx . Sequential ( backbone , tx . Linear ( backbone . output_features , 10 ) ) . init ( 42 ) ... @jax . jit def train_step ( model , x , y , optimizer ): # only differentiate w.r.t. parameters whose module is not frozen params = model . filter ( tx . Parameter , lambda field : not field . module . frozen , ) ( loss , model ), grads = loss_fn ( params , model , x , y ) ... Notice that here we used a custom callback to filter to select only parameters from Modules that are not frozen.","title":"Freezing Modules"},{"location":"user-guide/initialization/","text":"Initialization Initialization is performed by calling the Module.init method or the tx.init function with a seed. init returns a new Module with all fields initialized. There are two initialization mechanisms in Treex: Using an Initializer object to initialize a field. Defining the rng_init method on a Module. Initializer s contain a function that take a key and return an initial value, init replaces leaves with Initializer objects with the initial value their function outputs for the given key: class MyModule ( tx . Module ): a : Union [ tx . Initializer , jnp . ndarray ] = tx . Parameter . node () b : int = tx . node () # we are not setting a kind for this field for no reason def __init__ ( self ): self . a = tx . Initializer ( lambda key : jax . random . uniform ( key , shape = ( 1 ,))) self . b = 2 module = MyModule () module # MyModule(a=Initializer, b=2) moduel . initialized # False module = module . init ( 42 ) module # MyModule(a=array([0.034...]), b=2) module . initialized # True The second is to override the rng_init method, this is useful for fields that require complex initialization logic. class MyModule ( tx . Module ): a : Union [ jnp . ndarray , tx . Initializer ] = tx . Parameter . node () b : Union [ jnp . ndarray , None ] = tx . Parameter . node () def __init__ ( self ): self . a = tx . Initializer ( lambda key : jax . random . uniform ( key , shape = ( 1 ,))) self . b = None def rng_init ( self , key ): # self.a is already initialized at this point self . b = 10.0 * self . a + jax . random . normal ( key , shape = ( 1 ,)) module = MyModule () . init ( 42 ) module # MyModule(a=array([0.3]), b=array([3.2])) As shown here, Initializer s are always called before rng_init .","title":"Initialization"},{"location":"user-guide/initialization/#initialization","text":"Initialization is performed by calling the Module.init method or the tx.init function with a seed. init returns a new Module with all fields initialized. There are two initialization mechanisms in Treex: Using an Initializer object to initialize a field. Defining the rng_init method on a Module. Initializer s contain a function that take a key and return an initial value, init replaces leaves with Initializer objects with the initial value their function outputs for the given key: class MyModule ( tx . Module ): a : Union [ tx . Initializer , jnp . ndarray ] = tx . Parameter . node () b : int = tx . node () # we are not setting a kind for this field for no reason def __init__ ( self ): self . a = tx . Initializer ( lambda key : jax . random . uniform ( key , shape = ( 1 ,))) self . b = 2 module = MyModule () module # MyModule(a=Initializer, b=2) moduel . initialized # False module = module . init ( 42 ) module # MyModule(a=array([0.034...]), b=2) module . initialized # True The second is to override the rng_init method, this is useful for fields that require complex initialization logic. class MyModule ( tx . Module ): a : Union [ jnp . ndarray , tx . Initializer ] = tx . Parameter . node () b : Union [ jnp . ndarray , None ] = tx . Parameter . node () def __init__ ( self ): self . a = tx . Initializer ( lambda key : jax . random . uniform ( key , shape = ( 1 ,))) self . b = None def rng_init ( self , key ): # self.a is already initialized at this point self . b = 10.0 * self . a + jax . random . normal ( key , shape = ( 1 ,)) module = MyModule () . init ( 42 ) module # MyModule(a=array([0.3]), b=array([3.2])) As shown here, Initializer s are always called before rng_init .","title":"Initialization"},{"location":"user-guide/intro/","text":"User Guide Module is the main construct in Treex, it inherits from treeo.Tree and adds a couple of convenient methods. We recommend that you review the core concepts of Treeo but we will provide a brief overview. Terminology These are the core concepts from Treeo: Type Annotation : ( type hints ) types you set while defining a variable after the : symbol. Field Declaration : default values for class variables that are set using the field function. Node Field : A field that is declared as a node, that is, its content is part of the tree leaves. Static Field : A field that is declared as a static, that is, its content is not part of the leaves. Field Kind : An associated type, separate from the type annotation, that gives semantic meaning to the field. In code these terms map to the following: class MyModule ( tx . Module ): # field annotation ------------declaration--------------- # v v v v some_field : jnp . ndarray = to . field ( node = True , kind = tx . Parameter ) # ^ ^ # node status field kind Here if node=False it would mean that the field is static, else is a node. The previous is written more compactly as: class MyModule ( tx . Module ): some_field : jnp . ndarray = tx . Parameter . node ()","title":"User Guide"},{"location":"user-guide/intro/#user-guide","text":"Module is the main construct in Treex, it inherits from treeo.Tree and adds a couple of convenient methods. We recommend that you review the core concepts of Treeo but we will provide a brief overview.","title":"User Guide"},{"location":"user-guide/intro/#terminology","text":"These are the core concepts from Treeo: Type Annotation : ( type hints ) types you set while defining a variable after the : symbol. Field Declaration : default values for class variables that are set using the field function. Node Field : A field that is declared as a node, that is, its content is part of the tree leaves. Static Field : A field that is declared as a static, that is, its content is not part of the leaves. Field Kind : An associated type, separate from the type annotation, that gives semantic meaning to the field. In code these terms map to the following: class MyModule ( tx . Module ): # field annotation ------------declaration--------------- # v v v v some_field : jnp . ndarray = to . field ( node = True , kind = tx . Parameter ) # ^ ^ # node status field kind Here if node=False it would mean that the field is static, else is a node. The previous is written more compactly as: class MyModule ( tx . Module ): some_field : jnp . ndarray = tx . Parameter . node ()","title":"Terminology"},{"location":"user-guide/optimizer/","text":"Optimizer Optax is an amazing library however, its optimizers are not pytrees, this means that their state and computation are separate and you cannot jit them. To solve this Treex provides a Optimizer class which inherits from treeo.Tree and can wrap any Optax optimizer. Optimizer follows a similar API as optax.GradientTransformation except that: There is no separate opt_state , the Optimizer contains the state. update by default applies the update the parameters, if you want the gradient updates instead you can set apply_updates=False . update also updates the internal state of the Optimizer in-place. While in Optax you would define something like this: def main (): ... optimizer = optax . adam ( 1e-3 ) opt_state = optimizer . init ( params ) ... @partial ( jax . jit , static_argnums = ( 4 ,)) def train_step ( model , x , y , opt_state , optimizer ): # optimizer has to be static ... updates , opt_state = optimizer . update ( grads , opt_state , params ) params = optax . apply_updates ( params , updates ) ... return model , loss , opt_state With tx.Optimizer you it can be simplified to: def main (): ... optimizer = tx . Optimizer ( optax . adam ( 1e-3 )) . init ( params ) ... jax . jit # no static_argnums needed def train_step ( model , x , y , optimizer ): ... params = optimizer . update ( grads , params ) ... return model , loss , optimizer Notice that since tx.Optimizer is a Pytree it was passed through jit naturally without the need to specify static_argnums .","title":"Optimizer"},{"location":"user-guide/optimizer/#optimizer","text":"Optax is an amazing library however, its optimizers are not pytrees, this means that their state and computation are separate and you cannot jit them. To solve this Treex provides a Optimizer class which inherits from treeo.Tree and can wrap any Optax optimizer. Optimizer follows a similar API as optax.GradientTransformation except that: There is no separate opt_state , the Optimizer contains the state. update by default applies the update the parameters, if you want the gradient updates instead you can set apply_updates=False . update also updates the internal state of the Optimizer in-place. While in Optax you would define something like this: def main (): ... optimizer = optax . adam ( 1e-3 ) opt_state = optimizer . init ( params ) ... @partial ( jax . jit , static_argnums = ( 4 ,)) def train_step ( model , x , y , opt_state , optimizer ): # optimizer has to be static ... updates , opt_state = optimizer . update ( grads , opt_state , params ) params = optax . apply_updates ( params , updates ) ... return model , loss , opt_state With tx.Optimizer you it can be simplified to: def main (): ... optimizer = tx . Optimizer ( optax . adam ( 1e-3 )) . init ( params ) ... jax . jit # no static_argnums needed def train_step ( model , x , y , optimizer ): ... params = optimizer . update ( grads , params ) ... return model , loss , optimizer Notice that since tx.Optimizer is a Pytree it was passed through jit naturally without the need to specify static_argnums .","title":"Optimizer"},{"location":"user-guide/state-management/","text":"State Management Treex takes a \"direct\" approach to state management, i.e., state is updated in-place by the Module whenever it needs to. For example, this module will calculate the running average of its input: class Average ( tx . Module ): count : jnp . ndarray = tx . State . node () total : jnp . ndarray = tx . State . node () def __init__ ( self ): self . count = jnp . array ( 0 ) self . total = jnp . array ( 0.0 ) def __call__ ( self , x ): self . count += np . prod ( x . shape ) self . total += jnp . sum ( x ) return self . total / self . count Treex Modules that require random state will often keep a rng key internally and update it in-place when needed: class Dropout ( tx . Module ): key : jnp . ndarray = tx . Rng . node () def __init__ ( self , key : jnp . ndarray ): self . key = key ... def __call__ ( self , x ): key , self . key = jax . random . split ( self . key ) ... Finally ` Optimizer also performs inplace updates inside the update` method, here is a sketch of how it works: class Optimizer ( tx . Module ): opt_state : Any = tx . OptState . node () optimizer : optax . GradientTransformation def update ( self , grads , params ): ... updates , self . opt_state = self . optimizer . update ( grads , self . opt_state , params ) ... What is the catch? State management is one of the most challenging things in JAX because of its functional nature, however here it seems effortless. What is the catch? As always there are trade-offs to consider: The Pytree approach requires the user to be aware that if a Module is stateful it should propagate its state as output to jitted functions, on the other hand implementation and usage if very simple. Frameworks like Flax and Haiku are more explicit as to when state is updated but introduce a lot of complexity to do so. A standard solution to this problem is: always output the Module to merge its state . For example, a typical loss function that contains a stateful model would look like this: @partial ( jax . value_and_grad , has_aux = True ) def loss_fn ( params , model , x , y ): model = model . update ( params ) y_pred = model ( x ) loss = jnp . mean (( y_pred - y ) ** 2 ) return loss , model params = model . parameters () ( loss , model ), grads = loss_fn ( params , model , x , y ) ... Here model is returned along with the loss through value_and_grad to update model on the outside thus persisting any changes to the state performed on the inside.","title":"State Management"},{"location":"user-guide/state-management/#state-management","text":"Treex takes a \"direct\" approach to state management, i.e., state is updated in-place by the Module whenever it needs to. For example, this module will calculate the running average of its input: class Average ( tx . Module ): count : jnp . ndarray = tx . State . node () total : jnp . ndarray = tx . State . node () def __init__ ( self ): self . count = jnp . array ( 0 ) self . total = jnp . array ( 0.0 ) def __call__ ( self , x ): self . count += np . prod ( x . shape ) self . total += jnp . sum ( x ) return self . total / self . count Treex Modules that require random state will often keep a rng key internally and update it in-place when needed: class Dropout ( tx . Module ): key : jnp . ndarray = tx . Rng . node () def __init__ ( self , key : jnp . ndarray ): self . key = key ... def __call__ ( self , x ): key , self . key = jax . random . split ( self . key ) ... Finally ` Optimizer also performs inplace updates inside the update` method, here is a sketch of how it works: class Optimizer ( tx . Module ): opt_state : Any = tx . OptState . node () optimizer : optax . GradientTransformation def update ( self , grads , params ): ... updates , self . opt_state = self . optimizer . update ( grads , self . opt_state , params ) ...","title":"State Management"},{"location":"user-guide/state-management/#what-is-the-catch","text":"State management is one of the most challenging things in JAX because of its functional nature, however here it seems effortless. What is the catch? As always there are trade-offs to consider: The Pytree approach requires the user to be aware that if a Module is stateful it should propagate its state as output to jitted functions, on the other hand implementation and usage if very simple. Frameworks like Flax and Haiku are more explicit as to when state is updated but introduce a lot of complexity to do so. A standard solution to this problem is: always output the Module to merge its state . For example, a typical loss function that contains a stateful model would look like this: @partial ( jax . value_and_grad , has_aux = True ) def loss_fn ( params , model , x , y ): model = model . update ( params ) y_pred = model ( x ) loss = jnp . mean (( y_pred - y ) ** 2 ) return loss , model params = model . parameters () ( loss , model ), grads = loss_fn ( params , model , x , y ) ... Here model is returned along with the loss through value_and_grad to update model on the outside thus persisting any changes to the state performed on the inside.","title":"What is the catch?"},{"location":"user-guide/training-state/","text":"Training State Modules have a training: bool property that specifies whether the module is in training mode or not. This property conditions the behavior of Modules such as Dropout and BatchNorm , which behave differently between training and evaluation. # training loop for step in range ( 1000 ): loss , model , opt_state = train_step ( model , x , y , opt_state ) # prepare for evaluation model = model . eval () # make predictions y_pred = model ( X_test ) To switch between modes, use the .train() and .eval() methods, they return a new Module whose training state and the state of all of its submodules (recursively) are set to the desired value.","title":"Training State"},{"location":"user-guide/training-state/#training-state","text":"Modules have a training: bool property that specifies whether the module is in training mode or not. This property conditions the behavior of Modules such as Dropout and BatchNorm , which behave differently between training and evaluation. # training loop for step in range ( 1000 ): loss , model , opt_state = train_step ( model , x , y , opt_state ) # prepare for evaluation model = model . eval () # make predictions y_pred = model ( X_test ) To switch between modes, use the .train() and .eval() methods, they return a new Module whose training state and the state of all of its submodules (recursively) are set to the desired value.","title":"Training State"},{"location":"user-guide/api/filter/","text":"Filter The filter method allows you to select a subtree by filtering based on a kind , all leaves whose field kind is a subclass of such type are kept, the rest are set to a special Nothing value. tree = MyModule ( a = 1 , b = 2 ) module . filter ( Parameter ) # MyModule(a=1, b=Nothing) module . filter ( BatchStat ) # MyModule(a=Nothing, b=2) Since Nothing is an empty Pytree it gets ignored by tree operations, this effectively allows you to easily operate on a subset of the fields: negative = lambda x : - x jax . tree_map ( negative , module . filter ( Parameter )) # MyModule(a=-1, b=Nothing) jax . tree_map ( negative , module . filter ( BatchStat )) # MyModule(a=Nothing, b=-2) Shortcuts As simple filters using the standard TreePart types are used often, some shortcuts are provided: Shortcut Equivalence .parameters() .filter(tx.Parameter) .batch_stats() .filter(tx.BatchStat) .rngs() .filter(tx.RNG) .model_states() .filter(tx.ModelState) .states() .filter(tx.State) .metrics() .filter(tx.Metric) .losses() .filter(tx.Loss) .logs() .filter(tx.Log) Based on this the first example can be written as: module . parameters () # MyModule(a=1, b=Nothing) module . batch_stats () # MyModule(a=Nothing, b=2) filter predicates If you need to do more complex filtering, you can pass callables with the signature FieldInfo -> bool instead of types: # all Parameters whose field name is \"kernel\" module . filter ( lambda field : issubclass ( field . kind , Parameter ) and field . name == \"kernel\" ) # MyModule(a=Nothing, b=Nothing) multiple filters You can some queries by using multiple filters as *args . For a field to be kept it will required that all filters pass . Since passing types by themselves are \"kind filters\", one of the previous examples could be written as: # all Parameters whose field name is \"kernel\" module . filter ( Parameter , lambda field : field . name == \"kernel\" ) # MyModule(a=Nothing, b=Nothing) inplace If inplace is True , the input obj is mutated and returned. You can only update inplace if the input obj has a __dict__ attribute, else a TypeError is raised.","title":"Filter"},{"location":"user-guide/api/filter/#filter","text":"The filter method allows you to select a subtree by filtering based on a kind , all leaves whose field kind is a subclass of such type are kept, the rest are set to a special Nothing value. tree = MyModule ( a = 1 , b = 2 ) module . filter ( Parameter ) # MyModule(a=1, b=Nothing) module . filter ( BatchStat ) # MyModule(a=Nothing, b=2) Since Nothing is an empty Pytree it gets ignored by tree operations, this effectively allows you to easily operate on a subset of the fields: negative = lambda x : - x jax . tree_map ( negative , module . filter ( Parameter )) # MyModule(a=-1, b=Nothing) jax . tree_map ( negative , module . filter ( BatchStat )) # MyModule(a=Nothing, b=-2)","title":"Filter"},{"location":"user-guide/api/filter/#shortcuts","text":"As simple filters using the standard TreePart types are used often, some shortcuts are provided: Shortcut Equivalence .parameters() .filter(tx.Parameter) .batch_stats() .filter(tx.BatchStat) .rngs() .filter(tx.RNG) .model_states() .filter(tx.ModelState) .states() .filter(tx.State) .metrics() .filter(tx.Metric) .losses() .filter(tx.Loss) .logs() .filter(tx.Log) Based on this the first example can be written as: module . parameters () # MyModule(a=1, b=Nothing) module . batch_stats () # MyModule(a=Nothing, b=2)","title":"Shortcuts"},{"location":"user-guide/api/filter/#filter-predicates","text":"If you need to do more complex filtering, you can pass callables with the signature FieldInfo -> bool instead of types: # all Parameters whose field name is \"kernel\" module . filter ( lambda field : issubclass ( field . kind , Parameter ) and field . name == \"kernel\" ) # MyModule(a=Nothing, b=Nothing)","title":"filter predicates"},{"location":"user-guide/api/filter/#multiple-filters","text":"You can some queries by using multiple filters as *args . For a field to be kept it will required that all filters pass . Since passing types by themselves are \"kind filters\", one of the previous examples could be written as: # all Parameters whose field name is \"kernel\" module . filter ( Parameter , lambda field : field . name == \"kernel\" ) # MyModule(a=Nothing, b=Nothing)","title":"multiple filters"},{"location":"user-guide/api/filter/#inplace","text":"If inplace is True , the input obj is mutated and returned. You can only update inplace if the input obj has a __dict__ attribute, else a TypeError is raised.","title":"inplace"},{"location":"user-guide/api/map/","text":"Map Applies a function to all leaves in the Module using jax.tree_map . If filters are given then the function will be applied only to the subset of leaves that match the filters. For example, if we want to zero all batch stats we can do: Example: @dataclass class MyModule ( x . Module ): a : int = tx . Parameter . node () b : int = tx . BatchStat . node () module = MyModule ( a = 1 , b = 2 ) module . map ( lambda _ : 0 , tx . BatchStat ) # MyTree(a=1, b=0) map is equivalent to filter -> tree_map -> merge in sequence. If inplace is True , the input obj is mutated and returned. You can only update inplace if the input obj has a __dict__ attribute, else a TypeError is raised.","title":"Map"},{"location":"user-guide/api/map/#map","text":"Applies a function to all leaves in the Module using jax.tree_map . If filters are given then the function will be applied only to the subset of leaves that match the filters. For example, if we want to zero all batch stats we can do: Example: @dataclass class MyModule ( x . Module ): a : int = tx . Parameter . node () b : int = tx . BatchStat . node () module = MyModule ( a = 1 , b = 2 ) module . map ( lambda _ : 0 , tx . BatchStat ) # MyTree(a=1, b=0) map is equivalent to filter -> tree_map -> merge in sequence. If inplace is True , the input obj is mutated and returned. You can only update inplace if the input obj has a __dict__ attribute, else a TypeError is raised.","title":"Map"},{"location":"user-guide/api/merge/","text":"Merge Creates a new Module with the same structure but its values merged based on the values from the incoming Modules. @dataclass class MyModule ( tx . Module ): a : int = tx . field ( node = True , kind = Parameter ) b : int = tx . field ( node = True , kind = BatchStat ) m1 = MyModule ( x = Nothing , y = 2 , z = 3 ) m2 = MyModule ( x = 1 , y = Nothing , z = 4 ) m1 . merge ( m2 ) # MyModule(x=1, y=2, z=4) Updates are performed using the following rules: For a list of equivalent leaves l1, l2, ..., ln , it returns the first non- Nothing leaf from right to left. If no flatten_mode() context manager is active and flatten_mode is not given, all fields will be updated. If flatten_mode=\"normal\" is set then static fields won't be updated and the output will have the exact same static components as the first input ( obj ). When using merge with multiple Modules the following equivalence holds: m1.merge(m2, m3) = m1.merge(m2.merge(m3)) If you want to merge the current module instead of creating a new one use inplace=True . This is useful when applying transformation inside a method where reassigning self is not possible: def double_params ( self ): # this is not doing what you expect self = jax . tree_map ( lambda x : 2 * x , self ) Instead do this: def double_params ( self ): doubled = jax . tree_map ( lambda x : 2 * x , self ) self . merge ( doubled , inplace = True ) If inplace is True , the input obj is mutated and returned. You can only merge inplace if the input obj has a __dict__ attribute, else a TypeError is raised. If ignore_static is True , static fields (according to the flattening mode) will be bypassed during the merge process, the final output will have the same static components as the first input ( obj ). This strategy is a bit less safe in general as it will flatten all trees using jax.tree_leaves instead of PyTreeDef.flatten_up_to , this skips some checks so it effectively ignores their static components, the only requirement is that the flattened struture of all trees matches.","title":"Merge"},{"location":"user-guide/api/merge/#merge","text":"Creates a new Module with the same structure but its values merged based on the values from the incoming Modules. @dataclass class MyModule ( tx . Module ): a : int = tx . field ( node = True , kind = Parameter ) b : int = tx . field ( node = True , kind = BatchStat ) m1 = MyModule ( x = Nothing , y = 2 , z = 3 ) m2 = MyModule ( x = 1 , y = Nothing , z = 4 ) m1 . merge ( m2 ) # MyModule(x=1, y=2, z=4) Updates are performed using the following rules: For a list of equivalent leaves l1, l2, ..., ln , it returns the first non- Nothing leaf from right to left. If no flatten_mode() context manager is active and flatten_mode is not given, all fields will be updated. If flatten_mode=\"normal\" is set then static fields won't be updated and the output will have the exact same static components as the first input ( obj ). When using merge with multiple Modules the following equivalence holds: m1.merge(m2, m3) = m1.merge(m2.merge(m3)) If you want to merge the current module instead of creating a new one use inplace=True . This is useful when applying transformation inside a method where reassigning self is not possible: def double_params ( self ): # this is not doing what you expect self = jax . tree_map ( lambda x : 2 * x , self ) Instead do this: def double_params ( self ): doubled = jax . tree_map ( lambda x : 2 * x , self ) self . merge ( doubled , inplace = True ) If inplace is True , the input obj is mutated and returned. You can only merge inplace if the input obj has a __dict__ attribute, else a TypeError is raised. If ignore_static is True , static fields (according to the flattening mode) will be bypassed during the merge process, the final output will have the same static components as the first input ( obj ). This strategy is a bit less safe in general as it will flatten all trees using jax.tree_leaves instead of PyTreeDef.flatten_up_to , this skips some checks so it effectively ignores their static components, the only requirement is that the flattened struture of all trees matches.","title":"Merge"}]}