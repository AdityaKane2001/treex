{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Treex A Pytree Module system for Deep Learning in JAX \ud83d\udca1 Intuitive : Modules contain their own parameters and respect Object Oriented semantics like in PyTorch and Keras. \ud83c\udf33 Pytree-based : Modules are Pytrees whos leaves are its parameters, meaning they are fully compatible with jit , grad , vmap , etc. Treex is implemented on top of Treeo and reexports all of its API for convenience. Getting Started | User Guide | Examples | Documentation What is included? A base Module class. A nn module for with common layers implemented as wrappers over Flax layers. A losses module with common loss functions. A metrics module with common metrics. An Optimizer class that can wrap any optax optimizer. Why Treex? Show Despite all JAX benefits, current Module systems are not intuitive to new users and add additional complexity not present in frameworks like PyTorch or Keras. Treex takes inspiration from S4TF and delivers an intuitive experience using JAX Pytree infrastructure. Current Alternative's Drawbacks and Solutions Currently we have many alternatives like Flax, Haiku, Objax, that have one or more of the following drawbacks: * Module structure and parameter structure are separate, and parameters have to be manipulated around by the end-user, which is not intuitive. In Treex, parameters are stored in the modules themselves and can be accessed directly. * Monadic architecture adds complexity. Flax and Haiku use an `apply` method to call modules that set a context with parameters, rng, and different metadata, which adds additional overhead to the API and creates an asymmetry in how Modules are being used inside and outside a context. In Treex, modules can be called directly. * Among different frameworks, parameter surgery requires special consideration and is challenging to implement. Consider a standard workflow such as transfer learning, transferring parameters and state from a pre-trained module or submodule as part of a new module; in different frameworks, we have to know precisely how to extract their parameters and how to insert them into the new parameter structure/dictionaries such that it is in agreement with the new module structure. In Treex, just as in PyTorch / Keras, we enable to pass the (sub)module to the new module, and parameters are automatically added to the new structure. * Multiple frameworks deviate from JAX semantics and require particular versions of `jit`, `grad`, `vmap`, etc., which makes it harder to integrate with other JAX libraries. Treex's Modules are plain old JAX PyTrees and are compatible with any JAX library that supports them. * Other Pytree-based approaches like Parallax and Equinox do not have a total state management solution to handle complex states as encountered in Flax. Treex has the Filter and Update API, which is very expressive and can effectively handle systems with a complex state. Installation Install using pip: pip install treex Getting Started This is a small appetizer to give you a feel for how using Treex looks like, be sure to checkout the User Guide for a more in-depth explanation. import treex as tx import numpy as np import jax , optax # create some data x = np . random . uniform ( size = ( 50 , 1 )) y = 1.3 * x ** 2 - 0.3 + np . random . normal ( size = x . shape ) # initialize a Module, its simple model = tx . MLP ([ 64 , 1 ]) . init ( key = 42 , inputs = x ) # define an optimizer, init with model params optimizer = tx . Optimizer ( optax . adam ( 4e-3 )) . init ( model ) # define loss function, notice # Modules are jit-abel and differentiable \ud83e\udd2f @jax . grad def loss_fn ( model : tx . MLP , x , y ): # forward is a simple call preds = model ( x ) # MSE return (( preds - y ) ** 2 ) . mean () # basic training loop for step in range ( 500 ): # grads have the same type as model grads : tx . MLP = loss_fn ( model , x , y ) # apply the gradient updates model = optimizer . update ( grads , model ) # Pytorch-like eval mode model = model . eval () preds = model ( x ) Custom Modules Show Modules are Treeo `Tree`s, which are Pytrees. When creating core layers you often mark fields that will contain state that JAX should be aware as `nodes` by assigning class variables to the output of functions like `tx.Parameter.node()`: import treex as tx class Linear ( tx . Module ): # use Treeo's API to define Parameter nodes w : jnp . ndarray = tx . Parameter . node () b : jnp . ndarray = tx . Parameter . node () def __init__ ( self , features_out : int ): self . features_out = features_out def __call__ ( self , x : jnp . ndarray ) -> jnp . ndarray : # init will call forward, we can know if we are inside it if self . initializing (): # `next_key` only available during `init` key = tx . next_key () # leverage shape inference self . w = jax . random . uniform ( key , shape = [ x . shape [ - 1 ], self . features_out ] ) self . b = jnp . zeros ( shape = [ self . features_out ]) # linear forward return jnp . dot ( x , self . w ) + self . b model = Linear ( 10 ) . init ( key = 42 , inputs = x ) Node field types (e.g. `tx.Parameter`) are called Kinds and Treex exports a whole family of Kinds which serve for differente purposes such as holding non-differentiable state (`tx.BatchStats`), metric's state (`tx.MetricState`), logging, etc. Checkout the [kinds](https://cgarciae.github.io/treex/user-guide/kinds) section for more information. Composite Modules Show Composite Modules usually hold and call other Modules within them, while they would be instantiate inside `__init__` and used later in `__call__` like in Pytorch / Keras, in Treex you usually leverage the `@tx.compact` decorator over the `__call__` method to define the submodules inline. class MLP ( tx . Module ): def __init__ ( self , features : Sequence [ int ]): self . features = features # compact lets you define submodules on the fly @tx . compact def __call__ ( self , x : jnp . ndarray ) -> jnp . ndarray : for units in self . features [: - 1 ]: x = Linear ( units )( x ) x = jax . nn . relu ( x ) return Linear ( self . features [ - 1 ])( x ) model = MLP ([ 32 , 10 ]) . init ( key = 42 , inputs = x ) Under the hood all calls to submodule constructors (e.g. `Linear(...)`) inside `compact` are assigned to fields in the parent Module (`MLP`) so they are part of the same Pytree, their field names are available under the `._subtrees` attribute. `compact` must always define submodules in the same order. Status Treex is in an early stage, things might brake between versions but we will respect semanting versioning. Since Treex layers are numerically equivalent to Flax, it borrows some maturity and yields more confidence over its results. Feedback is much appreciated. Roadmap : Wrap all Flax Linen Modules Implement more layers, losses, and metrics. Create applications and pretrained Modules. Contributions are welcomed! Sponsors \ud83d\udc9a Quansight - paid development time Examples Checkout the /examples directory for more detailed examples. Here are a few additional toy examples: Linear Regression This is a simple but realistic example of how Treex is used. from functools import partial from typing import Union import jax import jax.numpy as jnp import matplotlib.pyplot as plt import numpy as np import optax import treex as tx x = np . random . uniform ( size = ( 500 , 1 )) y = 1.4 * x - 0.3 + np . random . normal ( scale = 0.1 , size = ( 500 , 1 )) # differentiate only w.r.t. parameters def loss_fn ( params , model , x , y ): # merge params into model model = model . merge ( params ) preds = model ( x ) loss = jnp . mean (( preds - y ) ** 2 ) # the model may contain state updates # so it should be returned return loss , model grad_fn = jax . value_and_grad ( loss_fn , has_aux = True ) # both model and optimizer are jit-able @jax . jit def train_step ( model , x , y , optimizer ): # select only the parameters params = model . parameters () ( loss , model ), grads = grad_fn ( params , model , x , y ) # update params and model params = optimizer . update ( grads , params ) model = model . merge ( params ) # return new model and optimizer return loss , model , optimizer model = tx . Linear ( 1 ) . init ( 42 , x ) optimizer = tx . Optimizer ( optax . adam ( 0.01 )) . init ( model ) for step in range ( 300 ): loss , model , optimizer = train_step ( model , x , y , optimizer ) if step % 50 == 0 : print ( f \"loss: { loss : .4f } \" ) # eval mode \"turns off\" layers like Dropout / BatchNorm model = model . eval () X_test = np . linspace ( x . min (), x . max (), 100 )[:, None ] preds = model ( X_test ) plt . scatter ( x , y , c = \"k\" , label = \"data\" ) plt . plot ( X_test , preds , c = \"b\" , linewidth = 2 , label = \"prediction\" ) plt . legend () plt . show () A Stateful Module Here is an example of creating a stateful module of a RollingMean metric and using them with jax.jit . For a real use cases use the metrics inside treex.metrics . class RollingMean ( tx . Module ): count : jnp . ndarray = tx . State . node () total : jnp . ndarray = tx . State . node () def __init__ ( self ): self . count = jnp . array ( 0 , dtype = jnp . int32 ) self . total = jnp . array ( 0.0 , dtype = jnp . float32 ) def __call__ ( self , x : jnp . ndarray ) -> jnp . ndarray : self . count += np . prod ( x . shape ) self . total += x . sum () return self . total / self . count @jax . jit def update ( x : jnp . ndarray , metric : RollingMean ) -> Tuple [ jnp . ndarray , RollingMean ]: mean = metric ( x ) return mean , metric # return mean value and updated metric metric = RollingMean () for i in range ( 10 ): x = np . random . uniform ( - 1 , 1 , size = ( 100 , 1 )) mean , metric = update ( x , metric ) print ( mean )","title":"Treex"},{"location":"#treex","text":"A Pytree Module system for Deep Learning in JAX \ud83d\udca1 Intuitive : Modules contain their own parameters and respect Object Oriented semantics like in PyTorch and Keras. \ud83c\udf33 Pytree-based : Modules are Pytrees whos leaves are its parameters, meaning they are fully compatible with jit , grad , vmap , etc. Treex is implemented on top of Treeo and reexports all of its API for convenience. Getting Started | User Guide | Examples | Documentation","title":"Treex"},{"location":"#what-is-included","text":"A base Module class. A nn module for with common layers implemented as wrappers over Flax layers. A losses module with common loss functions. A metrics module with common metrics. An Optimizer class that can wrap any optax optimizer.","title":"What is included?"},{"location":"#why-treex","text":"Show Despite all JAX benefits, current Module systems are not intuitive to new users and add additional complexity not present in frameworks like PyTorch or Keras. Treex takes inspiration from S4TF and delivers an intuitive experience using JAX Pytree infrastructure. Current Alternative's Drawbacks and Solutions Currently we have many alternatives like Flax, Haiku, Objax, that have one or more of the following drawbacks: * Module structure and parameter structure are separate, and parameters have to be manipulated around by the end-user, which is not intuitive. In Treex, parameters are stored in the modules themselves and can be accessed directly. * Monadic architecture adds complexity. Flax and Haiku use an `apply` method to call modules that set a context with parameters, rng, and different metadata, which adds additional overhead to the API and creates an asymmetry in how Modules are being used inside and outside a context. In Treex, modules can be called directly. * Among different frameworks, parameter surgery requires special consideration and is challenging to implement. Consider a standard workflow such as transfer learning, transferring parameters and state from a pre-trained module or submodule as part of a new module; in different frameworks, we have to know precisely how to extract their parameters and how to insert them into the new parameter structure/dictionaries such that it is in agreement with the new module structure. In Treex, just as in PyTorch / Keras, we enable to pass the (sub)module to the new module, and parameters are automatically added to the new structure. * Multiple frameworks deviate from JAX semantics and require particular versions of `jit`, `grad`, `vmap`, etc., which makes it harder to integrate with other JAX libraries. Treex's Modules are plain old JAX PyTrees and are compatible with any JAX library that supports them. * Other Pytree-based approaches like Parallax and Equinox do not have a total state management solution to handle complex states as encountered in Flax. Treex has the Filter and Update API, which is very expressive and can effectively handle systems with a complex state.","title":"Why Treex?"},{"location":"#installation","text":"Install using pip: pip install treex","title":"Installation"},{"location":"#getting-started","text":"This is a small appetizer to give you a feel for how using Treex looks like, be sure to checkout the User Guide for a more in-depth explanation. import treex as tx import numpy as np import jax , optax # create some data x = np . random . uniform ( size = ( 50 , 1 )) y = 1.3 * x ** 2 - 0.3 + np . random . normal ( size = x . shape ) # initialize a Module, its simple model = tx . MLP ([ 64 , 1 ]) . init ( key = 42 , inputs = x ) # define an optimizer, init with model params optimizer = tx . Optimizer ( optax . adam ( 4e-3 )) . init ( model ) # define loss function, notice # Modules are jit-abel and differentiable \ud83e\udd2f @jax . grad def loss_fn ( model : tx . MLP , x , y ): # forward is a simple call preds = model ( x ) # MSE return (( preds - y ) ** 2 ) . mean () # basic training loop for step in range ( 500 ): # grads have the same type as model grads : tx . MLP = loss_fn ( model , x , y ) # apply the gradient updates model = optimizer . update ( grads , model ) # Pytorch-like eval mode model = model . eval () preds = model ( x )","title":"Getting Started"},{"location":"#custom-modules","text":"Show Modules are Treeo `Tree`s, which are Pytrees. When creating core layers you often mark fields that will contain state that JAX should be aware as `nodes` by assigning class variables to the output of functions like `tx.Parameter.node()`: import treex as tx class Linear ( tx . Module ): # use Treeo's API to define Parameter nodes w : jnp . ndarray = tx . Parameter . node () b : jnp . ndarray = tx . Parameter . node () def __init__ ( self , features_out : int ): self . features_out = features_out def __call__ ( self , x : jnp . ndarray ) -> jnp . ndarray : # init will call forward, we can know if we are inside it if self . initializing (): # `next_key` only available during `init` key = tx . next_key () # leverage shape inference self . w = jax . random . uniform ( key , shape = [ x . shape [ - 1 ], self . features_out ] ) self . b = jnp . zeros ( shape = [ self . features_out ]) # linear forward return jnp . dot ( x , self . w ) + self . b model = Linear ( 10 ) . init ( key = 42 , inputs = x ) Node field types (e.g. `tx.Parameter`) are called Kinds and Treex exports a whole family of Kinds which serve for differente purposes such as holding non-differentiable state (`tx.BatchStats`), metric's state (`tx.MetricState`), logging, etc. Checkout the [kinds](https://cgarciae.github.io/treex/user-guide/kinds) section for more information.","title":"Custom Modules"},{"location":"#composite-modules","text":"Show Composite Modules usually hold and call other Modules within them, while they would be instantiate inside `__init__` and used later in `__call__` like in Pytorch / Keras, in Treex you usually leverage the `@tx.compact` decorator over the `__call__` method to define the submodules inline. class MLP ( tx . Module ): def __init__ ( self , features : Sequence [ int ]): self . features = features # compact lets you define submodules on the fly @tx . compact def __call__ ( self , x : jnp . ndarray ) -> jnp . ndarray : for units in self . features [: - 1 ]: x = Linear ( units )( x ) x = jax . nn . relu ( x ) return Linear ( self . features [ - 1 ])( x ) model = MLP ([ 32 , 10 ]) . init ( key = 42 , inputs = x ) Under the hood all calls to submodule constructors (e.g. `Linear(...)`) inside `compact` are assigned to fields in the parent Module (`MLP`) so they are part of the same Pytree, their field names are available under the `._subtrees` attribute. `compact` must always define submodules in the same order.","title":"Composite Modules"},{"location":"#status","text":"Treex is in an early stage, things might brake between versions but we will respect semanting versioning. Since Treex layers are numerically equivalent to Flax, it borrows some maturity and yields more confidence over its results. Feedback is much appreciated. Roadmap : Wrap all Flax Linen Modules Implement more layers, losses, and metrics. Create applications and pretrained Modules. Contributions are welcomed!","title":"Status"},{"location":"#sponsors","text":"Quansight - paid development time","title":"Sponsors \ud83d\udc9a"},{"location":"#examples","text":"Checkout the /examples directory for more detailed examples. Here are a few additional toy examples:","title":"Examples"},{"location":"#linear-regression","text":"This is a simple but realistic example of how Treex is used. from functools import partial from typing import Union import jax import jax.numpy as jnp import matplotlib.pyplot as plt import numpy as np import optax import treex as tx x = np . random . uniform ( size = ( 500 , 1 )) y = 1.4 * x - 0.3 + np . random . normal ( scale = 0.1 , size = ( 500 , 1 )) # differentiate only w.r.t. parameters def loss_fn ( params , model , x , y ): # merge params into model model = model . merge ( params ) preds = model ( x ) loss = jnp . mean (( preds - y ) ** 2 ) # the model may contain state updates # so it should be returned return loss , model grad_fn = jax . value_and_grad ( loss_fn , has_aux = True ) # both model and optimizer are jit-able @jax . jit def train_step ( model , x , y , optimizer ): # select only the parameters params = model . parameters () ( loss , model ), grads = grad_fn ( params , model , x , y ) # update params and model params = optimizer . update ( grads , params ) model = model . merge ( params ) # return new model and optimizer return loss , model , optimizer model = tx . Linear ( 1 ) . init ( 42 , x ) optimizer = tx . Optimizer ( optax . adam ( 0.01 )) . init ( model ) for step in range ( 300 ): loss , model , optimizer = train_step ( model , x , y , optimizer ) if step % 50 == 0 : print ( f \"loss: { loss : .4f } \" ) # eval mode \"turns off\" layers like Dropout / BatchNorm model = model . eval () X_test = np . linspace ( x . min (), x . max (), 100 )[:, None ] preds = model ( X_test ) plt . scatter ( x , y , c = \"k\" , label = \"data\" ) plt . plot ( X_test , preds , c = \"b\" , linewidth = 2 , label = \"prediction\" ) plt . legend () plt . show ()","title":"Linear Regression"},{"location":"#a-stateful-module","text":"Here is an example of creating a stateful module of a RollingMean metric and using them with jax.jit . For a real use cases use the metrics inside treex.metrics . class RollingMean ( tx . Module ): count : jnp . ndarray = tx . State . node () total : jnp . ndarray = tx . State . node () def __init__ ( self ): self . count = jnp . array ( 0 , dtype = jnp . int32 ) self . total = jnp . array ( 0.0 , dtype = jnp . float32 ) def __call__ ( self , x : jnp . ndarray ) -> jnp . ndarray : self . count += np . prod ( x . shape ) self . total += x . sum () return self . total / self . count @jax . jit def update ( x : jnp . ndarray , metric : RollingMean ) -> Tuple [ jnp . ndarray , RollingMean ]: mean = metric ( x ) return mean , metric # return mean value and updated metric metric = RollingMean () for i in range ( 10 ): x = np . random . uniform ( - 1 , 1 , size = ( 100 , 1 )) mean , metric = update ( x , metric ) print ( mean )","title":"A Stateful Module"},{"location":"api/Apply/","text":"treex.Apply Mixin that adds a .apply() method to the class. apply ( self , f , * rest , * , inplace = False ) apply is a wrapper over treeo.apply that passes self as the second argument. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treeo/mixins.py def apply ( self : A , f : tp . Callable [ ... , None ], * rest : A , inplace : bool = False ) -> A : \"\"\" `apply` is a wrapper over `treeo.apply` that passes `self` as the second argument. Arguments: f: The function to apply. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" return api . apply ( f , self , * rest , inplace = inplace )","title":"Apply"},{"location":"api/Apply/#treexapply","text":"Mixin that adds a .apply() method to the class.","title":"treex.Apply"},{"location":"api/Apply/#treeo.mixins.Apply.apply","text":"apply is a wrapper over treeo.apply that passes self as the second argument. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treeo/mixins.py def apply ( self : A , f : tp . Callable [ ... , None ], * rest : A , inplace : bool = False ) -> A : \"\"\" `apply` is a wrapper over `treeo.apply` that passes `self` as the second argument. Arguments: f: The function to apply. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" return api . apply ( f , self , * rest , inplace = inplace )","title":"apply()"},{"location":"api/BatchNorm/","text":"treex.BatchNorm BatchNorm Module. BatchNorm is implemented as a wrapper over flax.linen.BatchNorm , its constructor arguments accept almost the same arguments including any Flax artifacts such as initializers. Main differences: use_running_average is not a constructor argument, but remains a __call__ argument. self.training state is used to indicate how BatchNorm should behave, interally use_running_average = not self.training or self.frozen is used unless use_running_average is explicitly passed via __call__ . first_run : bool inherited property readonly Returns: Type Description bool True if its currently the first run of a compact method. __class__ inherited __base__ inherited __base__ inherited Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()). __instancecheck__ ( cls , instance ) special Override for isinstance(instance, cls). Source code in treex/nn/batch_norm.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance ) __new__ ( mcls , name , bases , namespace , ** kwargs ) special staticmethod Create and return a new object. See help(type) for accurate signature. Source code in treex/nn/batch_norm.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls __subclasscheck__ ( cls , subclass ) special Override for issubclass(subclass, cls). Source code in treex/nn/batch_norm.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass ) register ( cls , subclass ) Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/batch_norm.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) register ( cls , subclass ) inherited Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/batch_norm.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) register ( cls , subclass ) inherited Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/batch_norm.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) __call__ ( self , x , use_running_average = None ) special Normalizes the input using batch statistics. Parameters: Name Type Description Default x ndarray the input to be normalized. required use_running_average Optional[bool] if true, the statistics stored in batch_stats will be used instead of computing the batch statistics on the input. None Returns: Type Description ndarray Normalized inputs (the same shape as inputs). Source code in treex/nn/batch_norm.py def __call__ ( self , x : jnp . ndarray , use_running_average : tp . Optional [ bool ] = None ) -> jnp . ndarray : \"\"\"Normalizes the input using batch statistics. Arguments: x: the input to be normalized. use_running_average: if true, the statistics stored in batch_stats will be used instead of computing the batch statistics on the input. Returns: Normalized inputs (the same shape as inputs). \"\"\" if self . initializing (): variables = self . module . init ( next_key (), x , use_running_average = True , ) . unfreeze () # Extract collections if \"params\" in variables : params = variables [ \"params\" ] if self . use_bias : self . bias = params [ \"bias\" ] if self . use_scale : self . scale = params [ \"scale\" ] self . mean = variables [ \"batch_stats\" ][ \"mean\" ] self . var = variables [ \"batch_stats\" ][ \"var\" ] params = {} if self . use_bias : params [ \"bias\" ] = self . bias if self . use_scale : params [ \"scale\" ] = self . scale variables = dict ( batch_stats = dict ( mean = self . mean , var = self . var , ), params = params , ) # use_running_average = True means batch_stats will not be mutated # self.training = True means batch_stats will be mutated training = ( not use_running_average if use_running_average is not None else self . training and not self . frozen and self . initialized ) # call apply output , variables = self . module . apply ( variables , x , mutable = [ \"batch_stats\" ] if training else [], use_running_average = not training , ) variables = variables . unfreeze () # update batch_stats if \"batch_stats\" in variables : self . mean = variables [ \"batch_stats\" ][ \"mean\" ] self . var = variables [ \"batch_stats\" ][ \"var\" ] return tp . cast ( jnp . ndarray , output ) __init__ ( self , * , axis =- 1 , momentum = 0.99 , epsilon = 1e-05 , dtype =< class ' jax . _src . numpy . lax_numpy . float32 '>, use_bias=True, use_scale=True, bias_init=<function zeros at 0x7f29d70075e0>, scale_init=<function ones at 0x7f29d7007700>, axis_name=None, axis_index_groups=None) special Parameters: Name Type Description Default features_in the number of input features. required axis int the feature or non-batch axis of the input. -1 momentum Union[float, jax._src.numpy.lax_numpy.ndarray] decay rate for the exponential moving average of the batch statistics. 0.99 epsilon float a small float added to variance to avoid dividing by zero. 1e-05 dtype Any the dtype of the computation (default: float32). <class 'jax._src.numpy.lax_numpy.float32'> use_bias bool if True, bias (beta) is added. True use_scale bool if True, multiply by scale (gamma). When the next layer is linear (also e.g. nn.relu), this can be disabled since the scaling will be done by the next layer. True bias_init Callable[[Any, Tuple[int], Any], Any] initializer for bias, by default, zero. <function zeros at 0x7f29d70075e0> scale_init Callable[[Any, Tuple[int], Any], Any] initializer for scale, by default, one. <function ones at 0x7f29d7007700> axis_name Optional[str] the axis name used to combine batch statistics from multiple devices. See jax.pmap for a description of axis names (default: None). None axis_index_groups Any groups of axis indices within that named axis representing subsets of devices to reduce over (default: None). For example, [[0, 1], [2, 3]] would independently batch-normalize over the examples on the first two and last two devices. See jax.lax.psum for more details. None Source code in treex/nn/batch_norm.py def __init__ ( self , * , axis : int = - 1 , momentum : tp . Union [ float , jnp . ndarray ] = 0.99 , epsilon : float = 1e-5 , dtype : flax_module . Dtype = jnp . float32 , use_bias : bool = True , use_scale : bool = True , bias_init : tp . Callable [ [ flax_module . PRNGKey , flax_module . Shape , flax_module . Dtype ], flax_module . Array , ] = flax_module . initializers . zeros , scale_init : tp . Callable [ [ flax_module . PRNGKey , flax_module . Shape , flax_module . Dtype ], flax_module . Array , ] = flax_module . initializers . ones , axis_name : tp . Optional [ str ] = None , axis_index_groups : tp . Any = None , ): \"\"\" Arguments: features_in: the number of input features. axis: the feature or non-batch axis of the input. momentum: decay rate for the exponential moving average of the batch statistics. epsilon: a small float added to variance to avoid dividing by zero. dtype: the dtype of the computation (default: float32). use_bias: if True, bias (beta) is added. use_scale: if True, multiply by scale (gamma). When the next layer is linear (also e.g. nn.relu), this can be disabled since the scaling will be done by the next layer. bias_init: initializer for bias, by default, zero. scale_init: initializer for scale, by default, one. axis_name: the axis name used to combine batch statistics from multiple devices. See `jax.pmap` for a description of axis names (default: None). axis_index_groups: groups of axis indices within that named axis representing subsets of devices to reduce over (default: None). For example, `[[0, 1], [2, 3]]` would independently batch-normalize over the examples on the first two and last two devices. See `jax.lax.psum` for more details. \"\"\" self . axis = axis self . momentum = jnp . asarray ( momentum ) self . epsilon = epsilon self . dtype = dtype self . use_bias = use_bias self . use_scale = use_scale self . bias_init = bias_init self . scale_init = scale_init self . axis_name = axis_name self . axis_index_groups = axis_index_groups self . mean = None self . var = None self . scale = None self . bias = None apply ( self , f , * rest , * , inplace = False ) inherited apply is a wrapper over treeo.apply that passes self as the second argument. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treex/nn/batch_norm.py def apply ( self : A , f : tp . Callable [ ... , None ], * rest : A , inplace : bool = False ) -> A : \"\"\" `apply` is a wrapper over `treeo.apply` that passes `self` as the second argument. Arguments: f: The function to apply. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" return api . apply ( f , self , * rest , inplace = inplace ) batch_stats ( self , * filters ) inherited Returns a copy of the Module with only tx.BatchStat TreeParts, alias for filter(tx.BatchStat) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/batch_norm.py def batch_stats ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.BatchStat TreeParts, alias for `filter(tx.BatchStat)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . BatchStat , * filters ) check_metadata_updates ( self ) inherited Checks for new fields, if found, adds them to the metadata. Source code in treex/nn/batch_norm.py def check_metadata_updates ( self ): \"\"\" Checks for new fields, if found, adds them to the metadata. \"\"\" with _CONTEXT . update ( flatten_mode = FlattenMode . all_fields ): jax . tree_flatten ( self ) copy ( self ) inherited copy is a wrapper over treeo.copy that passes self as the first argument. Source code in treex/nn/batch_norm.py def copy ( self : A ) -> A : \"\"\" `copy` is a wrapper over `treeo.copy` that passes `self` as the first argument. \"\"\" return tree_m . copy ( self ) eval ( self , inplace = False ) inherited Creates a new module with the training mode set to False, equivalent to calling train(False) . Returns: Type Description ~T The new module with the training mode set to False. Source code in treex/nn/batch_norm.py def eval ( self : T , inplace : bool = False ) -> T : \"\"\" Creates a new module with the training mode set to False, equivalent to calling `train(False)`. Returns: The new module with the training mode set to False. \"\"\" return self . train ( False , inplace = inplace ) filter ( self , * filters , * , inplace = False , flatten_mode = None ) inherited filter is a wrapper over treeo.filter that passes self as the first argument. Parameters: Name Type Description Default *filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treex/nn/batch_norm.py def filter ( self : A , * filters : api . Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ) -> A : \"\"\" `filter` is a wrapper over `treeo.filter` that passes `self` as the first argument. Arguments: *filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" return api . filter ( self , * filters , inplace = inplace , flatten_mode = flatten_mode ) freeze ( self , mode = True , inplace = False ) inherited Creates a new module with the same structure, but with Module.frozen set to the given value. Parameters: Name Type Description Default mode bool The new frozen mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module in with the frozen mode is set to the given value, if inplace is True then self is returned. Source code in treex/nn/batch_norm.py def freeze ( self : T , mode : bool = True , inplace : bool = False ) -> T : \"\"\" Creates a new module with the same structure, but with `Module.frozen` set to the given value. Arguments: mode: The new `frozen` mode. inplace: Whether to update the module inplace. Returns: The new module in with the `frozen` mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_frozen ( tree ): if isinstance ( tree , Treex ) and hasattr ( tree , \"_frozen\" ): tree . _frozen = mode return to . apply ( set_frozen , self , inplace = inplace ) get_field ( self , field_name , initializer ) inherited A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: The field must be declared in the class definition. The method can only be called inside a compact context. Parameters: Name Type Description Default field_name str The name of the field to get. required initializer Callable[[], ~A] The function to initialize the field if it does not exist. required Returns: Type Description ~A The field value. Source code in treex/nn/batch_norm.py def get_field ( self , field_name : str , initializer : tp . Callable [[], A ], ) -> A : \"\"\" A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: * The field must be declared in the class definition. * The method can only be called inside a `compact` context. Arguments: field_name: The name of the field to get. initializer: The function to initialize the field if it does not exist. Returns: The field value. \"\"\" value : A if field_name not in self . _field_metadata : raise ValueError ( f \"Metadata for field ' { field_name } ' does not exist.\" ) if field_name in vars ( self ): value = getattr ( self , field_name ) else : if tree_m . _COMPACT_CONTEXT . in_compact and not self . first_run : raise RuntimeError ( f \"Trying to initialize field ' { field_name } ' after the first run of `compact`.\" ) value = initializer () setattr ( self , field_name , value ) return value init ( self , key , inputs =< treeo . types . Missing object at 0x7f29ce5c9220 > , call_method = '__call__' , * , inplace = False , _set_initialize = True ) inherited Method version of tx.init , it applies self as first argument. init creates a new module with the same structure, but with its fields initialized given a seed key . The following procedure is used: The input key is split and iteratively updated before passing a derived value to any process that requires initialization. Initializer s are called and applied to the module first. Module.rng_init methods are called last. Parameters: Name Type Description Default key Union[int, jax._src.numpy.lax_numpy.ndarray] The seed to use for initialization. required Returns: Type Description ~M The new module with the fields initialized. Source code in treex/nn/batch_norm.py def init ( self : M , key : tp . Union [ int , jnp . ndarray ], inputs : types . InputLike = to . MISSING , call_method : str = \"__call__\" , * , inplace : bool = False , _set_initialize : bool = True , ) -> M : \"\"\" Method version of `tx.init`, it applies `self` as first argument. `init` creates a new module with the same structure, but with its fields initialized given a seed `key`. The following procedure is used: 1. The input `key` is split and iteratively updated before passing a derived value to any process that requires initialization. 2. `Initializer`s are called and applied to the module first. 3. `Module.rng_init` methods are called last. Arguments: key: The seed to use for initialization. Returns: The new module with the fields initialized. \"\"\" module = self . copy () if not inplace else self key = utils . Key ( key ) with _INIT_CONTEXT . update ( key = key , initializing = True ): module : M = module . map ( lambda initializer : ( initializer ( next_key ()) if isinstance ( initializer , types . Initializer ) else initializer ), is_leaf = lambda x : isinstance ( x , types . Initializer ), inplace = True , ) def call_rng_init ( module : Module ): if isinstance ( module , Module ) and not module . _initialized : module . rng_init () module = to . apply ( call_rng_init , module , inplace = True ) if inputs is not to . MISSING : inputs = types . Inputs . from_value ( inputs ) method = getattr ( module , call_method ) method ( * inputs . args , ** inputs . kwargs ) if _set_initialize : def set_initialized ( module : Module ): if isinstance ( module , Module ) and not module . _initialized : module . _initialized = True module = to . apply ( set_initialized , module , inplace = True ) return module logs ( self , * filters ) inherited Returns a copy of the Module with only tx.Log TreeParts, alias for filter(tx.Log) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/batch_norm.py def logs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Log TreeParts, alias for `filter(tx.Log)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . Log , * filters ) loss_logs ( self , * filters ) inherited Returns a copy of the Module with only tx.Loss TreeParts, alias for filter(tx.Loss) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/batch_norm.py def loss_logs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Loss TreeParts, alias for `filter(tx.Loss)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . LossLog , * filters ) map ( self , f , * filters , * , inplace = False , flatten_mode = None , is_leaf = None ) inherited map is a wrapper over treeo.map that passes self as the second argument. Parameters: Name Type Description Default f Callable The function to apply to the leaves. required *filters Filter The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treex/nn/batch_norm.py def map ( self : A , f : tp . Callable , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , is_leaf : tp . Callable [[ tp . Any ], bool ] = None , ) -> A : \"\"\" `map` is a wrapper over `treeo.map` that passes `self` as the second argument. Arguments: f: The function to apply to the leaves. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" return api . map ( f , self , * filters , inplace = inplace , flatten_mode = flatten_mode , is_leaf = is_leaf , ) merge ( self , other , * rest , * , inplace = False , flatten_mode = None , ignore_static = False ) inherited merge is a wrapper over treeo.merge that passes self as the first argument. Parameters: Name Type Description Default other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the merged values. If inplace is True , obj is returned. Source code in treex/nn/batch_norm.py def merge ( self : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" `merge` is a wrapper over `treeo.merge` that passes `self` as the first argument. Arguments: other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the merged values. If `inplace` is `True`, `obj` is returned. \"\"\" return api . merge ( self , other , * rest , inplace = inplace , flatten_mode = flatten_mode , ignore_static = ignore_static , ) metric_logs ( self , * filters ) inherited Returns a copy of the Module with only tx.Metric TreeParts, alias for filter(tx.Metric) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/batch_norm.py def metric_logs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Metric TreeParts, alias for `filter(tx.Metric)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . MetricLog , * filters ) model_states ( self , * filters ) inherited Returns a copy of the Module with only tx.ModelState TreeParts, alias for filter(tx.ModelState) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/batch_norm.py def model_states ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.ModelState TreeParts, alias for `filter(tx.ModelState)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . ModelState , * filters ) parameters ( self , * filters ) inherited Returns a copy of the Module with only tx.Parameter TreeParts, alias for filter(tx.Parameter) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/batch_norm.py def parameters ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Parameter TreeParts, alias for `filter(tx.Parameter)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . Parameter , * filters ) rngs ( self , * filters ) inherited Returns a copy of the Module with only tx.Rng TreeParts, alias for filter(tx.Rng) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/batch_norm.py def rngs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Rng TreeParts, alias for `filter(tx.Rng)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . Rng , * filters ) states ( self , * filters ) inherited Returns a copy of the Module with only tx.State TreeParts, alias for filter(tx.State) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/batch_norm.py def states ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.State TreeParts, alias for `filter(tx.State)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . State , * filters ) tabulate ( self , inputs =< treeo . types . Missing object at 0x7f29ce5c9220 > , depth =- 1 , signature = False , param_types = True ) inherited Returns a tabular representation of the module. Parameters: Name Type Description Default depth int The maximum depth of the representation in terms of nested Modules, -1 means no limit. -1 signature bool Whether to show the signature of the Module. False param_types bool Whether to show the types of the parameters. True Returns: Type Description str A string containing the tabular representation. Source code in treex/nn/batch_norm.py def tabulate ( self , inputs : tp . Union [ types . InputLike , to . Missing ] = to . MISSING , depth : int = - 1 , signature : bool = False , param_types : bool = True , ) -> str : \"\"\" Returns a tabular representation of the module. Arguments: depth: The maximum depth of the representation in terms of nested Modules, -1 means no limit. signature: Whether to show the signature of the Module. param_types: Whether to show the types of the parameters. Returns: A string containing the tabular representation. \"\"\" self = to . copy ( self ) if inputs is not to . MISSING : inputs = types . Inputs . from_value ( inputs ) if not isinstance ( self , tp . Callable ): raise TypeError ( \"`inputs` can only be specified if the module is a callable.\" ) with contexts . _Context ( call_info = {}): # call using self to preserve references def eval_call ( args , kwargs ): assert isinstance ( self , tp . Callable ) return self ( * args , ** kwargs ) jax . eval_shape ( eval_call , inputs . args , inputs . kwargs , ) call_info = contexts . _CONTEXT . call_info else : call_info = None with to . add_field_info (): flat : tp . List [ to . FieldInfo ] flat , _ = jax . tree_flatten ( self ) tree_part_types : tp . Tuple [ tp . Type [ types . TreePart ], ... ] = tuple ( { field_info . kind for field_info in flat if utils . _generic_issubclass ( field_info . kind , types . TreePart ) } ) path = () rows = list ( utils . _get_tabulate_rows ( path , self , depth , tree_part_types , signature , param_types ) ) modules = [ row [ 0 ] for row in rows ] rows = [ row [ 1 :] for row in rows ] if call_info is not None : for module , row in zip ( modules , rows ): if module in call_info : inputs , outputs = call_info [ module ] simplified_inputs = ( inputs . args [ 0 ] if len ( inputs . kwargs ) == 0 and len ( inputs . args ) == 1 else inputs . kwargs if len ( inputs . kwargs ) == 0 else inputs . kwargs if len ( inputs . args ) == 0 else ( inputs . args , inputs . kwargs ) ) inputs_repr = utils . _format_param_tree ( simplified_inputs ) outputs_repr = utils . _format_param_tree ( outputs ) else : inputs_repr = \"\" outputs_repr = \"\" row . insert ( 3 , outputs_repr ) row . insert ( 3 , inputs_repr ) n_non_treepart_cols = 2 if call_info is None else 4 rows [ 0 ][ 0 ] = \"*\" rows . append ( [ \"\" ] * n_non_treepart_cols + [ \"Total:\" ] + [ utils . _format_obj_size ( self . filter ( kind ), add_padding = True ) for kind in tree_part_types ] ) utils . _add_padding ( rows ) table = Table ( show_header = True , show_lines = True , show_footer = True , # box=rich.box.HORIZONTALS, ) table . add_column ( \"path\" ) table . add_column ( \"module\" ) table . add_column ( \"params\" ) if call_info is not None : table . add_column ( \"inputs\" ) table . add_column ( \"outputs\" ) for tree_part_type in tree_part_types : type_name = tree_part_type . __name__ if type_name . startswith ( \"_\" ): type_name = type_name [ 1 :] table . add_column ( type_name ) for row in rows [: - 1 ]: table . add_row ( * row ) table . columns [ n_non_treepart_cols ] . footer = Text . from_markup ( rows [ - 1 ][ n_non_treepart_cols ], justify = \"right\" ) for i in range ( len ( tree_part_types )): table . columns [ n_non_treepart_cols + 1 + i ] . footer = rows [ - 1 ][ n_non_treepart_cols + 1 + i ] table . caption_style = \"bold\" table . caption = \" \\n Total Parameters: \" + utils . _format_obj_size ( self , add_padding = False ) return utils . _get_rich_repr ( table ) to_dict ( self , * , private_fields = False , static_fields = True , type_info = False , field_info = False ) inherited to_dict is a wrapper over treeo.to_dict that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True type_info bool If True , type information is included. False field_info bool If True , field information is included. False Returns: Type Description Any A dict representation of the object. Source code in treex/nn/batch_norm.py def to_dict ( self , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : \"\"\" `to_dict` is a wrapper over `treeo.to_dict` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. type_info: If `True`, type information is included. field_info: If `True`, field information is included. Returns: A dict representation of the object. \"\"\" return api . to_dict ( self , private_fields = private_fields , static_fields = static_fields , type_info = type_info , field_info = field_info , ) to_string ( self , * , private_fields = False , static_fields = True , color = False ) inherited to_string is a wrapper over treeo.to_string that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True color bool If True , color is included. False Returns: Type Description str A string representation of the object. Source code in treex/nn/batch_norm.py def to_string ( self : A , * , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" `to_string` is a wrapper over `treeo.to_string` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. color: If `True`, color is included. Returns: A string representation of the object. \"\"\" return api . to_string ( self , private_fields = private_fields , static_fields = static_fields , color = color , ) train ( self , mode = True , inplace = False ) inherited Creates a new module with the same structure, but with Module.training set to the given value. Parameters: Name Type Description Default mode bool The new training mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module in with the training mode is set to the given value, if inplace is True then self is returned. Source code in treex/nn/batch_norm.py def train ( self : T , mode : bool = True , inplace : bool = False ) -> T : \"\"\" Creates a new module with the same structure, but with `Module.training` set to the given value. Arguments: mode: The new training mode. inplace: Whether to update the module inplace. Returns: The new module in with the training mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_training ( tree ): if isinstance ( tree , Treex ) and hasattr ( tree , \"_training\" ): tree . _training = mode return to . apply ( set_training , self , inplace = inplace ) unfreeze ( self , inplace = False ) inherited Creates a new module with .frozen set to False, equivalent to calling freeze(False) . Parameters: Name Type Description Default inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module with .frozen set to False, if inplace is True then self is returned. Source code in treex/nn/batch_norm.py def unfreeze ( self : T , inplace : bool = False ) -> T : \"\"\" Creates a new module with `.frozen` set to False, equivalent to calling `freeze(False)`. Arguments: inplace: Whether to update the module inplace. Returns: The new module with `.frozen` set to False, if `inplace` is `True` then `self` is returned. \"\"\" return self . freeze ( False , inplace = inplace )","title":"BatchNorm"},{"location":"api/BatchNorm/#treexbatchnorm","text":"BatchNorm Module. BatchNorm is implemented as a wrapper over flax.linen.BatchNorm , its constructor arguments accept almost the same arguments including any Flax artifacts such as initializers. Main differences: use_running_average is not a constructor argument, but remains a __call__ argument. self.training state is used to indicate how BatchNorm should behave, interally use_running_average = not self.training or self.frozen is used unless use_running_average is explicitly passed via __call__ .","title":"treex.BatchNorm"},{"location":"api/BatchNorm/#treex.nn.batch_norm.BatchNorm.first_run","text":"Returns: Type Description bool True if its currently the first run of a compact method.","title":"first_run"},{"location":"api/BatchNorm/#treex.nn.batch_norm.BatchNorm.__class__","text":"","title":"__class__"},{"location":"api/BatchNorm/#treex.nn.batch_norm.BatchNorm.__class__.__base__","text":"","title":"__base__"},{"location":"api/BatchNorm/#treex.nn.batch_norm.BatchNorm.__class__.__base__.__base__","text":"Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()).","title":"__base__"},{"location":"api/BatchNorm/#treex.nn.batch_norm.BatchNorm.__class__.__base__.__base__.__instancecheck__","text":"Override for isinstance(instance, cls). Source code in treex/nn/batch_norm.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance )","title":"__instancecheck__()"},{"location":"api/BatchNorm/#treex.nn.batch_norm.BatchNorm.__class__.__base__.__base__.__new__","text":"Create and return a new object. See help(type) for accurate signature. Source code in treex/nn/batch_norm.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls","title":"__new__()"},{"location":"api/BatchNorm/#treex.nn.batch_norm.BatchNorm.__class__.__base__.__base__.__subclasscheck__","text":"Override for issubclass(subclass, cls). Source code in treex/nn/batch_norm.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass )","title":"__subclasscheck__()"},{"location":"api/BatchNorm/#treex.nn.batch_norm.BatchNorm.__class__.__base__.__base__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/batch_norm.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/BatchNorm/#treex.nn.batch_norm.BatchNorm.__class__.__base__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/batch_norm.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/BatchNorm/#treex.nn.batch_norm.BatchNorm.__class__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/batch_norm.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/BatchNorm/#treex.nn.batch_norm.BatchNorm.__call__","text":"Normalizes the input using batch statistics. Parameters: Name Type Description Default x ndarray the input to be normalized. required use_running_average Optional[bool] if true, the statistics stored in batch_stats will be used instead of computing the batch statistics on the input. None Returns: Type Description ndarray Normalized inputs (the same shape as inputs). Source code in treex/nn/batch_norm.py def __call__ ( self , x : jnp . ndarray , use_running_average : tp . Optional [ bool ] = None ) -> jnp . ndarray : \"\"\"Normalizes the input using batch statistics. Arguments: x: the input to be normalized. use_running_average: if true, the statistics stored in batch_stats will be used instead of computing the batch statistics on the input. Returns: Normalized inputs (the same shape as inputs). \"\"\" if self . initializing (): variables = self . module . init ( next_key (), x , use_running_average = True , ) . unfreeze () # Extract collections if \"params\" in variables : params = variables [ \"params\" ] if self . use_bias : self . bias = params [ \"bias\" ] if self . use_scale : self . scale = params [ \"scale\" ] self . mean = variables [ \"batch_stats\" ][ \"mean\" ] self . var = variables [ \"batch_stats\" ][ \"var\" ] params = {} if self . use_bias : params [ \"bias\" ] = self . bias if self . use_scale : params [ \"scale\" ] = self . scale variables = dict ( batch_stats = dict ( mean = self . mean , var = self . var , ), params = params , ) # use_running_average = True means batch_stats will not be mutated # self.training = True means batch_stats will be mutated training = ( not use_running_average if use_running_average is not None else self . training and not self . frozen and self . initialized ) # call apply output , variables = self . module . apply ( variables , x , mutable = [ \"batch_stats\" ] if training else [], use_running_average = not training , ) variables = variables . unfreeze () # update batch_stats if \"batch_stats\" in variables : self . mean = variables [ \"batch_stats\" ][ \"mean\" ] self . var = variables [ \"batch_stats\" ][ \"var\" ] return tp . cast ( jnp . ndarray , output )","title":"__call__()"},{"location":"api/BatchNorm/#treex.nn.batch_norm.BatchNorm.__init__","text":"Parameters: Name Type Description Default features_in the number of input features. required axis int the feature or non-batch axis of the input. -1 momentum Union[float, jax._src.numpy.lax_numpy.ndarray] decay rate for the exponential moving average of the batch statistics. 0.99 epsilon float a small float added to variance to avoid dividing by zero. 1e-05 dtype Any the dtype of the computation (default: float32). <class 'jax._src.numpy.lax_numpy.float32'> use_bias bool if True, bias (beta) is added. True use_scale bool if True, multiply by scale (gamma). When the next layer is linear (also e.g. nn.relu), this can be disabled since the scaling will be done by the next layer. True bias_init Callable[[Any, Tuple[int], Any], Any] initializer for bias, by default, zero. <function zeros at 0x7f29d70075e0> scale_init Callable[[Any, Tuple[int], Any], Any] initializer for scale, by default, one. <function ones at 0x7f29d7007700> axis_name Optional[str] the axis name used to combine batch statistics from multiple devices. See jax.pmap for a description of axis names (default: None). None axis_index_groups Any groups of axis indices within that named axis representing subsets of devices to reduce over (default: None). For example, [[0, 1], [2, 3]] would independently batch-normalize over the examples on the first two and last two devices. See jax.lax.psum for more details. None Source code in treex/nn/batch_norm.py def __init__ ( self , * , axis : int = - 1 , momentum : tp . Union [ float , jnp . ndarray ] = 0.99 , epsilon : float = 1e-5 , dtype : flax_module . Dtype = jnp . float32 , use_bias : bool = True , use_scale : bool = True , bias_init : tp . Callable [ [ flax_module . PRNGKey , flax_module . Shape , flax_module . Dtype ], flax_module . Array , ] = flax_module . initializers . zeros , scale_init : tp . Callable [ [ flax_module . PRNGKey , flax_module . Shape , flax_module . Dtype ], flax_module . Array , ] = flax_module . initializers . ones , axis_name : tp . Optional [ str ] = None , axis_index_groups : tp . Any = None , ): \"\"\" Arguments: features_in: the number of input features. axis: the feature or non-batch axis of the input. momentum: decay rate for the exponential moving average of the batch statistics. epsilon: a small float added to variance to avoid dividing by zero. dtype: the dtype of the computation (default: float32). use_bias: if True, bias (beta) is added. use_scale: if True, multiply by scale (gamma). When the next layer is linear (also e.g. nn.relu), this can be disabled since the scaling will be done by the next layer. bias_init: initializer for bias, by default, zero. scale_init: initializer for scale, by default, one. axis_name: the axis name used to combine batch statistics from multiple devices. See `jax.pmap` for a description of axis names (default: None). axis_index_groups: groups of axis indices within that named axis representing subsets of devices to reduce over (default: None). For example, `[[0, 1], [2, 3]]` would independently batch-normalize over the examples on the first two and last two devices. See `jax.lax.psum` for more details. \"\"\" self . axis = axis self . momentum = jnp . asarray ( momentum ) self . epsilon = epsilon self . dtype = dtype self . use_bias = use_bias self . use_scale = use_scale self . bias_init = bias_init self . scale_init = scale_init self . axis_name = axis_name self . axis_index_groups = axis_index_groups self . mean = None self . var = None self . scale = None self . bias = None","title":"__init__()"},{"location":"api/BatchNorm/#treex.nn.batch_norm.BatchNorm.apply","text":"apply is a wrapper over treeo.apply that passes self as the second argument. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treex/nn/batch_norm.py def apply ( self : A , f : tp . Callable [ ... , None ], * rest : A , inplace : bool = False ) -> A : \"\"\" `apply` is a wrapper over `treeo.apply` that passes `self` as the second argument. Arguments: f: The function to apply. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" return api . apply ( f , self , * rest , inplace = inplace )","title":"apply()"},{"location":"api/BatchNorm/#treex.nn.batch_norm.BatchNorm.batch_stats","text":"Returns a copy of the Module with only tx.BatchStat TreeParts, alias for filter(tx.BatchStat) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/batch_norm.py def batch_stats ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.BatchStat TreeParts, alias for `filter(tx.BatchStat)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . BatchStat , * filters )","title":"batch_stats()"},{"location":"api/BatchNorm/#treex.nn.batch_norm.BatchNorm.check_metadata_updates","text":"Checks for new fields, if found, adds them to the metadata. Source code in treex/nn/batch_norm.py def check_metadata_updates ( self ): \"\"\" Checks for new fields, if found, adds them to the metadata. \"\"\" with _CONTEXT . update ( flatten_mode = FlattenMode . all_fields ): jax . tree_flatten ( self )","title":"check_metadata_updates()"},{"location":"api/BatchNorm/#treex.nn.batch_norm.BatchNorm.copy","text":"copy is a wrapper over treeo.copy that passes self as the first argument. Source code in treex/nn/batch_norm.py def copy ( self : A ) -> A : \"\"\" `copy` is a wrapper over `treeo.copy` that passes `self` as the first argument. \"\"\" return tree_m . copy ( self )","title":"copy()"},{"location":"api/BatchNorm/#treex.nn.batch_norm.BatchNorm.eval","text":"Creates a new module with the training mode set to False, equivalent to calling train(False) . Returns: Type Description ~T The new module with the training mode set to False. Source code in treex/nn/batch_norm.py def eval ( self : T , inplace : bool = False ) -> T : \"\"\" Creates a new module with the training mode set to False, equivalent to calling `train(False)`. Returns: The new module with the training mode set to False. \"\"\" return self . train ( False , inplace = inplace )","title":"eval()"},{"location":"api/BatchNorm/#treex.nn.batch_norm.BatchNorm.filter","text":"filter is a wrapper over treeo.filter that passes self as the first argument. Parameters: Name Type Description Default *filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treex/nn/batch_norm.py def filter ( self : A , * filters : api . Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ) -> A : \"\"\" `filter` is a wrapper over `treeo.filter` that passes `self` as the first argument. Arguments: *filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" return api . filter ( self , * filters , inplace = inplace , flatten_mode = flatten_mode )","title":"filter()"},{"location":"api/BatchNorm/#treex.nn.batch_norm.BatchNorm.freeze","text":"Creates a new module with the same structure, but with Module.frozen set to the given value. Parameters: Name Type Description Default mode bool The new frozen mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module in with the frozen mode is set to the given value, if inplace is True then self is returned. Source code in treex/nn/batch_norm.py def freeze ( self : T , mode : bool = True , inplace : bool = False ) -> T : \"\"\" Creates a new module with the same structure, but with `Module.frozen` set to the given value. Arguments: mode: The new `frozen` mode. inplace: Whether to update the module inplace. Returns: The new module in with the `frozen` mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_frozen ( tree ): if isinstance ( tree , Treex ) and hasattr ( tree , \"_frozen\" ): tree . _frozen = mode return to . apply ( set_frozen , self , inplace = inplace )","title":"freeze()"},{"location":"api/BatchNorm/#treex.nn.batch_norm.BatchNorm.get_field","text":"A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: The field must be declared in the class definition. The method can only be called inside a compact context. Parameters: Name Type Description Default field_name str The name of the field to get. required initializer Callable[[], ~A] The function to initialize the field if it does not exist. required Returns: Type Description ~A The field value. Source code in treex/nn/batch_norm.py def get_field ( self , field_name : str , initializer : tp . Callable [[], A ], ) -> A : \"\"\" A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: * The field must be declared in the class definition. * The method can only be called inside a `compact` context. Arguments: field_name: The name of the field to get. initializer: The function to initialize the field if it does not exist. Returns: The field value. \"\"\" value : A if field_name not in self . _field_metadata : raise ValueError ( f \"Metadata for field ' { field_name } ' does not exist.\" ) if field_name in vars ( self ): value = getattr ( self , field_name ) else : if tree_m . _COMPACT_CONTEXT . in_compact and not self . first_run : raise RuntimeError ( f \"Trying to initialize field ' { field_name } ' after the first run of `compact`.\" ) value = initializer () setattr ( self , field_name , value ) return value","title":"get_field()"},{"location":"api/BatchNorm/#treex.nn.batch_norm.BatchNorm.init","text":"Method version of tx.init , it applies self as first argument. init creates a new module with the same structure, but with its fields initialized given a seed key . The following procedure is used: The input key is split and iteratively updated before passing a derived value to any process that requires initialization. Initializer s are called and applied to the module first. Module.rng_init methods are called last. Parameters: Name Type Description Default key Union[int, jax._src.numpy.lax_numpy.ndarray] The seed to use for initialization. required Returns: Type Description ~M The new module with the fields initialized. Source code in treex/nn/batch_norm.py def init ( self : M , key : tp . Union [ int , jnp . ndarray ], inputs : types . InputLike = to . MISSING , call_method : str = \"__call__\" , * , inplace : bool = False , _set_initialize : bool = True , ) -> M : \"\"\" Method version of `tx.init`, it applies `self` as first argument. `init` creates a new module with the same structure, but with its fields initialized given a seed `key`. The following procedure is used: 1. The input `key` is split and iteratively updated before passing a derived value to any process that requires initialization. 2. `Initializer`s are called and applied to the module first. 3. `Module.rng_init` methods are called last. Arguments: key: The seed to use for initialization. Returns: The new module with the fields initialized. \"\"\" module = self . copy () if not inplace else self key = utils . Key ( key ) with _INIT_CONTEXT . update ( key = key , initializing = True ): module : M = module . map ( lambda initializer : ( initializer ( next_key ()) if isinstance ( initializer , types . Initializer ) else initializer ), is_leaf = lambda x : isinstance ( x , types . Initializer ), inplace = True , ) def call_rng_init ( module : Module ): if isinstance ( module , Module ) and not module . _initialized : module . rng_init () module = to . apply ( call_rng_init , module , inplace = True ) if inputs is not to . MISSING : inputs = types . Inputs . from_value ( inputs ) method = getattr ( module , call_method ) method ( * inputs . args , ** inputs . kwargs ) if _set_initialize : def set_initialized ( module : Module ): if isinstance ( module , Module ) and not module . _initialized : module . _initialized = True module = to . apply ( set_initialized , module , inplace = True ) return module","title":"init()"},{"location":"api/BatchNorm/#treex.nn.batch_norm.BatchNorm.logs","text":"Returns a copy of the Module with only tx.Log TreeParts, alias for filter(tx.Log) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/batch_norm.py def logs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Log TreeParts, alias for `filter(tx.Log)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . Log , * filters )","title":"logs()"},{"location":"api/BatchNorm/#treex.nn.batch_norm.BatchNorm.loss_logs","text":"Returns a copy of the Module with only tx.Loss TreeParts, alias for filter(tx.Loss) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/batch_norm.py def loss_logs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Loss TreeParts, alias for `filter(tx.Loss)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . LossLog , * filters )","title":"loss_logs()"},{"location":"api/BatchNorm/#treex.nn.batch_norm.BatchNorm.map","text":"map is a wrapper over treeo.map that passes self as the second argument. Parameters: Name Type Description Default f Callable The function to apply to the leaves. required *filters Filter The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treex/nn/batch_norm.py def map ( self : A , f : tp . Callable , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , is_leaf : tp . Callable [[ tp . Any ], bool ] = None , ) -> A : \"\"\" `map` is a wrapper over `treeo.map` that passes `self` as the second argument. Arguments: f: The function to apply to the leaves. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" return api . map ( f , self , * filters , inplace = inplace , flatten_mode = flatten_mode , is_leaf = is_leaf , )","title":"map()"},{"location":"api/BatchNorm/#treex.nn.batch_norm.BatchNorm.merge","text":"merge is a wrapper over treeo.merge that passes self as the first argument. Parameters: Name Type Description Default other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the merged values. If inplace is True , obj is returned. Source code in treex/nn/batch_norm.py def merge ( self : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" `merge` is a wrapper over `treeo.merge` that passes `self` as the first argument. Arguments: other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the merged values. If `inplace` is `True`, `obj` is returned. \"\"\" return api . merge ( self , other , * rest , inplace = inplace , flatten_mode = flatten_mode , ignore_static = ignore_static , )","title":"merge()"},{"location":"api/BatchNorm/#treex.nn.batch_norm.BatchNorm.metric_logs","text":"Returns a copy of the Module with only tx.Metric TreeParts, alias for filter(tx.Metric) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/batch_norm.py def metric_logs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Metric TreeParts, alias for `filter(tx.Metric)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . MetricLog , * filters )","title":"metric_logs()"},{"location":"api/BatchNorm/#treex.nn.batch_norm.BatchNorm.model_states","text":"Returns a copy of the Module with only tx.ModelState TreeParts, alias for filter(tx.ModelState) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/batch_norm.py def model_states ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.ModelState TreeParts, alias for `filter(tx.ModelState)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . ModelState , * filters )","title":"model_states()"},{"location":"api/BatchNorm/#treex.nn.batch_norm.BatchNorm.parameters","text":"Returns a copy of the Module with only tx.Parameter TreeParts, alias for filter(tx.Parameter) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/batch_norm.py def parameters ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Parameter TreeParts, alias for `filter(tx.Parameter)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . Parameter , * filters )","title":"parameters()"},{"location":"api/BatchNorm/#treex.nn.batch_norm.BatchNorm.rngs","text":"Returns a copy of the Module with only tx.Rng TreeParts, alias for filter(tx.Rng) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/batch_norm.py def rngs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Rng TreeParts, alias for `filter(tx.Rng)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . Rng , * filters )","title":"rngs()"},{"location":"api/BatchNorm/#treex.nn.batch_norm.BatchNorm.states","text":"Returns a copy of the Module with only tx.State TreeParts, alias for filter(tx.State) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/batch_norm.py def states ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.State TreeParts, alias for `filter(tx.State)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . State , * filters )","title":"states()"},{"location":"api/BatchNorm/#treex.nn.batch_norm.BatchNorm.tabulate","text":"Returns a tabular representation of the module. Parameters: Name Type Description Default depth int The maximum depth of the representation in terms of nested Modules, -1 means no limit. -1 signature bool Whether to show the signature of the Module. False param_types bool Whether to show the types of the parameters. True Returns: Type Description str A string containing the tabular representation. Source code in treex/nn/batch_norm.py def tabulate ( self , inputs : tp . Union [ types . InputLike , to . Missing ] = to . MISSING , depth : int = - 1 , signature : bool = False , param_types : bool = True , ) -> str : \"\"\" Returns a tabular representation of the module. Arguments: depth: The maximum depth of the representation in terms of nested Modules, -1 means no limit. signature: Whether to show the signature of the Module. param_types: Whether to show the types of the parameters. Returns: A string containing the tabular representation. \"\"\" self = to . copy ( self ) if inputs is not to . MISSING : inputs = types . Inputs . from_value ( inputs ) if not isinstance ( self , tp . Callable ): raise TypeError ( \"`inputs` can only be specified if the module is a callable.\" ) with contexts . _Context ( call_info = {}): # call using self to preserve references def eval_call ( args , kwargs ): assert isinstance ( self , tp . Callable ) return self ( * args , ** kwargs ) jax . eval_shape ( eval_call , inputs . args , inputs . kwargs , ) call_info = contexts . _CONTEXT . call_info else : call_info = None with to . add_field_info (): flat : tp . List [ to . FieldInfo ] flat , _ = jax . tree_flatten ( self ) tree_part_types : tp . Tuple [ tp . Type [ types . TreePart ], ... ] = tuple ( { field_info . kind for field_info in flat if utils . _generic_issubclass ( field_info . kind , types . TreePart ) } ) path = () rows = list ( utils . _get_tabulate_rows ( path , self , depth , tree_part_types , signature , param_types ) ) modules = [ row [ 0 ] for row in rows ] rows = [ row [ 1 :] for row in rows ] if call_info is not None : for module , row in zip ( modules , rows ): if module in call_info : inputs , outputs = call_info [ module ] simplified_inputs = ( inputs . args [ 0 ] if len ( inputs . kwargs ) == 0 and len ( inputs . args ) == 1 else inputs . kwargs if len ( inputs . kwargs ) == 0 else inputs . kwargs if len ( inputs . args ) == 0 else ( inputs . args , inputs . kwargs ) ) inputs_repr = utils . _format_param_tree ( simplified_inputs ) outputs_repr = utils . _format_param_tree ( outputs ) else : inputs_repr = \"\" outputs_repr = \"\" row . insert ( 3 , outputs_repr ) row . insert ( 3 , inputs_repr ) n_non_treepart_cols = 2 if call_info is None else 4 rows [ 0 ][ 0 ] = \"*\" rows . append ( [ \"\" ] * n_non_treepart_cols + [ \"Total:\" ] + [ utils . _format_obj_size ( self . filter ( kind ), add_padding = True ) for kind in tree_part_types ] ) utils . _add_padding ( rows ) table = Table ( show_header = True , show_lines = True , show_footer = True , # box=rich.box.HORIZONTALS, ) table . add_column ( \"path\" ) table . add_column ( \"module\" ) table . add_column ( \"params\" ) if call_info is not None : table . add_column ( \"inputs\" ) table . add_column ( \"outputs\" ) for tree_part_type in tree_part_types : type_name = tree_part_type . __name__ if type_name . startswith ( \"_\" ): type_name = type_name [ 1 :] table . add_column ( type_name ) for row in rows [: - 1 ]: table . add_row ( * row ) table . columns [ n_non_treepart_cols ] . footer = Text . from_markup ( rows [ - 1 ][ n_non_treepart_cols ], justify = \"right\" ) for i in range ( len ( tree_part_types )): table . columns [ n_non_treepart_cols + 1 + i ] . footer = rows [ - 1 ][ n_non_treepart_cols + 1 + i ] table . caption_style = \"bold\" table . caption = \" \\n Total Parameters: \" + utils . _format_obj_size ( self , add_padding = False ) return utils . _get_rich_repr ( table )","title":"tabulate()"},{"location":"api/BatchNorm/#treex.nn.batch_norm.BatchNorm.to_dict","text":"to_dict is a wrapper over treeo.to_dict that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True type_info bool If True , type information is included. False field_info bool If True , field information is included. False Returns: Type Description Any A dict representation of the object. Source code in treex/nn/batch_norm.py def to_dict ( self , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : \"\"\" `to_dict` is a wrapper over `treeo.to_dict` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. type_info: If `True`, type information is included. field_info: If `True`, field information is included. Returns: A dict representation of the object. \"\"\" return api . to_dict ( self , private_fields = private_fields , static_fields = static_fields , type_info = type_info , field_info = field_info , )","title":"to_dict()"},{"location":"api/BatchNorm/#treex.nn.batch_norm.BatchNorm.to_string","text":"to_string is a wrapper over treeo.to_string that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True color bool If True , color is included. False Returns: Type Description str A string representation of the object. Source code in treex/nn/batch_norm.py def to_string ( self : A , * , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" `to_string` is a wrapper over `treeo.to_string` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. color: If `True`, color is included. Returns: A string representation of the object. \"\"\" return api . to_string ( self , private_fields = private_fields , static_fields = static_fields , color = color , )","title":"to_string()"},{"location":"api/BatchNorm/#treex.nn.batch_norm.BatchNorm.train","text":"Creates a new module with the same structure, but with Module.training set to the given value. Parameters: Name Type Description Default mode bool The new training mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module in with the training mode is set to the given value, if inplace is True then self is returned. Source code in treex/nn/batch_norm.py def train ( self : T , mode : bool = True , inplace : bool = False ) -> T : \"\"\" Creates a new module with the same structure, but with `Module.training` set to the given value. Arguments: mode: The new training mode. inplace: Whether to update the module inplace. Returns: The new module in with the training mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_training ( tree ): if isinstance ( tree , Treex ) and hasattr ( tree , \"_training\" ): tree . _training = mode return to . apply ( set_training , self , inplace = inplace )","title":"train()"},{"location":"api/BatchNorm/#treex.nn.batch_norm.BatchNorm.unfreeze","text":"Creates a new module with .frozen set to False, equivalent to calling freeze(False) . Parameters: Name Type Description Default inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module with .frozen set to False, if inplace is True then self is returned. Source code in treex/nn/batch_norm.py def unfreeze ( self : T , inplace : bool = False ) -> T : \"\"\" Creates a new module with `.frozen` set to False, equivalent to calling `freeze(False)`. Arguments: inplace: Whether to update the module inplace. Returns: The new module with `.frozen` set to False, if `inplace` is `True` then `self` is returned. \"\"\" return self . freeze ( False , inplace = inplace )","title":"unfreeze()"},{"location":"api/BatchStat/","text":"treex.BatchStat","title":"BatchStat"},{"location":"api/BatchStat/#treexbatchstat","text":"","title":"treex.BatchStat"},{"location":"api/Cache/","text":"treex.Cache","title":"Cache"},{"location":"api/Cache/#treexcache","text":"","title":"treex.Cache"},{"location":"api/Compact/","text":"treex.Compact first_run : bool property readonly Returns: Type Description bool True if its currently the first run of a compact method. get_field ( self , field_name , initializer ) A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: The field must be declared in the class definition. The method can only be called inside a compact context. Parameters: Name Type Description Default field_name str The name of the field to get. required initializer Callable[[], ~A] The function to initialize the field if it does not exist. required Returns: Type Description ~A The field value. Source code in treeo/mixins.py def get_field ( self , field_name : str , initializer : tp . Callable [[], A ], ) -> A : \"\"\" A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: * The field must be declared in the class definition. * The method can only be called inside a `compact` context. Arguments: field_name: The name of the field to get. initializer: The function to initialize the field if it does not exist. Returns: The field value. \"\"\" value : A if field_name not in self . _field_metadata : raise ValueError ( f \"Metadata for field ' { field_name } ' does not exist.\" ) if field_name in vars ( self ): value = getattr ( self , field_name ) else : if tree_m . _COMPACT_CONTEXT . in_compact and not self . first_run : raise RuntimeError ( f \"Trying to initialize field ' { field_name } ' after the first run of `compact`.\" ) value = initializer () setattr ( self , field_name , value ) return value","title":"Compact"},{"location":"api/Compact/#treexcompact","text":"","title":"treex.Compact"},{"location":"api/Compact/#treeo.mixins.Compact.first_run","text":"Returns: Type Description bool True if its currently the first run of a compact method.","title":"first_run"},{"location":"api/Compact/#treeo.mixins.Compact.get_field","text":"A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: The field must be declared in the class definition. The method can only be called inside a compact context. Parameters: Name Type Description Default field_name str The name of the field to get. required initializer Callable[[], ~A] The function to initialize the field if it does not exist. required Returns: Type Description ~A The field value. Source code in treeo/mixins.py def get_field ( self , field_name : str , initializer : tp . Callable [[], A ], ) -> A : \"\"\" A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: * The field must be declared in the class definition. * The method can only be called inside a `compact` context. Arguments: field_name: The name of the field to get. initializer: The function to initialize the field if it does not exist. Returns: The field value. \"\"\" value : A if field_name not in self . _field_metadata : raise ValueError ( f \"Metadata for field ' { field_name } ' does not exist.\" ) if field_name in vars ( self ): value = getattr ( self , field_name ) else : if tree_m . _COMPACT_CONTEXT . in_compact and not self . first_run : raise RuntimeError ( f \"Trying to initialize field ' { field_name } ' after the first run of `compact`.\" ) value = initializer () setattr ( self , field_name , value ) return value","title":"get_field()"},{"location":"api/Conv/","text":"treex.Conv Convolution Module wrapping lax.conv_general_dilated. Conv is implemented as a wrapper over flax.linen.Conv , its constructor arguments accept almost the same arguments including any Flax artifacts such as initializers. Main differences: receives features_in as a first argument since shapes must be statically known. features argument is renamed to features_out . first_run : bool inherited property readonly Returns: Type Description bool True if its currently the first run of a compact method. __class__ inherited __base__ inherited __base__ inherited Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()). __instancecheck__ ( cls , instance ) special Override for isinstance(instance, cls). Source code in treex/nn/conv.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance ) __new__ ( mcls , name , bases , namespace , ** kwargs ) special staticmethod Create and return a new object. See help(type) for accurate signature. Source code in treex/nn/conv.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls __subclasscheck__ ( cls , subclass ) special Override for issubclass(subclass, cls). Source code in treex/nn/conv.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass ) register ( cls , subclass ) Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/conv.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) register ( cls , subclass ) inherited Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/conv.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) register ( cls , subclass ) inherited Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/conv.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) __call__ ( self , x ) special Applies a convolution to the inputs. Parameters: Name Type Description Default x ndarray input data with dimensions (batch, spatial_dims..., features). required Returns: Type Description ndarray The convolved data. Source code in treex/nn/conv.py def __call__ ( self , x : jnp . ndarray ) -> jnp . ndarray : \"\"\"Applies a convolution to the inputs. Arguments: x: input data with dimensions (batch, spatial_dims..., features). Returns: The convolved data. \"\"\" if self . initializing (): variables = self . module . init ({ \"params\" : next_key ()}, x ) # Extract collections params = variables [ \"params\" ] . unfreeze () self . kernel = params [ \"kernel\" ] if self . use_bias : self . bias = params [ \"bias\" ] assert self . kernel is not None params = { \"kernel\" : self . kernel } if self . use_bias : assert self . bias is not None params [ \"bias\" ] = self . bias output = self . module . apply ({ \"params\" : params }, x ) return tp . cast ( jnp . ndarray , output ) __init__ ( self , features_out , kernel_size , * , strides = None , padding = 'SAME' , input_dilation = None , kernel_dilation = None , feature_group_count = 1 , use_bias = True , dtype =< class ' jax . _src . numpy . lax_numpy . float32 '>, precision=None, kernel_init=<function variance_scaling.<locals>.init at 0x7f29cde939d0>, bias_init=<function zeros at 0x7f29d70075e0>) special Parameters: Name Type Description Default features_out int number of convolution filters. required kernel_size Union[int, Iterable[int]] shape of the convolutional kernel. For 1D convolution, the kernel size can be passed as an integer. For all other cases, it must be a sequence of integers. required strides Optional[Iterable[int]] a sequence of n integers, representing the inter-window strides. None padding Union[str, Iterable[Tuple[int, int]]] either the string 'SAME' , the string 'VALID' , or a sequence of n (low, high) integer pairs that give the padding to apply before and after each spatial dimension. 'SAME' input_dilation Optional[Iterable[int]] None , or a sequence of n integers, giving the dilation factor to apply in each spatial dimension of inputs . Convolution with input dilation d is equivalent to transposed convolution with stride d . None kernel_dilation Optional[Iterable[int]] None , or a sequence of n integers, giving the dilation factor to apply in each spatial dimension of the convolution kernel. Convolution with kernel dilation is also known as 'atrous convolution'. None feature_group_count int integer, default 1. If specified divides the input features into groups. 1 use_bias bool whether to add a bias to the output (default: True). True dtype Any the dtype of the computation (default: float32). <class 'jax._src.numpy.lax_numpy.float32'> precision Any numerical precision of the computation see jax.lax.Precision for details. None kernel_init Callable[[Any, Iterable[int], Any], Any] initializer for the convolutional kernel. <function variance_scaling.<locals>.init at 0x7f29cde939d0> bias_init Callable[[Any, Iterable[int], Any], Any] initializer for the bias. <function zeros at 0x7f29d70075e0> Source code in treex/nn/conv.py def __init__ ( self , features_out : int , kernel_size : tp . Union [ int , tp . Iterable [ int ]], * , strides : tp . Optional [ tp . Iterable [ int ]] = None , padding : tp . Union [ str , tp . Iterable [ tp . Tuple [ int , int ]]] = \"SAME\" , input_dilation : tp . Optional [ tp . Iterable [ int ]] = None , kernel_dilation : tp . Optional [ tp . Iterable [ int ]] = None , feature_group_count : int = 1 , use_bias : bool = True , dtype : flax_module . Dtype = jnp . float32 , precision : tp . Any = None , kernel_init : tp . Callable [ [ flax_module . PRNGKey , flax_module . Shape , flax_module . Dtype ], flax_module . Array , ] = flax_module . default_kernel_init , bias_init : tp . Callable [ [ flax_module . PRNGKey , flax_module . Shape , flax_module . Dtype ], flax_module . Array , ] = flax_module . zeros , ): \"\"\" Arguments: features_out: number of convolution filters. kernel_size: shape of the convolutional kernel. For 1D convolution, the kernel size can be passed as an integer. For all other cases, it must be a sequence of integers. strides: a sequence of `n` integers, representing the inter-window strides. padding: either the string `'SAME'`, the string `'VALID'`, or a sequence of `n` `(low, high)` integer pairs that give the padding to apply before and after each spatial dimension. input_dilation: `None`, or a sequence of `n` integers, giving the dilation factor to apply in each spatial dimension of `inputs`. Convolution with input dilation `d` is equivalent to transposed convolution with stride `d`. kernel_dilation: `None`, or a sequence of `n` integers, giving the dilation factor to apply in each spatial dimension of the convolution kernel. Convolution with kernel dilation is also known as 'atrous convolution'. feature_group_count: integer, default 1. If specified divides the input features into groups. use_bias: whether to add a bias to the output (default: True). dtype: the dtype of the computation (default: float32). precision: numerical precision of the computation see `jax.lax.Precision` for details. kernel_init: initializer for the convolutional kernel. bias_init: initializer for the bias. \"\"\" self . features_out = features_out self . kernel_size = kernel_size self . strides = strides self . padding = padding self . input_dilation = input_dilation self . kernel_dilation = kernel_dilation self . feature_group_count = feature_group_count self . use_bias = use_bias self . dtype = dtype self . precision = precision self . kernel_init = kernel_init self . bias_init = bias_init self . kernel = None self . bias = None apply ( self , f , * rest , * , inplace = False ) inherited apply is a wrapper over treeo.apply that passes self as the second argument. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treex/nn/conv.py def apply ( self : A , f : tp . Callable [ ... , None ], * rest : A , inplace : bool = False ) -> A : \"\"\" `apply` is a wrapper over `treeo.apply` that passes `self` as the second argument. Arguments: f: The function to apply. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" return api . apply ( f , self , * rest , inplace = inplace ) batch_stats ( self , * filters ) inherited Returns a copy of the Module with only tx.BatchStat TreeParts, alias for filter(tx.BatchStat) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/conv.py def batch_stats ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.BatchStat TreeParts, alias for `filter(tx.BatchStat)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . BatchStat , * filters ) check_metadata_updates ( self ) inherited Checks for new fields, if found, adds them to the metadata. Source code in treex/nn/conv.py def check_metadata_updates ( self ): \"\"\" Checks for new fields, if found, adds them to the metadata. \"\"\" with _CONTEXT . update ( flatten_mode = FlattenMode . all_fields ): jax . tree_flatten ( self ) copy ( self ) inherited copy is a wrapper over treeo.copy that passes self as the first argument. Source code in treex/nn/conv.py def copy ( self : A ) -> A : \"\"\" `copy` is a wrapper over `treeo.copy` that passes `self` as the first argument. \"\"\" return tree_m . copy ( self ) eval ( self , inplace = False ) inherited Creates a new module with the training mode set to False, equivalent to calling train(False) . Returns: Type Description ~T The new module with the training mode set to False. Source code in treex/nn/conv.py def eval ( self : T , inplace : bool = False ) -> T : \"\"\" Creates a new module with the training mode set to False, equivalent to calling `train(False)`. Returns: The new module with the training mode set to False. \"\"\" return self . train ( False , inplace = inplace ) filter ( self , * filters , * , inplace = False , flatten_mode = None ) inherited filter is a wrapper over treeo.filter that passes self as the first argument. Parameters: Name Type Description Default *filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treex/nn/conv.py def filter ( self : A , * filters : api . Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ) -> A : \"\"\" `filter` is a wrapper over `treeo.filter` that passes `self` as the first argument. Arguments: *filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" return api . filter ( self , * filters , inplace = inplace , flatten_mode = flatten_mode ) freeze ( self , mode = True , inplace = False ) inherited Creates a new module with the same structure, but with Module.frozen set to the given value. Parameters: Name Type Description Default mode bool The new frozen mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module in with the frozen mode is set to the given value, if inplace is True then self is returned. Source code in treex/nn/conv.py def freeze ( self : T , mode : bool = True , inplace : bool = False ) -> T : \"\"\" Creates a new module with the same structure, but with `Module.frozen` set to the given value. Arguments: mode: The new `frozen` mode. inplace: Whether to update the module inplace. Returns: The new module in with the `frozen` mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_frozen ( tree ): if isinstance ( tree , Treex ) and hasattr ( tree , \"_frozen\" ): tree . _frozen = mode return to . apply ( set_frozen , self , inplace = inplace ) get_field ( self , field_name , initializer ) inherited A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: The field must be declared in the class definition. The method can only be called inside a compact context. Parameters: Name Type Description Default field_name str The name of the field to get. required initializer Callable[[], ~A] The function to initialize the field if it does not exist. required Returns: Type Description ~A The field value. Source code in treex/nn/conv.py def get_field ( self , field_name : str , initializer : tp . Callable [[], A ], ) -> A : \"\"\" A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: * The field must be declared in the class definition. * The method can only be called inside a `compact` context. Arguments: field_name: The name of the field to get. initializer: The function to initialize the field if it does not exist. Returns: The field value. \"\"\" value : A if field_name not in self . _field_metadata : raise ValueError ( f \"Metadata for field ' { field_name } ' does not exist.\" ) if field_name in vars ( self ): value = getattr ( self , field_name ) else : if tree_m . _COMPACT_CONTEXT . in_compact and not self . first_run : raise RuntimeError ( f \"Trying to initialize field ' { field_name } ' after the first run of `compact`.\" ) value = initializer () setattr ( self , field_name , value ) return value init ( self , key , inputs =< treeo . types . Missing object at 0x7f29ce5c9220 > , call_method = '__call__' , * , inplace = False , _set_initialize = True ) inherited Method version of tx.init , it applies self as first argument. init creates a new module with the same structure, but with its fields initialized given a seed key . The following procedure is used: The input key is split and iteratively updated before passing a derived value to any process that requires initialization. Initializer s are called and applied to the module first. Module.rng_init methods are called last. Parameters: Name Type Description Default key Union[int, jax._src.numpy.lax_numpy.ndarray] The seed to use for initialization. required Returns: Type Description ~M The new module with the fields initialized. Source code in treex/nn/conv.py def init ( self : M , key : tp . Union [ int , jnp . ndarray ], inputs : types . InputLike = to . MISSING , call_method : str = \"__call__\" , * , inplace : bool = False , _set_initialize : bool = True , ) -> M : \"\"\" Method version of `tx.init`, it applies `self` as first argument. `init` creates a new module with the same structure, but with its fields initialized given a seed `key`. The following procedure is used: 1. The input `key` is split and iteratively updated before passing a derived value to any process that requires initialization. 2. `Initializer`s are called and applied to the module first. 3. `Module.rng_init` methods are called last. Arguments: key: The seed to use for initialization. Returns: The new module with the fields initialized. \"\"\" module = self . copy () if not inplace else self key = utils . Key ( key ) with _INIT_CONTEXT . update ( key = key , initializing = True ): module : M = module . map ( lambda initializer : ( initializer ( next_key ()) if isinstance ( initializer , types . Initializer ) else initializer ), is_leaf = lambda x : isinstance ( x , types . Initializer ), inplace = True , ) def call_rng_init ( module : Module ): if isinstance ( module , Module ) and not module . _initialized : module . rng_init () module = to . apply ( call_rng_init , module , inplace = True ) if inputs is not to . MISSING : inputs = types . Inputs . from_value ( inputs ) method = getattr ( module , call_method ) method ( * inputs . args , ** inputs . kwargs ) if _set_initialize : def set_initialized ( module : Module ): if isinstance ( module , Module ) and not module . _initialized : module . _initialized = True module = to . apply ( set_initialized , module , inplace = True ) return module logs ( self , * filters ) inherited Returns a copy of the Module with only tx.Log TreeParts, alias for filter(tx.Log) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/conv.py def logs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Log TreeParts, alias for `filter(tx.Log)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . Log , * filters ) loss_logs ( self , * filters ) inherited Returns a copy of the Module with only tx.Loss TreeParts, alias for filter(tx.Loss) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/conv.py def loss_logs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Loss TreeParts, alias for `filter(tx.Loss)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . LossLog , * filters ) map ( self , f , * filters , * , inplace = False , flatten_mode = None , is_leaf = None ) inherited map is a wrapper over treeo.map that passes self as the second argument. Parameters: Name Type Description Default f Callable The function to apply to the leaves. required *filters Filter The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treex/nn/conv.py def map ( self : A , f : tp . Callable , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , is_leaf : tp . Callable [[ tp . Any ], bool ] = None , ) -> A : \"\"\" `map` is a wrapper over `treeo.map` that passes `self` as the second argument. Arguments: f: The function to apply to the leaves. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" return api . map ( f , self , * filters , inplace = inplace , flatten_mode = flatten_mode , is_leaf = is_leaf , ) merge ( self , other , * rest , * , inplace = False , flatten_mode = None , ignore_static = False ) inherited merge is a wrapper over treeo.merge that passes self as the first argument. Parameters: Name Type Description Default other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the merged values. If inplace is True , obj is returned. Source code in treex/nn/conv.py def merge ( self : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" `merge` is a wrapper over `treeo.merge` that passes `self` as the first argument. Arguments: other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the merged values. If `inplace` is `True`, `obj` is returned. \"\"\" return api . merge ( self , other , * rest , inplace = inplace , flatten_mode = flatten_mode , ignore_static = ignore_static , ) metric_logs ( self , * filters ) inherited Returns a copy of the Module with only tx.Metric TreeParts, alias for filter(tx.Metric) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/conv.py def metric_logs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Metric TreeParts, alias for `filter(tx.Metric)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . MetricLog , * filters ) model_states ( self , * filters ) inherited Returns a copy of the Module with only tx.ModelState TreeParts, alias for filter(tx.ModelState) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/conv.py def model_states ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.ModelState TreeParts, alias for `filter(tx.ModelState)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . ModelState , * filters ) parameters ( self , * filters ) inherited Returns a copy of the Module with only tx.Parameter TreeParts, alias for filter(tx.Parameter) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/conv.py def parameters ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Parameter TreeParts, alias for `filter(tx.Parameter)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . Parameter , * filters ) rngs ( self , * filters ) inherited Returns a copy of the Module with only tx.Rng TreeParts, alias for filter(tx.Rng) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/conv.py def rngs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Rng TreeParts, alias for `filter(tx.Rng)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . Rng , * filters ) states ( self , * filters ) inherited Returns a copy of the Module with only tx.State TreeParts, alias for filter(tx.State) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/conv.py def states ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.State TreeParts, alias for `filter(tx.State)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . State , * filters ) tabulate ( self , inputs =< treeo . types . Missing object at 0x7f29ce5c9220 > , depth =- 1 , signature = False , param_types = True ) inherited Returns a tabular representation of the module. Parameters: Name Type Description Default depth int The maximum depth of the representation in terms of nested Modules, -1 means no limit. -1 signature bool Whether to show the signature of the Module. False param_types bool Whether to show the types of the parameters. True Returns: Type Description str A string containing the tabular representation. Source code in treex/nn/conv.py def tabulate ( self , inputs : tp . Union [ types . InputLike , to . Missing ] = to . MISSING , depth : int = - 1 , signature : bool = False , param_types : bool = True , ) -> str : \"\"\" Returns a tabular representation of the module. Arguments: depth: The maximum depth of the representation in terms of nested Modules, -1 means no limit. signature: Whether to show the signature of the Module. param_types: Whether to show the types of the parameters. Returns: A string containing the tabular representation. \"\"\" self = to . copy ( self ) if inputs is not to . MISSING : inputs = types . Inputs . from_value ( inputs ) if not isinstance ( self , tp . Callable ): raise TypeError ( \"`inputs` can only be specified if the module is a callable.\" ) with contexts . _Context ( call_info = {}): # call using self to preserve references def eval_call ( args , kwargs ): assert isinstance ( self , tp . Callable ) return self ( * args , ** kwargs ) jax . eval_shape ( eval_call , inputs . args , inputs . kwargs , ) call_info = contexts . _CONTEXT . call_info else : call_info = None with to . add_field_info (): flat : tp . List [ to . FieldInfo ] flat , _ = jax . tree_flatten ( self ) tree_part_types : tp . Tuple [ tp . Type [ types . TreePart ], ... ] = tuple ( { field_info . kind for field_info in flat if utils . _generic_issubclass ( field_info . kind , types . TreePart ) } ) path = () rows = list ( utils . _get_tabulate_rows ( path , self , depth , tree_part_types , signature , param_types ) ) modules = [ row [ 0 ] for row in rows ] rows = [ row [ 1 :] for row in rows ] if call_info is not None : for module , row in zip ( modules , rows ): if module in call_info : inputs , outputs = call_info [ module ] simplified_inputs = ( inputs . args [ 0 ] if len ( inputs . kwargs ) == 0 and len ( inputs . args ) == 1 else inputs . kwargs if len ( inputs . kwargs ) == 0 else inputs . kwargs if len ( inputs . args ) == 0 else ( inputs . args , inputs . kwargs ) ) inputs_repr = utils . _format_param_tree ( simplified_inputs ) outputs_repr = utils . _format_param_tree ( outputs ) else : inputs_repr = \"\" outputs_repr = \"\" row . insert ( 3 , outputs_repr ) row . insert ( 3 , inputs_repr ) n_non_treepart_cols = 2 if call_info is None else 4 rows [ 0 ][ 0 ] = \"*\" rows . append ( [ \"\" ] * n_non_treepart_cols + [ \"Total:\" ] + [ utils . _format_obj_size ( self . filter ( kind ), add_padding = True ) for kind in tree_part_types ] ) utils . _add_padding ( rows ) table = Table ( show_header = True , show_lines = True , show_footer = True , # box=rich.box.HORIZONTALS, ) table . add_column ( \"path\" ) table . add_column ( \"module\" ) table . add_column ( \"params\" ) if call_info is not None : table . add_column ( \"inputs\" ) table . add_column ( \"outputs\" ) for tree_part_type in tree_part_types : type_name = tree_part_type . __name__ if type_name . startswith ( \"_\" ): type_name = type_name [ 1 :] table . add_column ( type_name ) for row in rows [: - 1 ]: table . add_row ( * row ) table . columns [ n_non_treepart_cols ] . footer = Text . from_markup ( rows [ - 1 ][ n_non_treepart_cols ], justify = \"right\" ) for i in range ( len ( tree_part_types )): table . columns [ n_non_treepart_cols + 1 + i ] . footer = rows [ - 1 ][ n_non_treepart_cols + 1 + i ] table . caption_style = \"bold\" table . caption = \" \\n Total Parameters: \" + utils . _format_obj_size ( self , add_padding = False ) return utils . _get_rich_repr ( table ) to_dict ( self , * , private_fields = False , static_fields = True , type_info = False , field_info = False ) inherited to_dict is a wrapper over treeo.to_dict that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True type_info bool If True , type information is included. False field_info bool If True , field information is included. False Returns: Type Description Any A dict representation of the object. Source code in treex/nn/conv.py def to_dict ( self , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : \"\"\" `to_dict` is a wrapper over `treeo.to_dict` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. type_info: If `True`, type information is included. field_info: If `True`, field information is included. Returns: A dict representation of the object. \"\"\" return api . to_dict ( self , private_fields = private_fields , static_fields = static_fields , type_info = type_info , field_info = field_info , ) to_string ( self , * , private_fields = False , static_fields = True , color = False ) inherited to_string is a wrapper over treeo.to_string that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True color bool If True , color is included. False Returns: Type Description str A string representation of the object. Source code in treex/nn/conv.py def to_string ( self : A , * , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" `to_string` is a wrapper over `treeo.to_string` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. color: If `True`, color is included. Returns: A string representation of the object. \"\"\" return api . to_string ( self , private_fields = private_fields , static_fields = static_fields , color = color , ) train ( self , mode = True , inplace = False ) inherited Creates a new module with the same structure, but with Module.training set to the given value. Parameters: Name Type Description Default mode bool The new training mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module in with the training mode is set to the given value, if inplace is True then self is returned. Source code in treex/nn/conv.py def train ( self : T , mode : bool = True , inplace : bool = False ) -> T : \"\"\" Creates a new module with the same structure, but with `Module.training` set to the given value. Arguments: mode: The new training mode. inplace: Whether to update the module inplace. Returns: The new module in with the training mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_training ( tree ): if isinstance ( tree , Treex ) and hasattr ( tree , \"_training\" ): tree . _training = mode return to . apply ( set_training , self , inplace = inplace ) unfreeze ( self , inplace = False ) inherited Creates a new module with .frozen set to False, equivalent to calling freeze(False) . Parameters: Name Type Description Default inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module with .frozen set to False, if inplace is True then self is returned. Source code in treex/nn/conv.py def unfreeze ( self : T , inplace : bool = False ) -> T : \"\"\" Creates a new module with `.frozen` set to False, equivalent to calling `freeze(False)`. Arguments: inplace: Whether to update the module inplace. Returns: The new module with `.frozen` set to False, if `inplace` is `True` then `self` is returned. \"\"\" return self . freeze ( False , inplace = inplace )","title":"Conv"},{"location":"api/Conv/#treexconv","text":"Convolution Module wrapping lax.conv_general_dilated. Conv is implemented as a wrapper over flax.linen.Conv , its constructor arguments accept almost the same arguments including any Flax artifacts such as initializers. Main differences: receives features_in as a first argument since shapes must be statically known. features argument is renamed to features_out .","title":"treex.Conv"},{"location":"api/Conv/#treex.nn.conv.Conv.first_run","text":"Returns: Type Description bool True if its currently the first run of a compact method.","title":"first_run"},{"location":"api/Conv/#treex.nn.conv.Conv.__class__","text":"","title":"__class__"},{"location":"api/Conv/#treex.nn.conv.Conv.__class__.__base__","text":"","title":"__base__"},{"location":"api/Conv/#treex.nn.conv.Conv.__class__.__base__.__base__","text":"Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()).","title":"__base__"},{"location":"api/Conv/#treex.nn.conv.Conv.__class__.__base__.__base__.__instancecheck__","text":"Override for isinstance(instance, cls). Source code in treex/nn/conv.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance )","title":"__instancecheck__()"},{"location":"api/Conv/#treex.nn.conv.Conv.__class__.__base__.__base__.__new__","text":"Create and return a new object. See help(type) for accurate signature. Source code in treex/nn/conv.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls","title":"__new__()"},{"location":"api/Conv/#treex.nn.conv.Conv.__class__.__base__.__base__.__subclasscheck__","text":"Override for issubclass(subclass, cls). Source code in treex/nn/conv.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass )","title":"__subclasscheck__()"},{"location":"api/Conv/#treex.nn.conv.Conv.__class__.__base__.__base__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/conv.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/Conv/#treex.nn.conv.Conv.__class__.__base__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/conv.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/Conv/#treex.nn.conv.Conv.__class__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/conv.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/Conv/#treex.nn.conv.Conv.__call__","text":"Applies a convolution to the inputs. Parameters: Name Type Description Default x ndarray input data with dimensions (batch, spatial_dims..., features). required Returns: Type Description ndarray The convolved data. Source code in treex/nn/conv.py def __call__ ( self , x : jnp . ndarray ) -> jnp . ndarray : \"\"\"Applies a convolution to the inputs. Arguments: x: input data with dimensions (batch, spatial_dims..., features). Returns: The convolved data. \"\"\" if self . initializing (): variables = self . module . init ({ \"params\" : next_key ()}, x ) # Extract collections params = variables [ \"params\" ] . unfreeze () self . kernel = params [ \"kernel\" ] if self . use_bias : self . bias = params [ \"bias\" ] assert self . kernel is not None params = { \"kernel\" : self . kernel } if self . use_bias : assert self . bias is not None params [ \"bias\" ] = self . bias output = self . module . apply ({ \"params\" : params }, x ) return tp . cast ( jnp . ndarray , output )","title":"__call__()"},{"location":"api/Conv/#treex.nn.conv.Conv.__init__","text":"Parameters: Name Type Description Default features_out int number of convolution filters. required kernel_size Union[int, Iterable[int]] shape of the convolutional kernel. For 1D convolution, the kernel size can be passed as an integer. For all other cases, it must be a sequence of integers. required strides Optional[Iterable[int]] a sequence of n integers, representing the inter-window strides. None padding Union[str, Iterable[Tuple[int, int]]] either the string 'SAME' , the string 'VALID' , or a sequence of n (low, high) integer pairs that give the padding to apply before and after each spatial dimension. 'SAME' input_dilation Optional[Iterable[int]] None , or a sequence of n integers, giving the dilation factor to apply in each spatial dimension of inputs . Convolution with input dilation d is equivalent to transposed convolution with stride d . None kernel_dilation Optional[Iterable[int]] None , or a sequence of n integers, giving the dilation factor to apply in each spatial dimension of the convolution kernel. Convolution with kernel dilation is also known as 'atrous convolution'. None feature_group_count int integer, default 1. If specified divides the input features into groups. 1 use_bias bool whether to add a bias to the output (default: True). True dtype Any the dtype of the computation (default: float32). <class 'jax._src.numpy.lax_numpy.float32'> precision Any numerical precision of the computation see jax.lax.Precision for details. None kernel_init Callable[[Any, Iterable[int], Any], Any] initializer for the convolutional kernel. <function variance_scaling.<locals>.init at 0x7f29cde939d0> bias_init Callable[[Any, Iterable[int], Any], Any] initializer for the bias. <function zeros at 0x7f29d70075e0> Source code in treex/nn/conv.py def __init__ ( self , features_out : int , kernel_size : tp . Union [ int , tp . Iterable [ int ]], * , strides : tp . Optional [ tp . Iterable [ int ]] = None , padding : tp . Union [ str , tp . Iterable [ tp . Tuple [ int , int ]]] = \"SAME\" , input_dilation : tp . Optional [ tp . Iterable [ int ]] = None , kernel_dilation : tp . Optional [ tp . Iterable [ int ]] = None , feature_group_count : int = 1 , use_bias : bool = True , dtype : flax_module . Dtype = jnp . float32 , precision : tp . Any = None , kernel_init : tp . Callable [ [ flax_module . PRNGKey , flax_module . Shape , flax_module . Dtype ], flax_module . Array , ] = flax_module . default_kernel_init , bias_init : tp . Callable [ [ flax_module . PRNGKey , flax_module . Shape , flax_module . Dtype ], flax_module . Array , ] = flax_module . zeros , ): \"\"\" Arguments: features_out: number of convolution filters. kernel_size: shape of the convolutional kernel. For 1D convolution, the kernel size can be passed as an integer. For all other cases, it must be a sequence of integers. strides: a sequence of `n` integers, representing the inter-window strides. padding: either the string `'SAME'`, the string `'VALID'`, or a sequence of `n` `(low, high)` integer pairs that give the padding to apply before and after each spatial dimension. input_dilation: `None`, or a sequence of `n` integers, giving the dilation factor to apply in each spatial dimension of `inputs`. Convolution with input dilation `d` is equivalent to transposed convolution with stride `d`. kernel_dilation: `None`, or a sequence of `n` integers, giving the dilation factor to apply in each spatial dimension of the convolution kernel. Convolution with kernel dilation is also known as 'atrous convolution'. feature_group_count: integer, default 1. If specified divides the input features into groups. use_bias: whether to add a bias to the output (default: True). dtype: the dtype of the computation (default: float32). precision: numerical precision of the computation see `jax.lax.Precision` for details. kernel_init: initializer for the convolutional kernel. bias_init: initializer for the bias. \"\"\" self . features_out = features_out self . kernel_size = kernel_size self . strides = strides self . padding = padding self . input_dilation = input_dilation self . kernel_dilation = kernel_dilation self . feature_group_count = feature_group_count self . use_bias = use_bias self . dtype = dtype self . precision = precision self . kernel_init = kernel_init self . bias_init = bias_init self . kernel = None self . bias = None","title":"__init__()"},{"location":"api/Conv/#treex.nn.conv.Conv.apply","text":"apply is a wrapper over treeo.apply that passes self as the second argument. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treex/nn/conv.py def apply ( self : A , f : tp . Callable [ ... , None ], * rest : A , inplace : bool = False ) -> A : \"\"\" `apply` is a wrapper over `treeo.apply` that passes `self` as the second argument. Arguments: f: The function to apply. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" return api . apply ( f , self , * rest , inplace = inplace )","title":"apply()"},{"location":"api/Conv/#treex.nn.conv.Conv.batch_stats","text":"Returns a copy of the Module with only tx.BatchStat TreeParts, alias for filter(tx.BatchStat) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/conv.py def batch_stats ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.BatchStat TreeParts, alias for `filter(tx.BatchStat)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . BatchStat , * filters )","title":"batch_stats()"},{"location":"api/Conv/#treex.nn.conv.Conv.check_metadata_updates","text":"Checks for new fields, if found, adds them to the metadata. Source code in treex/nn/conv.py def check_metadata_updates ( self ): \"\"\" Checks for new fields, if found, adds them to the metadata. \"\"\" with _CONTEXT . update ( flatten_mode = FlattenMode . all_fields ): jax . tree_flatten ( self )","title":"check_metadata_updates()"},{"location":"api/Conv/#treex.nn.conv.Conv.copy","text":"copy is a wrapper over treeo.copy that passes self as the first argument. Source code in treex/nn/conv.py def copy ( self : A ) -> A : \"\"\" `copy` is a wrapper over `treeo.copy` that passes `self` as the first argument. \"\"\" return tree_m . copy ( self )","title":"copy()"},{"location":"api/Conv/#treex.nn.conv.Conv.eval","text":"Creates a new module with the training mode set to False, equivalent to calling train(False) . Returns: Type Description ~T The new module with the training mode set to False. Source code in treex/nn/conv.py def eval ( self : T , inplace : bool = False ) -> T : \"\"\" Creates a new module with the training mode set to False, equivalent to calling `train(False)`. Returns: The new module with the training mode set to False. \"\"\" return self . train ( False , inplace = inplace )","title":"eval()"},{"location":"api/Conv/#treex.nn.conv.Conv.filter","text":"filter is a wrapper over treeo.filter that passes self as the first argument. Parameters: Name Type Description Default *filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treex/nn/conv.py def filter ( self : A , * filters : api . Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ) -> A : \"\"\" `filter` is a wrapper over `treeo.filter` that passes `self` as the first argument. Arguments: *filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" return api . filter ( self , * filters , inplace = inplace , flatten_mode = flatten_mode )","title":"filter()"},{"location":"api/Conv/#treex.nn.conv.Conv.freeze","text":"Creates a new module with the same structure, but with Module.frozen set to the given value. Parameters: Name Type Description Default mode bool The new frozen mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module in with the frozen mode is set to the given value, if inplace is True then self is returned. Source code in treex/nn/conv.py def freeze ( self : T , mode : bool = True , inplace : bool = False ) -> T : \"\"\" Creates a new module with the same structure, but with `Module.frozen` set to the given value. Arguments: mode: The new `frozen` mode. inplace: Whether to update the module inplace. Returns: The new module in with the `frozen` mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_frozen ( tree ): if isinstance ( tree , Treex ) and hasattr ( tree , \"_frozen\" ): tree . _frozen = mode return to . apply ( set_frozen , self , inplace = inplace )","title":"freeze()"},{"location":"api/Conv/#treex.nn.conv.Conv.get_field","text":"A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: The field must be declared in the class definition. The method can only be called inside a compact context. Parameters: Name Type Description Default field_name str The name of the field to get. required initializer Callable[[], ~A] The function to initialize the field if it does not exist. required Returns: Type Description ~A The field value. Source code in treex/nn/conv.py def get_field ( self , field_name : str , initializer : tp . Callable [[], A ], ) -> A : \"\"\" A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: * The field must be declared in the class definition. * The method can only be called inside a `compact` context. Arguments: field_name: The name of the field to get. initializer: The function to initialize the field if it does not exist. Returns: The field value. \"\"\" value : A if field_name not in self . _field_metadata : raise ValueError ( f \"Metadata for field ' { field_name } ' does not exist.\" ) if field_name in vars ( self ): value = getattr ( self , field_name ) else : if tree_m . _COMPACT_CONTEXT . in_compact and not self . first_run : raise RuntimeError ( f \"Trying to initialize field ' { field_name } ' after the first run of `compact`.\" ) value = initializer () setattr ( self , field_name , value ) return value","title":"get_field()"},{"location":"api/Conv/#treex.nn.conv.Conv.init","text":"Method version of tx.init , it applies self as first argument. init creates a new module with the same structure, but with its fields initialized given a seed key . The following procedure is used: The input key is split and iteratively updated before passing a derived value to any process that requires initialization. Initializer s are called and applied to the module first. Module.rng_init methods are called last. Parameters: Name Type Description Default key Union[int, jax._src.numpy.lax_numpy.ndarray] The seed to use for initialization. required Returns: Type Description ~M The new module with the fields initialized. Source code in treex/nn/conv.py def init ( self : M , key : tp . Union [ int , jnp . ndarray ], inputs : types . InputLike = to . MISSING , call_method : str = \"__call__\" , * , inplace : bool = False , _set_initialize : bool = True , ) -> M : \"\"\" Method version of `tx.init`, it applies `self` as first argument. `init` creates a new module with the same structure, but with its fields initialized given a seed `key`. The following procedure is used: 1. The input `key` is split and iteratively updated before passing a derived value to any process that requires initialization. 2. `Initializer`s are called and applied to the module first. 3. `Module.rng_init` methods are called last. Arguments: key: The seed to use for initialization. Returns: The new module with the fields initialized. \"\"\" module = self . copy () if not inplace else self key = utils . Key ( key ) with _INIT_CONTEXT . update ( key = key , initializing = True ): module : M = module . map ( lambda initializer : ( initializer ( next_key ()) if isinstance ( initializer , types . Initializer ) else initializer ), is_leaf = lambda x : isinstance ( x , types . Initializer ), inplace = True , ) def call_rng_init ( module : Module ): if isinstance ( module , Module ) and not module . _initialized : module . rng_init () module = to . apply ( call_rng_init , module , inplace = True ) if inputs is not to . MISSING : inputs = types . Inputs . from_value ( inputs ) method = getattr ( module , call_method ) method ( * inputs . args , ** inputs . kwargs ) if _set_initialize : def set_initialized ( module : Module ): if isinstance ( module , Module ) and not module . _initialized : module . _initialized = True module = to . apply ( set_initialized , module , inplace = True ) return module","title":"init()"},{"location":"api/Conv/#treex.nn.conv.Conv.logs","text":"Returns a copy of the Module with only tx.Log TreeParts, alias for filter(tx.Log) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/conv.py def logs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Log TreeParts, alias for `filter(tx.Log)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . Log , * filters )","title":"logs()"},{"location":"api/Conv/#treex.nn.conv.Conv.loss_logs","text":"Returns a copy of the Module with only tx.Loss TreeParts, alias for filter(tx.Loss) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/conv.py def loss_logs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Loss TreeParts, alias for `filter(tx.Loss)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . LossLog , * filters )","title":"loss_logs()"},{"location":"api/Conv/#treex.nn.conv.Conv.map","text":"map is a wrapper over treeo.map that passes self as the second argument. Parameters: Name Type Description Default f Callable The function to apply to the leaves. required *filters Filter The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treex/nn/conv.py def map ( self : A , f : tp . Callable , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , is_leaf : tp . Callable [[ tp . Any ], bool ] = None , ) -> A : \"\"\" `map` is a wrapper over `treeo.map` that passes `self` as the second argument. Arguments: f: The function to apply to the leaves. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" return api . map ( f , self , * filters , inplace = inplace , flatten_mode = flatten_mode , is_leaf = is_leaf , )","title":"map()"},{"location":"api/Conv/#treex.nn.conv.Conv.merge","text":"merge is a wrapper over treeo.merge that passes self as the first argument. Parameters: Name Type Description Default other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the merged values. If inplace is True , obj is returned. Source code in treex/nn/conv.py def merge ( self : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" `merge` is a wrapper over `treeo.merge` that passes `self` as the first argument. Arguments: other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the merged values. If `inplace` is `True`, `obj` is returned. \"\"\" return api . merge ( self , other , * rest , inplace = inplace , flatten_mode = flatten_mode , ignore_static = ignore_static , )","title":"merge()"},{"location":"api/Conv/#treex.nn.conv.Conv.metric_logs","text":"Returns a copy of the Module with only tx.Metric TreeParts, alias for filter(tx.Metric) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/conv.py def metric_logs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Metric TreeParts, alias for `filter(tx.Metric)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . MetricLog , * filters )","title":"metric_logs()"},{"location":"api/Conv/#treex.nn.conv.Conv.model_states","text":"Returns a copy of the Module with only tx.ModelState TreeParts, alias for filter(tx.ModelState) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/conv.py def model_states ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.ModelState TreeParts, alias for `filter(tx.ModelState)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . ModelState , * filters )","title":"model_states()"},{"location":"api/Conv/#treex.nn.conv.Conv.parameters","text":"Returns a copy of the Module with only tx.Parameter TreeParts, alias for filter(tx.Parameter) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/conv.py def parameters ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Parameter TreeParts, alias for `filter(tx.Parameter)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . Parameter , * filters )","title":"parameters()"},{"location":"api/Conv/#treex.nn.conv.Conv.rngs","text":"Returns a copy of the Module with only tx.Rng TreeParts, alias for filter(tx.Rng) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/conv.py def rngs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Rng TreeParts, alias for `filter(tx.Rng)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . Rng , * filters )","title":"rngs()"},{"location":"api/Conv/#treex.nn.conv.Conv.states","text":"Returns a copy of the Module with only tx.State TreeParts, alias for filter(tx.State) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/conv.py def states ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.State TreeParts, alias for `filter(tx.State)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . State , * filters )","title":"states()"},{"location":"api/Conv/#treex.nn.conv.Conv.tabulate","text":"Returns a tabular representation of the module. Parameters: Name Type Description Default depth int The maximum depth of the representation in terms of nested Modules, -1 means no limit. -1 signature bool Whether to show the signature of the Module. False param_types bool Whether to show the types of the parameters. True Returns: Type Description str A string containing the tabular representation. Source code in treex/nn/conv.py def tabulate ( self , inputs : tp . Union [ types . InputLike , to . Missing ] = to . MISSING , depth : int = - 1 , signature : bool = False , param_types : bool = True , ) -> str : \"\"\" Returns a tabular representation of the module. Arguments: depth: The maximum depth of the representation in terms of nested Modules, -1 means no limit. signature: Whether to show the signature of the Module. param_types: Whether to show the types of the parameters. Returns: A string containing the tabular representation. \"\"\" self = to . copy ( self ) if inputs is not to . MISSING : inputs = types . Inputs . from_value ( inputs ) if not isinstance ( self , tp . Callable ): raise TypeError ( \"`inputs` can only be specified if the module is a callable.\" ) with contexts . _Context ( call_info = {}): # call using self to preserve references def eval_call ( args , kwargs ): assert isinstance ( self , tp . Callable ) return self ( * args , ** kwargs ) jax . eval_shape ( eval_call , inputs . args , inputs . kwargs , ) call_info = contexts . _CONTEXT . call_info else : call_info = None with to . add_field_info (): flat : tp . List [ to . FieldInfo ] flat , _ = jax . tree_flatten ( self ) tree_part_types : tp . Tuple [ tp . Type [ types . TreePart ], ... ] = tuple ( { field_info . kind for field_info in flat if utils . _generic_issubclass ( field_info . kind , types . TreePart ) } ) path = () rows = list ( utils . _get_tabulate_rows ( path , self , depth , tree_part_types , signature , param_types ) ) modules = [ row [ 0 ] for row in rows ] rows = [ row [ 1 :] for row in rows ] if call_info is not None : for module , row in zip ( modules , rows ): if module in call_info : inputs , outputs = call_info [ module ] simplified_inputs = ( inputs . args [ 0 ] if len ( inputs . kwargs ) == 0 and len ( inputs . args ) == 1 else inputs . kwargs if len ( inputs . kwargs ) == 0 else inputs . kwargs if len ( inputs . args ) == 0 else ( inputs . args , inputs . kwargs ) ) inputs_repr = utils . _format_param_tree ( simplified_inputs ) outputs_repr = utils . _format_param_tree ( outputs ) else : inputs_repr = \"\" outputs_repr = \"\" row . insert ( 3 , outputs_repr ) row . insert ( 3 , inputs_repr ) n_non_treepart_cols = 2 if call_info is None else 4 rows [ 0 ][ 0 ] = \"*\" rows . append ( [ \"\" ] * n_non_treepart_cols + [ \"Total:\" ] + [ utils . _format_obj_size ( self . filter ( kind ), add_padding = True ) for kind in tree_part_types ] ) utils . _add_padding ( rows ) table = Table ( show_header = True , show_lines = True , show_footer = True , # box=rich.box.HORIZONTALS, ) table . add_column ( \"path\" ) table . add_column ( \"module\" ) table . add_column ( \"params\" ) if call_info is not None : table . add_column ( \"inputs\" ) table . add_column ( \"outputs\" ) for tree_part_type in tree_part_types : type_name = tree_part_type . __name__ if type_name . startswith ( \"_\" ): type_name = type_name [ 1 :] table . add_column ( type_name ) for row in rows [: - 1 ]: table . add_row ( * row ) table . columns [ n_non_treepart_cols ] . footer = Text . from_markup ( rows [ - 1 ][ n_non_treepart_cols ], justify = \"right\" ) for i in range ( len ( tree_part_types )): table . columns [ n_non_treepart_cols + 1 + i ] . footer = rows [ - 1 ][ n_non_treepart_cols + 1 + i ] table . caption_style = \"bold\" table . caption = \" \\n Total Parameters: \" + utils . _format_obj_size ( self , add_padding = False ) return utils . _get_rich_repr ( table )","title":"tabulate()"},{"location":"api/Conv/#treex.nn.conv.Conv.to_dict","text":"to_dict is a wrapper over treeo.to_dict that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True type_info bool If True , type information is included. False field_info bool If True , field information is included. False Returns: Type Description Any A dict representation of the object. Source code in treex/nn/conv.py def to_dict ( self , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : \"\"\" `to_dict` is a wrapper over `treeo.to_dict` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. type_info: If `True`, type information is included. field_info: If `True`, field information is included. Returns: A dict representation of the object. \"\"\" return api . to_dict ( self , private_fields = private_fields , static_fields = static_fields , type_info = type_info , field_info = field_info , )","title":"to_dict()"},{"location":"api/Conv/#treex.nn.conv.Conv.to_string","text":"to_string is a wrapper over treeo.to_string that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True color bool If True , color is included. False Returns: Type Description str A string representation of the object. Source code in treex/nn/conv.py def to_string ( self : A , * , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" `to_string` is a wrapper over `treeo.to_string` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. color: If `True`, color is included. Returns: A string representation of the object. \"\"\" return api . to_string ( self , private_fields = private_fields , static_fields = static_fields , color = color , )","title":"to_string()"},{"location":"api/Conv/#treex.nn.conv.Conv.train","text":"Creates a new module with the same structure, but with Module.training set to the given value. Parameters: Name Type Description Default mode bool The new training mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module in with the training mode is set to the given value, if inplace is True then self is returned. Source code in treex/nn/conv.py def train ( self : T , mode : bool = True , inplace : bool = False ) -> T : \"\"\" Creates a new module with the same structure, but with `Module.training` set to the given value. Arguments: mode: The new training mode. inplace: Whether to update the module inplace. Returns: The new module in with the training mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_training ( tree ): if isinstance ( tree , Treex ) and hasattr ( tree , \"_training\" ): tree . _training = mode return to . apply ( set_training , self , inplace = inplace )","title":"train()"},{"location":"api/Conv/#treex.nn.conv.Conv.unfreeze","text":"Creates a new module with .frozen set to False, equivalent to calling freeze(False) . Parameters: Name Type Description Default inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module with .frozen set to False, if inplace is True then self is returned. Source code in treex/nn/conv.py def unfreeze ( self : T , inplace : bool = False ) -> T : \"\"\" Creates a new module with `.frozen` set to False, equivalent to calling `freeze(False)`. Arguments: inplace: Whether to update the module inplace. Returns: The new module with `.frozen` set to False, if `inplace` is `True` then `self` is returned. \"\"\" return self . freeze ( False , inplace = inplace )","title":"unfreeze()"},{"location":"api/Copy/","text":"treex.Copy Mixin that adds a .copy() method to the class. copy ( self ) copy is a wrapper over treeo.copy that passes self as the first argument. Source code in treeo/mixins.py def copy ( self : A ) -> A : \"\"\" `copy` is a wrapper over `treeo.copy` that passes `self` as the first argument. \"\"\" return tree_m . copy ( self )","title":"Copy"},{"location":"api/Copy/#treexcopy","text":"Mixin that adds a .copy() method to the class.","title":"treex.Copy"},{"location":"api/Copy/#treeo.mixins.Copy.copy","text":"copy is a wrapper over treeo.copy that passes self as the first argument. Source code in treeo/mixins.py def copy ( self : A ) -> A : \"\"\" `copy` is a wrapper over `treeo.copy` that passes `self` as the first argument. \"\"\" return tree_m . copy ( self )","title":"copy()"},{"location":"api/Dropout/","text":"treex.Dropout Create a dropout layer. Dropout is implemented as a wrapper over flax.linen.Dropout , its constructor arguments accept almost the same arguments including any Flax artifacts such as initializers. Main differences: deterministic is not a constructor argument, but remains a __call__ argument. self.training state is used to indicate how Dropout should behave, interally deterministic = not self.training or self.frozen is used unless deterministic is explicitly passed via __call__ . Dropout maintains an rng: Rng state which is used to generate random masks unless rng is passed via __call__ . first_run : bool inherited property readonly Returns: Type Description bool True if its currently the first run of a compact method. __class__ inherited __base__ inherited __base__ inherited Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()). __instancecheck__ ( cls , instance ) special Override for isinstance(instance, cls). Source code in treex/nn/dropout.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance ) __new__ ( mcls , name , bases , namespace , ** kwargs ) special staticmethod Create and return a new object. See help(type) for accurate signature. Source code in treex/nn/dropout.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls __subclasscheck__ ( cls , subclass ) special Override for issubclass(subclass, cls). Source code in treex/nn/dropout.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass ) register ( cls , subclass ) Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/dropout.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) register ( cls , subclass ) inherited Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/dropout.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) register ( cls , subclass ) inherited Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/dropout.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) __call__ ( self , x , deterministic = None , rng = None ) special Applies a random dropout mask to the input. Parameters: Name Type Description Default x ndarray the inputs that should be randomly masked. required deterministic Optional[bool] if false the inputs are scaled by 1 / (1 - rate) and masked, whereas if true, no mask is applied and the inputs are returned as is. None rng an optional jax.random.PRNGKey . By default self.rng will be used. None Returns: Type Description ndarray The masked inputs reweighted to preserve mean. Source code in treex/nn/dropout.py def __call__ ( self , x : jnp . ndarray , deterministic : tp . Optional [ bool ] = None , rng = None ) -> jnp . ndarray : \"\"\"Applies a random dropout mask to the input. Arguments: x: the inputs that should be randomly masked. deterministic: if false the inputs are scaled by `1 / (1 - rate)` and masked, whereas if true, no mask is applied and the inputs are returned as is. rng: an optional `jax.random.PRNGKey`. By default `self.rng` will be used. Returns: The masked inputs reweighted to preserve mean. \"\"\" variables = dict () training = ( not deterministic if deterministic is not None else self . training and not self . frozen ) if rng is None : rng = self . next_key () if training else self . next_key . key # call apply output = self . module . apply ( variables , x , deterministic = not training , rng = rng , ) return tp . cast ( jnp . ndarray , output ) __init__ ( self , rate , broadcast_dims = ()) special Create a dropout layer. Parameters: Name Type Description Default rate float the dropout probability. ( not the keep rate!) required broadcast_dims Iterable[int] dimensions that will share the same dropout mask () Source code in treex/nn/dropout.py def __init__ ( self , rate : float , broadcast_dims : tp . Iterable [ int ] = (), ): \"\"\" Create a dropout layer. Arguments: rate: the dropout probability. (_not_ the keep rate!) broadcast_dims: dimensions that will share the same dropout mask \"\"\" self . rate = rate self . broadcast_dims = broadcast_dims self . next_key = KeySeq () apply ( self , f , * rest , * , inplace = False ) inherited apply is a wrapper over treeo.apply that passes self as the second argument. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treex/nn/dropout.py def apply ( self : A , f : tp . Callable [ ... , None ], * rest : A , inplace : bool = False ) -> A : \"\"\" `apply` is a wrapper over `treeo.apply` that passes `self` as the second argument. Arguments: f: The function to apply. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" return api . apply ( f , self , * rest , inplace = inplace ) batch_stats ( self , * filters ) inherited Returns a copy of the Module with only tx.BatchStat TreeParts, alias for filter(tx.BatchStat) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/dropout.py def batch_stats ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.BatchStat TreeParts, alias for `filter(tx.BatchStat)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . BatchStat , * filters ) check_metadata_updates ( self ) inherited Checks for new fields, if found, adds them to the metadata. Source code in treex/nn/dropout.py def check_metadata_updates ( self ): \"\"\" Checks for new fields, if found, adds them to the metadata. \"\"\" with _CONTEXT . update ( flatten_mode = FlattenMode . all_fields ): jax . tree_flatten ( self ) copy ( self ) inherited copy is a wrapper over treeo.copy that passes self as the first argument. Source code in treex/nn/dropout.py def copy ( self : A ) -> A : \"\"\" `copy` is a wrapper over `treeo.copy` that passes `self` as the first argument. \"\"\" return tree_m . copy ( self ) eval ( self , inplace = False ) inherited Creates a new module with the training mode set to False, equivalent to calling train(False) . Returns: Type Description ~T The new module with the training mode set to False. Source code in treex/nn/dropout.py def eval ( self : T , inplace : bool = False ) -> T : \"\"\" Creates a new module with the training mode set to False, equivalent to calling `train(False)`. Returns: The new module with the training mode set to False. \"\"\" return self . train ( False , inplace = inplace ) filter ( self , * filters , * , inplace = False , flatten_mode = None ) inherited filter is a wrapper over treeo.filter that passes self as the first argument. Parameters: Name Type Description Default *filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treex/nn/dropout.py def filter ( self : A , * filters : api . Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ) -> A : \"\"\" `filter` is a wrapper over `treeo.filter` that passes `self` as the first argument. Arguments: *filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" return api . filter ( self , * filters , inplace = inplace , flatten_mode = flatten_mode ) freeze ( self , mode = True , inplace = False ) inherited Creates a new module with the same structure, but with Module.frozen set to the given value. Parameters: Name Type Description Default mode bool The new frozen mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module in with the frozen mode is set to the given value, if inplace is True then self is returned. Source code in treex/nn/dropout.py def freeze ( self : T , mode : bool = True , inplace : bool = False ) -> T : \"\"\" Creates a new module with the same structure, but with `Module.frozen` set to the given value. Arguments: mode: The new `frozen` mode. inplace: Whether to update the module inplace. Returns: The new module in with the `frozen` mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_frozen ( tree ): if isinstance ( tree , Treex ) and hasattr ( tree , \"_frozen\" ): tree . _frozen = mode return to . apply ( set_frozen , self , inplace = inplace ) get_field ( self , field_name , initializer ) inherited A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: The field must be declared in the class definition. The method can only be called inside a compact context. Parameters: Name Type Description Default field_name str The name of the field to get. required initializer Callable[[], ~A] The function to initialize the field if it does not exist. required Returns: Type Description ~A The field value. Source code in treex/nn/dropout.py def get_field ( self , field_name : str , initializer : tp . Callable [[], A ], ) -> A : \"\"\" A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: * The field must be declared in the class definition. * The method can only be called inside a `compact` context. Arguments: field_name: The name of the field to get. initializer: The function to initialize the field if it does not exist. Returns: The field value. \"\"\" value : A if field_name not in self . _field_metadata : raise ValueError ( f \"Metadata for field ' { field_name } ' does not exist.\" ) if field_name in vars ( self ): value = getattr ( self , field_name ) else : if tree_m . _COMPACT_CONTEXT . in_compact and not self . first_run : raise RuntimeError ( f \"Trying to initialize field ' { field_name } ' after the first run of `compact`.\" ) value = initializer () setattr ( self , field_name , value ) return value init ( self , key , inputs =< treeo . types . Missing object at 0x7f29ce5c9220 > , call_method = '__call__' , * , inplace = False , _set_initialize = True ) inherited Method version of tx.init , it applies self as first argument. init creates a new module with the same structure, but with its fields initialized given a seed key . The following procedure is used: The input key is split and iteratively updated before passing a derived value to any process that requires initialization. Initializer s are called and applied to the module first. Module.rng_init methods are called last. Parameters: Name Type Description Default key Union[int, jax._src.numpy.lax_numpy.ndarray] The seed to use for initialization. required Returns: Type Description ~M The new module with the fields initialized. Source code in treex/nn/dropout.py def init ( self : M , key : tp . Union [ int , jnp . ndarray ], inputs : types . InputLike = to . MISSING , call_method : str = \"__call__\" , * , inplace : bool = False , _set_initialize : bool = True , ) -> M : \"\"\" Method version of `tx.init`, it applies `self` as first argument. `init` creates a new module with the same structure, but with its fields initialized given a seed `key`. The following procedure is used: 1. The input `key` is split and iteratively updated before passing a derived value to any process that requires initialization. 2. `Initializer`s are called and applied to the module first. 3. `Module.rng_init` methods are called last. Arguments: key: The seed to use for initialization. Returns: The new module with the fields initialized. \"\"\" module = self . copy () if not inplace else self key = utils . Key ( key ) with _INIT_CONTEXT . update ( key = key , initializing = True ): module : M = module . map ( lambda initializer : ( initializer ( next_key ()) if isinstance ( initializer , types . Initializer ) else initializer ), is_leaf = lambda x : isinstance ( x , types . Initializer ), inplace = True , ) def call_rng_init ( module : Module ): if isinstance ( module , Module ) and not module . _initialized : module . rng_init () module = to . apply ( call_rng_init , module , inplace = True ) if inputs is not to . MISSING : inputs = types . Inputs . from_value ( inputs ) method = getattr ( module , call_method ) method ( * inputs . args , ** inputs . kwargs ) if _set_initialize : def set_initialized ( module : Module ): if isinstance ( module , Module ) and not module . _initialized : module . _initialized = True module = to . apply ( set_initialized , module , inplace = True ) return module logs ( self , * filters ) inherited Returns a copy of the Module with only tx.Log TreeParts, alias for filter(tx.Log) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/dropout.py def logs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Log TreeParts, alias for `filter(tx.Log)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . Log , * filters ) loss_logs ( self , * filters ) inherited Returns a copy of the Module with only tx.Loss TreeParts, alias for filter(tx.Loss) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/dropout.py def loss_logs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Loss TreeParts, alias for `filter(tx.Loss)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . LossLog , * filters ) map ( self , f , * filters , * , inplace = False , flatten_mode = None , is_leaf = None ) inherited map is a wrapper over treeo.map that passes self as the second argument. Parameters: Name Type Description Default f Callable The function to apply to the leaves. required *filters Filter The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treex/nn/dropout.py def map ( self : A , f : tp . Callable , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , is_leaf : tp . Callable [[ tp . Any ], bool ] = None , ) -> A : \"\"\" `map` is a wrapper over `treeo.map` that passes `self` as the second argument. Arguments: f: The function to apply to the leaves. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" return api . map ( f , self , * filters , inplace = inplace , flatten_mode = flatten_mode , is_leaf = is_leaf , ) merge ( self , other , * rest , * , inplace = False , flatten_mode = None , ignore_static = False ) inherited merge is a wrapper over treeo.merge that passes self as the first argument. Parameters: Name Type Description Default other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the merged values. If inplace is True , obj is returned. Source code in treex/nn/dropout.py def merge ( self : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" `merge` is a wrapper over `treeo.merge` that passes `self` as the first argument. Arguments: other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the merged values. If `inplace` is `True`, `obj` is returned. \"\"\" return api . merge ( self , other , * rest , inplace = inplace , flatten_mode = flatten_mode , ignore_static = ignore_static , ) metric_logs ( self , * filters ) inherited Returns a copy of the Module with only tx.Metric TreeParts, alias for filter(tx.Metric) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/dropout.py def metric_logs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Metric TreeParts, alias for `filter(tx.Metric)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . MetricLog , * filters ) model_states ( self , * filters ) inherited Returns a copy of the Module with only tx.ModelState TreeParts, alias for filter(tx.ModelState) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/dropout.py def model_states ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.ModelState TreeParts, alias for `filter(tx.ModelState)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . ModelState , * filters ) parameters ( self , * filters ) inherited Returns a copy of the Module with only tx.Parameter TreeParts, alias for filter(tx.Parameter) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/dropout.py def parameters ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Parameter TreeParts, alias for `filter(tx.Parameter)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . Parameter , * filters ) rngs ( self , * filters ) inherited Returns a copy of the Module with only tx.Rng TreeParts, alias for filter(tx.Rng) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/dropout.py def rngs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Rng TreeParts, alias for `filter(tx.Rng)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . Rng , * filters ) states ( self , * filters ) inherited Returns a copy of the Module with only tx.State TreeParts, alias for filter(tx.State) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/dropout.py def states ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.State TreeParts, alias for `filter(tx.State)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . State , * filters ) tabulate ( self , inputs =< treeo . types . Missing object at 0x7f29ce5c9220 > , depth =- 1 , signature = False , param_types = True ) inherited Returns a tabular representation of the module. Parameters: Name Type Description Default depth int The maximum depth of the representation in terms of nested Modules, -1 means no limit. -1 signature bool Whether to show the signature of the Module. False param_types bool Whether to show the types of the parameters. True Returns: Type Description str A string containing the tabular representation. Source code in treex/nn/dropout.py def tabulate ( self , inputs : tp . Union [ types . InputLike , to . Missing ] = to . MISSING , depth : int = - 1 , signature : bool = False , param_types : bool = True , ) -> str : \"\"\" Returns a tabular representation of the module. Arguments: depth: The maximum depth of the representation in terms of nested Modules, -1 means no limit. signature: Whether to show the signature of the Module. param_types: Whether to show the types of the parameters. Returns: A string containing the tabular representation. \"\"\" self = to . copy ( self ) if inputs is not to . MISSING : inputs = types . Inputs . from_value ( inputs ) if not isinstance ( self , tp . Callable ): raise TypeError ( \"`inputs` can only be specified if the module is a callable.\" ) with contexts . _Context ( call_info = {}): # call using self to preserve references def eval_call ( args , kwargs ): assert isinstance ( self , tp . Callable ) return self ( * args , ** kwargs ) jax . eval_shape ( eval_call , inputs . args , inputs . kwargs , ) call_info = contexts . _CONTEXT . call_info else : call_info = None with to . add_field_info (): flat : tp . List [ to . FieldInfo ] flat , _ = jax . tree_flatten ( self ) tree_part_types : tp . Tuple [ tp . Type [ types . TreePart ], ... ] = tuple ( { field_info . kind for field_info in flat if utils . _generic_issubclass ( field_info . kind , types . TreePart ) } ) path = () rows = list ( utils . _get_tabulate_rows ( path , self , depth , tree_part_types , signature , param_types ) ) modules = [ row [ 0 ] for row in rows ] rows = [ row [ 1 :] for row in rows ] if call_info is not None : for module , row in zip ( modules , rows ): if module in call_info : inputs , outputs = call_info [ module ] simplified_inputs = ( inputs . args [ 0 ] if len ( inputs . kwargs ) == 0 and len ( inputs . args ) == 1 else inputs . kwargs if len ( inputs . kwargs ) == 0 else inputs . kwargs if len ( inputs . args ) == 0 else ( inputs . args , inputs . kwargs ) ) inputs_repr = utils . _format_param_tree ( simplified_inputs ) outputs_repr = utils . _format_param_tree ( outputs ) else : inputs_repr = \"\" outputs_repr = \"\" row . insert ( 3 , outputs_repr ) row . insert ( 3 , inputs_repr ) n_non_treepart_cols = 2 if call_info is None else 4 rows [ 0 ][ 0 ] = \"*\" rows . append ( [ \"\" ] * n_non_treepart_cols + [ \"Total:\" ] + [ utils . _format_obj_size ( self . filter ( kind ), add_padding = True ) for kind in tree_part_types ] ) utils . _add_padding ( rows ) table = Table ( show_header = True , show_lines = True , show_footer = True , # box=rich.box.HORIZONTALS, ) table . add_column ( \"path\" ) table . add_column ( \"module\" ) table . add_column ( \"params\" ) if call_info is not None : table . add_column ( \"inputs\" ) table . add_column ( \"outputs\" ) for tree_part_type in tree_part_types : type_name = tree_part_type . __name__ if type_name . startswith ( \"_\" ): type_name = type_name [ 1 :] table . add_column ( type_name ) for row in rows [: - 1 ]: table . add_row ( * row ) table . columns [ n_non_treepart_cols ] . footer = Text . from_markup ( rows [ - 1 ][ n_non_treepart_cols ], justify = \"right\" ) for i in range ( len ( tree_part_types )): table . columns [ n_non_treepart_cols + 1 + i ] . footer = rows [ - 1 ][ n_non_treepart_cols + 1 + i ] table . caption_style = \"bold\" table . caption = \" \\n Total Parameters: \" + utils . _format_obj_size ( self , add_padding = False ) return utils . _get_rich_repr ( table ) to_dict ( self , * , private_fields = False , static_fields = True , type_info = False , field_info = False ) inherited to_dict is a wrapper over treeo.to_dict that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True type_info bool If True , type information is included. False field_info bool If True , field information is included. False Returns: Type Description Any A dict representation of the object. Source code in treex/nn/dropout.py def to_dict ( self , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : \"\"\" `to_dict` is a wrapper over `treeo.to_dict` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. type_info: If `True`, type information is included. field_info: If `True`, field information is included. Returns: A dict representation of the object. \"\"\" return api . to_dict ( self , private_fields = private_fields , static_fields = static_fields , type_info = type_info , field_info = field_info , ) to_string ( self , * , private_fields = False , static_fields = True , color = False ) inherited to_string is a wrapper over treeo.to_string that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True color bool If True , color is included. False Returns: Type Description str A string representation of the object. Source code in treex/nn/dropout.py def to_string ( self : A , * , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" `to_string` is a wrapper over `treeo.to_string` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. color: If `True`, color is included. Returns: A string representation of the object. \"\"\" return api . to_string ( self , private_fields = private_fields , static_fields = static_fields , color = color , ) train ( self , mode = True , inplace = False ) inherited Creates a new module with the same structure, but with Module.training set to the given value. Parameters: Name Type Description Default mode bool The new training mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module in with the training mode is set to the given value, if inplace is True then self is returned. Source code in treex/nn/dropout.py def train ( self : T , mode : bool = True , inplace : bool = False ) -> T : \"\"\" Creates a new module with the same structure, but with `Module.training` set to the given value. Arguments: mode: The new training mode. inplace: Whether to update the module inplace. Returns: The new module in with the training mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_training ( tree ): if isinstance ( tree , Treex ) and hasattr ( tree , \"_training\" ): tree . _training = mode return to . apply ( set_training , self , inplace = inplace ) unfreeze ( self , inplace = False ) inherited Creates a new module with .frozen set to False, equivalent to calling freeze(False) . Parameters: Name Type Description Default inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module with .frozen set to False, if inplace is True then self is returned. Source code in treex/nn/dropout.py def unfreeze ( self : T , inplace : bool = False ) -> T : \"\"\" Creates a new module with `.frozen` set to False, equivalent to calling `freeze(False)`. Arguments: inplace: Whether to update the module inplace. Returns: The new module with `.frozen` set to False, if `inplace` is `True` then `self` is returned. \"\"\" return self . freeze ( False , inplace = inplace )","title":"Dropout"},{"location":"api/Dropout/#treexdropout","text":"Create a dropout layer. Dropout is implemented as a wrapper over flax.linen.Dropout , its constructor arguments accept almost the same arguments including any Flax artifacts such as initializers. Main differences: deterministic is not a constructor argument, but remains a __call__ argument. self.training state is used to indicate how Dropout should behave, interally deterministic = not self.training or self.frozen is used unless deterministic is explicitly passed via __call__ . Dropout maintains an rng: Rng state which is used to generate random masks unless rng is passed via __call__ .","title":"treex.Dropout"},{"location":"api/Dropout/#treex.nn.dropout.Dropout.first_run","text":"Returns: Type Description bool True if its currently the first run of a compact method.","title":"first_run"},{"location":"api/Dropout/#treex.nn.dropout.Dropout.__class__","text":"","title":"__class__"},{"location":"api/Dropout/#treex.nn.dropout.Dropout.__class__.__base__","text":"","title":"__base__"},{"location":"api/Dropout/#treex.nn.dropout.Dropout.__class__.__base__.__base__","text":"Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()).","title":"__base__"},{"location":"api/Dropout/#treex.nn.dropout.Dropout.__class__.__base__.__base__.__instancecheck__","text":"Override for isinstance(instance, cls). Source code in treex/nn/dropout.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance )","title":"__instancecheck__()"},{"location":"api/Dropout/#treex.nn.dropout.Dropout.__class__.__base__.__base__.__new__","text":"Create and return a new object. See help(type) for accurate signature. Source code in treex/nn/dropout.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls","title":"__new__()"},{"location":"api/Dropout/#treex.nn.dropout.Dropout.__class__.__base__.__base__.__subclasscheck__","text":"Override for issubclass(subclass, cls). Source code in treex/nn/dropout.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass )","title":"__subclasscheck__()"},{"location":"api/Dropout/#treex.nn.dropout.Dropout.__class__.__base__.__base__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/dropout.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/Dropout/#treex.nn.dropout.Dropout.__class__.__base__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/dropout.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/Dropout/#treex.nn.dropout.Dropout.__class__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/dropout.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/Dropout/#treex.nn.dropout.Dropout.__call__","text":"Applies a random dropout mask to the input. Parameters: Name Type Description Default x ndarray the inputs that should be randomly masked. required deterministic Optional[bool] if false the inputs are scaled by 1 / (1 - rate) and masked, whereas if true, no mask is applied and the inputs are returned as is. None rng an optional jax.random.PRNGKey . By default self.rng will be used. None Returns: Type Description ndarray The masked inputs reweighted to preserve mean. Source code in treex/nn/dropout.py def __call__ ( self , x : jnp . ndarray , deterministic : tp . Optional [ bool ] = None , rng = None ) -> jnp . ndarray : \"\"\"Applies a random dropout mask to the input. Arguments: x: the inputs that should be randomly masked. deterministic: if false the inputs are scaled by `1 / (1 - rate)` and masked, whereas if true, no mask is applied and the inputs are returned as is. rng: an optional `jax.random.PRNGKey`. By default `self.rng` will be used. Returns: The masked inputs reweighted to preserve mean. \"\"\" variables = dict () training = ( not deterministic if deterministic is not None else self . training and not self . frozen ) if rng is None : rng = self . next_key () if training else self . next_key . key # call apply output = self . module . apply ( variables , x , deterministic = not training , rng = rng , ) return tp . cast ( jnp . ndarray , output )","title":"__call__()"},{"location":"api/Dropout/#treex.nn.dropout.Dropout.__init__","text":"Create a dropout layer. Parameters: Name Type Description Default rate float the dropout probability. ( not the keep rate!) required broadcast_dims Iterable[int] dimensions that will share the same dropout mask () Source code in treex/nn/dropout.py def __init__ ( self , rate : float , broadcast_dims : tp . Iterable [ int ] = (), ): \"\"\" Create a dropout layer. Arguments: rate: the dropout probability. (_not_ the keep rate!) broadcast_dims: dimensions that will share the same dropout mask \"\"\" self . rate = rate self . broadcast_dims = broadcast_dims self . next_key = KeySeq ()","title":"__init__()"},{"location":"api/Dropout/#treex.nn.dropout.Dropout.apply","text":"apply is a wrapper over treeo.apply that passes self as the second argument. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treex/nn/dropout.py def apply ( self : A , f : tp . Callable [ ... , None ], * rest : A , inplace : bool = False ) -> A : \"\"\" `apply` is a wrapper over `treeo.apply` that passes `self` as the second argument. Arguments: f: The function to apply. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" return api . apply ( f , self , * rest , inplace = inplace )","title":"apply()"},{"location":"api/Dropout/#treex.nn.dropout.Dropout.batch_stats","text":"Returns a copy of the Module with only tx.BatchStat TreeParts, alias for filter(tx.BatchStat) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/dropout.py def batch_stats ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.BatchStat TreeParts, alias for `filter(tx.BatchStat)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . BatchStat , * filters )","title":"batch_stats()"},{"location":"api/Dropout/#treex.nn.dropout.Dropout.check_metadata_updates","text":"Checks for new fields, if found, adds them to the metadata. Source code in treex/nn/dropout.py def check_metadata_updates ( self ): \"\"\" Checks for new fields, if found, adds them to the metadata. \"\"\" with _CONTEXT . update ( flatten_mode = FlattenMode . all_fields ): jax . tree_flatten ( self )","title":"check_metadata_updates()"},{"location":"api/Dropout/#treex.nn.dropout.Dropout.copy","text":"copy is a wrapper over treeo.copy that passes self as the first argument. Source code in treex/nn/dropout.py def copy ( self : A ) -> A : \"\"\" `copy` is a wrapper over `treeo.copy` that passes `self` as the first argument. \"\"\" return tree_m . copy ( self )","title":"copy()"},{"location":"api/Dropout/#treex.nn.dropout.Dropout.eval","text":"Creates a new module with the training mode set to False, equivalent to calling train(False) . Returns: Type Description ~T The new module with the training mode set to False. Source code in treex/nn/dropout.py def eval ( self : T , inplace : bool = False ) -> T : \"\"\" Creates a new module with the training mode set to False, equivalent to calling `train(False)`. Returns: The new module with the training mode set to False. \"\"\" return self . train ( False , inplace = inplace )","title":"eval()"},{"location":"api/Dropout/#treex.nn.dropout.Dropout.filter","text":"filter is a wrapper over treeo.filter that passes self as the first argument. Parameters: Name Type Description Default *filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treex/nn/dropout.py def filter ( self : A , * filters : api . Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ) -> A : \"\"\" `filter` is a wrapper over `treeo.filter` that passes `self` as the first argument. Arguments: *filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" return api . filter ( self , * filters , inplace = inplace , flatten_mode = flatten_mode )","title":"filter()"},{"location":"api/Dropout/#treex.nn.dropout.Dropout.freeze","text":"Creates a new module with the same structure, but with Module.frozen set to the given value. Parameters: Name Type Description Default mode bool The new frozen mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module in with the frozen mode is set to the given value, if inplace is True then self is returned. Source code in treex/nn/dropout.py def freeze ( self : T , mode : bool = True , inplace : bool = False ) -> T : \"\"\" Creates a new module with the same structure, but with `Module.frozen` set to the given value. Arguments: mode: The new `frozen` mode. inplace: Whether to update the module inplace. Returns: The new module in with the `frozen` mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_frozen ( tree ): if isinstance ( tree , Treex ) and hasattr ( tree , \"_frozen\" ): tree . _frozen = mode return to . apply ( set_frozen , self , inplace = inplace )","title":"freeze()"},{"location":"api/Dropout/#treex.nn.dropout.Dropout.get_field","text":"A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: The field must be declared in the class definition. The method can only be called inside a compact context. Parameters: Name Type Description Default field_name str The name of the field to get. required initializer Callable[[], ~A] The function to initialize the field if it does not exist. required Returns: Type Description ~A The field value. Source code in treex/nn/dropout.py def get_field ( self , field_name : str , initializer : tp . Callable [[], A ], ) -> A : \"\"\" A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: * The field must be declared in the class definition. * The method can only be called inside a `compact` context. Arguments: field_name: The name of the field to get. initializer: The function to initialize the field if it does not exist. Returns: The field value. \"\"\" value : A if field_name not in self . _field_metadata : raise ValueError ( f \"Metadata for field ' { field_name } ' does not exist.\" ) if field_name in vars ( self ): value = getattr ( self , field_name ) else : if tree_m . _COMPACT_CONTEXT . in_compact and not self . first_run : raise RuntimeError ( f \"Trying to initialize field ' { field_name } ' after the first run of `compact`.\" ) value = initializer () setattr ( self , field_name , value ) return value","title":"get_field()"},{"location":"api/Dropout/#treex.nn.dropout.Dropout.init","text":"Method version of tx.init , it applies self as first argument. init creates a new module with the same structure, but with its fields initialized given a seed key . The following procedure is used: The input key is split and iteratively updated before passing a derived value to any process that requires initialization. Initializer s are called and applied to the module first. Module.rng_init methods are called last. Parameters: Name Type Description Default key Union[int, jax._src.numpy.lax_numpy.ndarray] The seed to use for initialization. required Returns: Type Description ~M The new module with the fields initialized. Source code in treex/nn/dropout.py def init ( self : M , key : tp . Union [ int , jnp . ndarray ], inputs : types . InputLike = to . MISSING , call_method : str = \"__call__\" , * , inplace : bool = False , _set_initialize : bool = True , ) -> M : \"\"\" Method version of `tx.init`, it applies `self` as first argument. `init` creates a new module with the same structure, but with its fields initialized given a seed `key`. The following procedure is used: 1. The input `key` is split and iteratively updated before passing a derived value to any process that requires initialization. 2. `Initializer`s are called and applied to the module first. 3. `Module.rng_init` methods are called last. Arguments: key: The seed to use for initialization. Returns: The new module with the fields initialized. \"\"\" module = self . copy () if not inplace else self key = utils . Key ( key ) with _INIT_CONTEXT . update ( key = key , initializing = True ): module : M = module . map ( lambda initializer : ( initializer ( next_key ()) if isinstance ( initializer , types . Initializer ) else initializer ), is_leaf = lambda x : isinstance ( x , types . Initializer ), inplace = True , ) def call_rng_init ( module : Module ): if isinstance ( module , Module ) and not module . _initialized : module . rng_init () module = to . apply ( call_rng_init , module , inplace = True ) if inputs is not to . MISSING : inputs = types . Inputs . from_value ( inputs ) method = getattr ( module , call_method ) method ( * inputs . args , ** inputs . kwargs ) if _set_initialize : def set_initialized ( module : Module ): if isinstance ( module , Module ) and not module . _initialized : module . _initialized = True module = to . apply ( set_initialized , module , inplace = True ) return module","title":"init()"},{"location":"api/Dropout/#treex.nn.dropout.Dropout.logs","text":"Returns a copy of the Module with only tx.Log TreeParts, alias for filter(tx.Log) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/dropout.py def logs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Log TreeParts, alias for `filter(tx.Log)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . Log , * filters )","title":"logs()"},{"location":"api/Dropout/#treex.nn.dropout.Dropout.loss_logs","text":"Returns a copy of the Module with only tx.Loss TreeParts, alias for filter(tx.Loss) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/dropout.py def loss_logs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Loss TreeParts, alias for `filter(tx.Loss)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . LossLog , * filters )","title":"loss_logs()"},{"location":"api/Dropout/#treex.nn.dropout.Dropout.map","text":"map is a wrapper over treeo.map that passes self as the second argument. Parameters: Name Type Description Default f Callable The function to apply to the leaves. required *filters Filter The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treex/nn/dropout.py def map ( self : A , f : tp . Callable , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , is_leaf : tp . Callable [[ tp . Any ], bool ] = None , ) -> A : \"\"\" `map` is a wrapper over `treeo.map` that passes `self` as the second argument. Arguments: f: The function to apply to the leaves. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" return api . map ( f , self , * filters , inplace = inplace , flatten_mode = flatten_mode , is_leaf = is_leaf , )","title":"map()"},{"location":"api/Dropout/#treex.nn.dropout.Dropout.merge","text":"merge is a wrapper over treeo.merge that passes self as the first argument. Parameters: Name Type Description Default other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the merged values. If inplace is True , obj is returned. Source code in treex/nn/dropout.py def merge ( self : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" `merge` is a wrapper over `treeo.merge` that passes `self` as the first argument. Arguments: other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the merged values. If `inplace` is `True`, `obj` is returned. \"\"\" return api . merge ( self , other , * rest , inplace = inplace , flatten_mode = flatten_mode , ignore_static = ignore_static , )","title":"merge()"},{"location":"api/Dropout/#treex.nn.dropout.Dropout.metric_logs","text":"Returns a copy of the Module with only tx.Metric TreeParts, alias for filter(tx.Metric) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/dropout.py def metric_logs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Metric TreeParts, alias for `filter(tx.Metric)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . MetricLog , * filters )","title":"metric_logs()"},{"location":"api/Dropout/#treex.nn.dropout.Dropout.model_states","text":"Returns a copy of the Module with only tx.ModelState TreeParts, alias for filter(tx.ModelState) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/dropout.py def model_states ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.ModelState TreeParts, alias for `filter(tx.ModelState)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . ModelState , * filters )","title":"model_states()"},{"location":"api/Dropout/#treex.nn.dropout.Dropout.parameters","text":"Returns a copy of the Module with only tx.Parameter TreeParts, alias for filter(tx.Parameter) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/dropout.py def parameters ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Parameter TreeParts, alias for `filter(tx.Parameter)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . Parameter , * filters )","title":"parameters()"},{"location":"api/Dropout/#treex.nn.dropout.Dropout.rngs","text":"Returns a copy of the Module with only tx.Rng TreeParts, alias for filter(tx.Rng) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/dropout.py def rngs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Rng TreeParts, alias for `filter(tx.Rng)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . Rng , * filters )","title":"rngs()"},{"location":"api/Dropout/#treex.nn.dropout.Dropout.states","text":"Returns a copy of the Module with only tx.State TreeParts, alias for filter(tx.State) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/dropout.py def states ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.State TreeParts, alias for `filter(tx.State)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . State , * filters )","title":"states()"},{"location":"api/Dropout/#treex.nn.dropout.Dropout.tabulate","text":"Returns a tabular representation of the module. Parameters: Name Type Description Default depth int The maximum depth of the representation in terms of nested Modules, -1 means no limit. -1 signature bool Whether to show the signature of the Module. False param_types bool Whether to show the types of the parameters. True Returns: Type Description str A string containing the tabular representation. Source code in treex/nn/dropout.py def tabulate ( self , inputs : tp . Union [ types . InputLike , to . Missing ] = to . MISSING , depth : int = - 1 , signature : bool = False , param_types : bool = True , ) -> str : \"\"\" Returns a tabular representation of the module. Arguments: depth: The maximum depth of the representation in terms of nested Modules, -1 means no limit. signature: Whether to show the signature of the Module. param_types: Whether to show the types of the parameters. Returns: A string containing the tabular representation. \"\"\" self = to . copy ( self ) if inputs is not to . MISSING : inputs = types . Inputs . from_value ( inputs ) if not isinstance ( self , tp . Callable ): raise TypeError ( \"`inputs` can only be specified if the module is a callable.\" ) with contexts . _Context ( call_info = {}): # call using self to preserve references def eval_call ( args , kwargs ): assert isinstance ( self , tp . Callable ) return self ( * args , ** kwargs ) jax . eval_shape ( eval_call , inputs . args , inputs . kwargs , ) call_info = contexts . _CONTEXT . call_info else : call_info = None with to . add_field_info (): flat : tp . List [ to . FieldInfo ] flat , _ = jax . tree_flatten ( self ) tree_part_types : tp . Tuple [ tp . Type [ types . TreePart ], ... ] = tuple ( { field_info . kind for field_info in flat if utils . _generic_issubclass ( field_info . kind , types . TreePart ) } ) path = () rows = list ( utils . _get_tabulate_rows ( path , self , depth , tree_part_types , signature , param_types ) ) modules = [ row [ 0 ] for row in rows ] rows = [ row [ 1 :] for row in rows ] if call_info is not None : for module , row in zip ( modules , rows ): if module in call_info : inputs , outputs = call_info [ module ] simplified_inputs = ( inputs . args [ 0 ] if len ( inputs . kwargs ) == 0 and len ( inputs . args ) == 1 else inputs . kwargs if len ( inputs . kwargs ) == 0 else inputs . kwargs if len ( inputs . args ) == 0 else ( inputs . args , inputs . kwargs ) ) inputs_repr = utils . _format_param_tree ( simplified_inputs ) outputs_repr = utils . _format_param_tree ( outputs ) else : inputs_repr = \"\" outputs_repr = \"\" row . insert ( 3 , outputs_repr ) row . insert ( 3 , inputs_repr ) n_non_treepart_cols = 2 if call_info is None else 4 rows [ 0 ][ 0 ] = \"*\" rows . append ( [ \"\" ] * n_non_treepart_cols + [ \"Total:\" ] + [ utils . _format_obj_size ( self . filter ( kind ), add_padding = True ) for kind in tree_part_types ] ) utils . _add_padding ( rows ) table = Table ( show_header = True , show_lines = True , show_footer = True , # box=rich.box.HORIZONTALS, ) table . add_column ( \"path\" ) table . add_column ( \"module\" ) table . add_column ( \"params\" ) if call_info is not None : table . add_column ( \"inputs\" ) table . add_column ( \"outputs\" ) for tree_part_type in tree_part_types : type_name = tree_part_type . __name__ if type_name . startswith ( \"_\" ): type_name = type_name [ 1 :] table . add_column ( type_name ) for row in rows [: - 1 ]: table . add_row ( * row ) table . columns [ n_non_treepart_cols ] . footer = Text . from_markup ( rows [ - 1 ][ n_non_treepart_cols ], justify = \"right\" ) for i in range ( len ( tree_part_types )): table . columns [ n_non_treepart_cols + 1 + i ] . footer = rows [ - 1 ][ n_non_treepart_cols + 1 + i ] table . caption_style = \"bold\" table . caption = \" \\n Total Parameters: \" + utils . _format_obj_size ( self , add_padding = False ) return utils . _get_rich_repr ( table )","title":"tabulate()"},{"location":"api/Dropout/#treex.nn.dropout.Dropout.to_dict","text":"to_dict is a wrapper over treeo.to_dict that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True type_info bool If True , type information is included. False field_info bool If True , field information is included. False Returns: Type Description Any A dict representation of the object. Source code in treex/nn/dropout.py def to_dict ( self , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : \"\"\" `to_dict` is a wrapper over `treeo.to_dict` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. type_info: If `True`, type information is included. field_info: If `True`, field information is included. Returns: A dict representation of the object. \"\"\" return api . to_dict ( self , private_fields = private_fields , static_fields = static_fields , type_info = type_info , field_info = field_info , )","title":"to_dict()"},{"location":"api/Dropout/#treex.nn.dropout.Dropout.to_string","text":"to_string is a wrapper over treeo.to_string that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True color bool If True , color is included. False Returns: Type Description str A string representation of the object. Source code in treex/nn/dropout.py def to_string ( self : A , * , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" `to_string` is a wrapper over `treeo.to_string` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. color: If `True`, color is included. Returns: A string representation of the object. \"\"\" return api . to_string ( self , private_fields = private_fields , static_fields = static_fields , color = color , )","title":"to_string()"},{"location":"api/Dropout/#treex.nn.dropout.Dropout.train","text":"Creates a new module with the same structure, but with Module.training set to the given value. Parameters: Name Type Description Default mode bool The new training mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module in with the training mode is set to the given value, if inplace is True then self is returned. Source code in treex/nn/dropout.py def train ( self : T , mode : bool = True , inplace : bool = False ) -> T : \"\"\" Creates a new module with the same structure, but with `Module.training` set to the given value. Arguments: mode: The new training mode. inplace: Whether to update the module inplace. Returns: The new module in with the training mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_training ( tree ): if isinstance ( tree , Treex ) and hasattr ( tree , \"_training\" ): tree . _training = mode return to . apply ( set_training , self , inplace = inplace )","title":"train()"},{"location":"api/Dropout/#treex.nn.dropout.Dropout.unfreeze","text":"Creates a new module with .frozen set to False, equivalent to calling freeze(False) . Parameters: Name Type Description Default inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module with .frozen set to False, if inplace is True then self is returned. Source code in treex/nn/dropout.py def unfreeze ( self : T , inplace : bool = False ) -> T : \"\"\" Creates a new module with `.frozen` set to False, equivalent to calling `freeze(False)`. Arguments: inplace: Whether to update the module inplace. Returns: The new module with `.frozen` set to False, if `inplace` is `True` then `self` is returned. \"\"\" return self . freeze ( False , inplace = inplace )","title":"unfreeze()"},{"location":"api/Extensions/","text":"treex.Extensions Mixin that adds all available mixins from treeo.mixins except KindMixin . first_run : bool inherited property readonly Returns: Type Description bool True if its currently the first run of a compact method. __repr__ ( self ) inherited special Uses treeo.to_string to generate a string representation of the object. Source code in treeo/mixins.py def __repr__ ( self ) -> tp . Any : \"\"\" Uses `treeo.to_string` to generate a string representation of the object. \"\"\" return api . to_string ( self , private_fields = False , static_fields = True , color = False , ) apply ( self , f , * rest , * , inplace = False ) inherited apply is a wrapper over treeo.apply that passes self as the second argument. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treeo/mixins.py def apply ( self : A , f : tp . Callable [ ... , None ], * rest : A , inplace : bool = False ) -> A : \"\"\" `apply` is a wrapper over `treeo.apply` that passes `self` as the second argument. Arguments: f: The function to apply. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" return api . apply ( f , self , * rest , inplace = inplace ) copy ( self ) inherited copy is a wrapper over treeo.copy that passes self as the first argument. Source code in treeo/mixins.py def copy ( self : A ) -> A : \"\"\" `copy` is a wrapper over `treeo.copy` that passes `self` as the first argument. \"\"\" return tree_m . copy ( self ) filter ( self , * filters , * , inplace = False , flatten_mode = None ) inherited filter is a wrapper over treeo.filter that passes self as the first argument. Parameters: Name Type Description Default *filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treeo/mixins.py def filter ( self : A , * filters : api . Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ) -> A : \"\"\" `filter` is a wrapper over `treeo.filter` that passes `self` as the first argument. Arguments: *filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" return api . filter ( self , * filters , inplace = inplace , flatten_mode = flatten_mode ) get_field ( self , field_name , initializer ) inherited A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: The field must be declared in the class definition. The method can only be called inside a compact context. Parameters: Name Type Description Default field_name str The name of the field to get. required initializer Callable[[], ~A] The function to initialize the field if it does not exist. required Returns: Type Description ~A The field value. Source code in treeo/mixins.py def get_field ( self , field_name : str , initializer : tp . Callable [[], A ], ) -> A : \"\"\" A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: * The field must be declared in the class definition. * The method can only be called inside a `compact` context. Arguments: field_name: The name of the field to get. initializer: The function to initialize the field if it does not exist. Returns: The field value. \"\"\" value : A if field_name not in self . _field_metadata : raise ValueError ( f \"Metadata for field ' { field_name } ' does not exist.\" ) if field_name in vars ( self ): value = getattr ( self , field_name ) else : if tree_m . _COMPACT_CONTEXT . in_compact and not self . first_run : raise RuntimeError ( f \"Trying to initialize field ' { field_name } ' after the first run of `compact`.\" ) value = initializer () setattr ( self , field_name , value ) return value map ( self , f , * filters , * , inplace = False , flatten_mode = None , is_leaf = None ) inherited map is a wrapper over treeo.map that passes self as the second argument. Parameters: Name Type Description Default f Callable The function to apply to the leaves. required *filters Filter The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treeo/mixins.py def map ( self : A , f : tp . Callable , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , is_leaf : tp . Callable [[ tp . Any ], bool ] = None , ) -> A : \"\"\" `map` is a wrapper over `treeo.map` that passes `self` as the second argument. Arguments: f: The function to apply to the leaves. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" return api . map ( f , self , * filters , inplace = inplace , flatten_mode = flatten_mode , is_leaf = is_leaf , ) merge ( self , other , * rest , * , inplace = False , flatten_mode = None , ignore_static = False ) inherited merge is a wrapper over treeo.merge that passes self as the first argument. Parameters: Name Type Description Default other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the merged values. If inplace is True , obj is returned. Source code in treeo/mixins.py def merge ( self : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" `merge` is a wrapper over `treeo.merge` that passes `self` as the first argument. Arguments: other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the merged values. If `inplace` is `True`, `obj` is returned. \"\"\" return api . merge ( self , other , * rest , inplace = inplace , flatten_mode = flatten_mode , ignore_static = ignore_static , ) to_dict ( self , * , private_fields = False , static_fields = True , type_info = False , field_info = False ) inherited to_dict is a wrapper over treeo.to_dict that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True type_info bool If True , type information is included. False field_info bool If True , field information is included. False Returns: Type Description Any A dict representation of the object. Source code in treeo/mixins.py def to_dict ( self , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : \"\"\" `to_dict` is a wrapper over `treeo.to_dict` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. type_info: If `True`, type information is included. field_info: If `True`, field information is included. Returns: A dict representation of the object. \"\"\" return api . to_dict ( self , private_fields = private_fields , static_fields = static_fields , type_info = type_info , field_info = field_info , ) to_string ( self , * , private_fields = False , static_fields = True , color = False ) inherited to_string is a wrapper over treeo.to_string that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True color bool If True , color is included. False Returns: Type Description str A string representation of the object. Source code in treeo/mixins.py def to_string ( self : A , * , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" `to_string` is a wrapper over `treeo.to_string` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. color: If `True`, color is included. Returns: A string representation of the object. \"\"\" return api . to_string ( self , private_fields = private_fields , static_fields = static_fields , color = color , )","title":"Extensions"},{"location":"api/Extensions/#treexextensions","text":"Mixin that adds all available mixins from treeo.mixins except KindMixin .","title":"treex.Extensions"},{"location":"api/Extensions/#treeo.mixins.Extensions.first_run","text":"Returns: Type Description bool True if its currently the first run of a compact method.","title":"first_run"},{"location":"api/Extensions/#treeo.mixins.Extensions.__repr__","text":"Uses treeo.to_string to generate a string representation of the object. Source code in treeo/mixins.py def __repr__ ( self ) -> tp . Any : \"\"\" Uses `treeo.to_string` to generate a string representation of the object. \"\"\" return api . to_string ( self , private_fields = False , static_fields = True , color = False , )","title":"__repr__()"},{"location":"api/Extensions/#treeo.mixins.Extensions.apply","text":"apply is a wrapper over treeo.apply that passes self as the second argument. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treeo/mixins.py def apply ( self : A , f : tp . Callable [ ... , None ], * rest : A , inplace : bool = False ) -> A : \"\"\" `apply` is a wrapper over `treeo.apply` that passes `self` as the second argument. Arguments: f: The function to apply. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" return api . apply ( f , self , * rest , inplace = inplace )","title":"apply()"},{"location":"api/Extensions/#treeo.mixins.Extensions.copy","text":"copy is a wrapper over treeo.copy that passes self as the first argument. Source code in treeo/mixins.py def copy ( self : A ) -> A : \"\"\" `copy` is a wrapper over `treeo.copy` that passes `self` as the first argument. \"\"\" return tree_m . copy ( self )","title":"copy()"},{"location":"api/Extensions/#treeo.mixins.Extensions.filter","text":"filter is a wrapper over treeo.filter that passes self as the first argument. Parameters: Name Type Description Default *filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treeo/mixins.py def filter ( self : A , * filters : api . Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ) -> A : \"\"\" `filter` is a wrapper over `treeo.filter` that passes `self` as the first argument. Arguments: *filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" return api . filter ( self , * filters , inplace = inplace , flatten_mode = flatten_mode )","title":"filter()"},{"location":"api/Extensions/#treeo.mixins.Extensions.get_field","text":"A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: The field must be declared in the class definition. The method can only be called inside a compact context. Parameters: Name Type Description Default field_name str The name of the field to get. required initializer Callable[[], ~A] The function to initialize the field if it does not exist. required Returns: Type Description ~A The field value. Source code in treeo/mixins.py def get_field ( self , field_name : str , initializer : tp . Callable [[], A ], ) -> A : \"\"\" A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: * The field must be declared in the class definition. * The method can only be called inside a `compact` context. Arguments: field_name: The name of the field to get. initializer: The function to initialize the field if it does not exist. Returns: The field value. \"\"\" value : A if field_name not in self . _field_metadata : raise ValueError ( f \"Metadata for field ' { field_name } ' does not exist.\" ) if field_name in vars ( self ): value = getattr ( self , field_name ) else : if tree_m . _COMPACT_CONTEXT . in_compact and not self . first_run : raise RuntimeError ( f \"Trying to initialize field ' { field_name } ' after the first run of `compact`.\" ) value = initializer () setattr ( self , field_name , value ) return value","title":"get_field()"},{"location":"api/Extensions/#treeo.mixins.Extensions.map","text":"map is a wrapper over treeo.map that passes self as the second argument. Parameters: Name Type Description Default f Callable The function to apply to the leaves. required *filters Filter The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treeo/mixins.py def map ( self : A , f : tp . Callable , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , is_leaf : tp . Callable [[ tp . Any ], bool ] = None , ) -> A : \"\"\" `map` is a wrapper over `treeo.map` that passes `self` as the second argument. Arguments: f: The function to apply to the leaves. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" return api . map ( f , self , * filters , inplace = inplace , flatten_mode = flatten_mode , is_leaf = is_leaf , )","title":"map()"},{"location":"api/Extensions/#treeo.mixins.Extensions.merge","text":"merge is a wrapper over treeo.merge that passes self as the first argument. Parameters: Name Type Description Default other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the merged values. If inplace is True , obj is returned. Source code in treeo/mixins.py def merge ( self : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" `merge` is a wrapper over `treeo.merge` that passes `self` as the first argument. Arguments: other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the merged values. If `inplace` is `True`, `obj` is returned. \"\"\" return api . merge ( self , other , * rest , inplace = inplace , flatten_mode = flatten_mode , ignore_static = ignore_static , )","title":"merge()"},{"location":"api/Extensions/#treeo.mixins.Extensions.to_dict","text":"to_dict is a wrapper over treeo.to_dict that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True type_info bool If True , type information is included. False field_info bool If True , field information is included. False Returns: Type Description Any A dict representation of the object. Source code in treeo/mixins.py def to_dict ( self , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : \"\"\" `to_dict` is a wrapper over `treeo.to_dict` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. type_info: If `True`, type information is included. field_info: If `True`, field information is included. Returns: A dict representation of the object. \"\"\" return api . to_dict ( self , private_fields = private_fields , static_fields = static_fields , type_info = type_info , field_info = field_info , )","title":"to_dict()"},{"location":"api/Extensions/#treeo.mixins.Extensions.to_string","text":"to_string is a wrapper over treeo.to_string that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True color bool If True , color is included. False Returns: Type Description str A string representation of the object. Source code in treeo/mixins.py def to_string ( self : A , * , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" `to_string` is a wrapper over `treeo.to_string` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. color: If `True`, color is included. Returns: A string representation of the object. \"\"\" return api . to_string ( self , private_fields = private_fields , static_fields = static_fields , color = color , )","title":"to_string()"},{"location":"api/FieldInfo/","text":"treex.FieldInfo","title":"FieldInfo"},{"location":"api/FieldInfo/#treexfieldinfo","text":"","title":"treex.FieldInfo"},{"location":"api/FieldMetadata/","text":"treex.FieldMetadata","title":"FieldMetadata"},{"location":"api/FieldMetadata/#treexfieldmetadata","text":"","title":"treex.FieldMetadata"},{"location":"api/Filters/","text":"treex.Filters batch_stats ( self , * filters ) Returns a copy of the Module with only tx.BatchStat TreeParts, alias for filter(tx.BatchStat) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/treex.py def batch_stats ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.BatchStat TreeParts, alias for `filter(tx.BatchStat)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . BatchStat , * filters ) logs ( self , * filters ) Returns a copy of the Module with only tx.Log TreeParts, alias for filter(tx.Log) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/treex.py def logs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Log TreeParts, alias for `filter(tx.Log)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . Log , * filters ) loss_logs ( self , * filters ) Returns a copy of the Module with only tx.Loss TreeParts, alias for filter(tx.Loss) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/treex.py def loss_logs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Loss TreeParts, alias for `filter(tx.Loss)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . LossLog , * filters ) metric_logs ( self , * filters ) Returns a copy of the Module with only tx.Metric TreeParts, alias for filter(tx.Metric) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/treex.py def metric_logs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Metric TreeParts, alias for `filter(tx.Metric)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . MetricLog , * filters ) model_states ( self , * filters ) Returns a copy of the Module with only tx.ModelState TreeParts, alias for filter(tx.ModelState) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/treex.py def model_states ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.ModelState TreeParts, alias for `filter(tx.ModelState)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . ModelState , * filters ) parameters ( self , * filters ) Returns a copy of the Module with only tx.Parameter TreeParts, alias for filter(tx.Parameter) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/treex.py def parameters ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Parameter TreeParts, alias for `filter(tx.Parameter)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . Parameter , * filters ) rngs ( self , * filters ) Returns a copy of the Module with only tx.Rng TreeParts, alias for filter(tx.Rng) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/treex.py def rngs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Rng TreeParts, alias for `filter(tx.Rng)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . Rng , * filters ) states ( self , * filters ) Returns a copy of the Module with only tx.State TreeParts, alias for filter(tx.State) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/treex.py def states ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.State TreeParts, alias for `filter(tx.State)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . State , * filters )","title":"Filters"},{"location":"api/Filters/#treexfilters","text":"","title":"treex.Filters"},{"location":"api/Filters/#treex.treex.Filters.batch_stats","text":"Returns a copy of the Module with only tx.BatchStat TreeParts, alias for filter(tx.BatchStat) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/treex.py def batch_stats ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.BatchStat TreeParts, alias for `filter(tx.BatchStat)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . BatchStat , * filters )","title":"batch_stats()"},{"location":"api/Filters/#treex.treex.Filters.logs","text":"Returns a copy of the Module with only tx.Log TreeParts, alias for filter(tx.Log) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/treex.py def logs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Log TreeParts, alias for `filter(tx.Log)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . Log , * filters )","title":"logs()"},{"location":"api/Filters/#treex.treex.Filters.loss_logs","text":"Returns a copy of the Module with only tx.Loss TreeParts, alias for filter(tx.Loss) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/treex.py def loss_logs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Loss TreeParts, alias for `filter(tx.Loss)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . LossLog , * filters )","title":"loss_logs()"},{"location":"api/Filters/#treex.treex.Filters.metric_logs","text":"Returns a copy of the Module with only tx.Metric TreeParts, alias for filter(tx.Metric) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/treex.py def metric_logs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Metric TreeParts, alias for `filter(tx.Metric)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . MetricLog , * filters )","title":"metric_logs()"},{"location":"api/Filters/#treex.treex.Filters.model_states","text":"Returns a copy of the Module with only tx.ModelState TreeParts, alias for filter(tx.ModelState) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/treex.py def model_states ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.ModelState TreeParts, alias for `filter(tx.ModelState)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . ModelState , * filters )","title":"model_states()"},{"location":"api/Filters/#treex.treex.Filters.parameters","text":"Returns a copy of the Module with only tx.Parameter TreeParts, alias for filter(tx.Parameter) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/treex.py def parameters ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Parameter TreeParts, alias for `filter(tx.Parameter)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . Parameter , * filters )","title":"parameters()"},{"location":"api/Filters/#treex.treex.Filters.rngs","text":"Returns a copy of the Module with only tx.Rng TreeParts, alias for filter(tx.Rng) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/treex.py def rngs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Rng TreeParts, alias for `filter(tx.Rng)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . Rng , * filters )","title":"rngs()"},{"location":"api/Filters/#treex.treex.Filters.states","text":"Returns a copy of the Module with only tx.State TreeParts, alias for filter(tx.State) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/treex.py def states ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.State TreeParts, alias for `filter(tx.State)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . State , * filters )","title":"states()"},{"location":"api/Flatten/","text":"treex.Flatten first_run : bool inherited property readonly Returns: Type Description bool True if its currently the first run of a compact method. __class__ inherited __base__ inherited __base__ inherited Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()). __instancecheck__ ( cls , instance ) special Override for isinstance(instance, cls). Source code in treex/nn/flatten.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance ) __new__ ( mcls , name , bases , namespace , ** kwargs ) special staticmethod Create and return a new object. See help(type) for accurate signature. Source code in treex/nn/flatten.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls __subclasscheck__ ( cls , subclass ) special Override for issubclass(subclass, cls). Source code in treex/nn/flatten.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass ) register ( cls , subclass ) Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/flatten.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) register ( cls , subclass ) inherited Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/flatten.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) register ( cls , subclass ) inherited Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/flatten.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) apply ( self , f , * rest , * , inplace = False ) inherited apply is a wrapper over treeo.apply that passes self as the second argument. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treex/nn/flatten.py def apply ( self : A , f : tp . Callable [ ... , None ], * rest : A , inplace : bool = False ) -> A : \"\"\" `apply` is a wrapper over `treeo.apply` that passes `self` as the second argument. Arguments: f: The function to apply. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" return api . apply ( f , self , * rest , inplace = inplace ) batch_stats ( self , * filters ) inherited Returns a copy of the Module with only tx.BatchStat TreeParts, alias for filter(tx.BatchStat) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/flatten.py def batch_stats ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.BatchStat TreeParts, alias for `filter(tx.BatchStat)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . BatchStat , * filters ) check_metadata_updates ( self ) inherited Checks for new fields, if found, adds them to the metadata. Source code in treex/nn/flatten.py def check_metadata_updates ( self ): \"\"\" Checks for new fields, if found, adds them to the metadata. \"\"\" with _CONTEXT . update ( flatten_mode = FlattenMode . all_fields ): jax . tree_flatten ( self ) copy ( self ) inherited copy is a wrapper over treeo.copy that passes self as the first argument. Source code in treex/nn/flatten.py def copy ( self : A ) -> A : \"\"\" `copy` is a wrapper over `treeo.copy` that passes `self` as the first argument. \"\"\" return tree_m . copy ( self ) eval ( self , inplace = False ) inherited Creates a new module with the training mode set to False, equivalent to calling train(False) . Returns: Type Description ~T The new module with the training mode set to False. Source code in treex/nn/flatten.py def eval ( self : T , inplace : bool = False ) -> T : \"\"\" Creates a new module with the training mode set to False, equivalent to calling `train(False)`. Returns: The new module with the training mode set to False. \"\"\" return self . train ( False , inplace = inplace ) filter ( self , * filters , * , inplace = False , flatten_mode = None ) inherited filter is a wrapper over treeo.filter that passes self as the first argument. Parameters: Name Type Description Default *filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treex/nn/flatten.py def filter ( self : A , * filters : api . Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ) -> A : \"\"\" `filter` is a wrapper over `treeo.filter` that passes `self` as the first argument. Arguments: *filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" return api . filter ( self , * filters , inplace = inplace , flatten_mode = flatten_mode ) freeze ( self , mode = True , inplace = False ) inherited Creates a new module with the same structure, but with Module.frozen set to the given value. Parameters: Name Type Description Default mode bool The new frozen mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module in with the frozen mode is set to the given value, if inplace is True then self is returned. Source code in treex/nn/flatten.py def freeze ( self : T , mode : bool = True , inplace : bool = False ) -> T : \"\"\" Creates a new module with the same structure, but with `Module.frozen` set to the given value. Arguments: mode: The new `frozen` mode. inplace: Whether to update the module inplace. Returns: The new module in with the `frozen` mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_frozen ( tree ): if isinstance ( tree , Treex ) and hasattr ( tree , \"_frozen\" ): tree . _frozen = mode return to . apply ( set_frozen , self , inplace = inplace ) get_field ( self , field_name , initializer ) inherited A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: The field must be declared in the class definition. The method can only be called inside a compact context. Parameters: Name Type Description Default field_name str The name of the field to get. required initializer Callable[[], ~A] The function to initialize the field if it does not exist. required Returns: Type Description ~A The field value. Source code in treex/nn/flatten.py def get_field ( self , field_name : str , initializer : tp . Callable [[], A ], ) -> A : \"\"\" A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: * The field must be declared in the class definition. * The method can only be called inside a `compact` context. Arguments: field_name: The name of the field to get. initializer: The function to initialize the field if it does not exist. Returns: The field value. \"\"\" value : A if field_name not in self . _field_metadata : raise ValueError ( f \"Metadata for field ' { field_name } ' does not exist.\" ) if field_name in vars ( self ): value = getattr ( self , field_name ) else : if tree_m . _COMPACT_CONTEXT . in_compact and not self . first_run : raise RuntimeError ( f \"Trying to initialize field ' { field_name } ' after the first run of `compact`.\" ) value = initializer () setattr ( self , field_name , value ) return value init ( self , key , inputs =< treeo . types . Missing object at 0x7f29ce5c9220 > , call_method = '__call__' , * , inplace = False , _set_initialize = True ) inherited Method version of tx.init , it applies self as first argument. init creates a new module with the same structure, but with its fields initialized given a seed key . The following procedure is used: The input key is split and iteratively updated before passing a derived value to any process that requires initialization. Initializer s are called and applied to the module first. Module.rng_init methods are called last. Parameters: Name Type Description Default key Union[int, jax._src.numpy.lax_numpy.ndarray] The seed to use for initialization. required Returns: Type Description ~M The new module with the fields initialized. Source code in treex/nn/flatten.py def init ( self : M , key : tp . Union [ int , jnp . ndarray ], inputs : types . InputLike = to . MISSING , call_method : str = \"__call__\" , * , inplace : bool = False , _set_initialize : bool = True , ) -> M : \"\"\" Method version of `tx.init`, it applies `self` as first argument. `init` creates a new module with the same structure, but with its fields initialized given a seed `key`. The following procedure is used: 1. The input `key` is split and iteratively updated before passing a derived value to any process that requires initialization. 2. `Initializer`s are called and applied to the module first. 3. `Module.rng_init` methods are called last. Arguments: key: The seed to use for initialization. Returns: The new module with the fields initialized. \"\"\" module = self . copy () if not inplace else self key = utils . Key ( key ) with _INIT_CONTEXT . update ( key = key , initializing = True ): module : M = module . map ( lambda initializer : ( initializer ( next_key ()) if isinstance ( initializer , types . Initializer ) else initializer ), is_leaf = lambda x : isinstance ( x , types . Initializer ), inplace = True , ) def call_rng_init ( module : Module ): if isinstance ( module , Module ) and not module . _initialized : module . rng_init () module = to . apply ( call_rng_init , module , inplace = True ) if inputs is not to . MISSING : inputs = types . Inputs . from_value ( inputs ) method = getattr ( module , call_method ) method ( * inputs . args , ** inputs . kwargs ) if _set_initialize : def set_initialized ( module : Module ): if isinstance ( module , Module ) and not module . _initialized : module . _initialized = True module = to . apply ( set_initialized , module , inplace = True ) return module logs ( self , * filters ) inherited Returns a copy of the Module with only tx.Log TreeParts, alias for filter(tx.Log) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/flatten.py def logs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Log TreeParts, alias for `filter(tx.Log)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . Log , * filters ) loss_logs ( self , * filters ) inherited Returns a copy of the Module with only tx.Loss TreeParts, alias for filter(tx.Loss) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/flatten.py def loss_logs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Loss TreeParts, alias for `filter(tx.Loss)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . LossLog , * filters ) map ( self , f , * filters , * , inplace = False , flatten_mode = None , is_leaf = None ) inherited map is a wrapper over treeo.map that passes self as the second argument. Parameters: Name Type Description Default f Callable The function to apply to the leaves. required *filters Filter The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treex/nn/flatten.py def map ( self : A , f : tp . Callable , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , is_leaf : tp . Callable [[ tp . Any ], bool ] = None , ) -> A : \"\"\" `map` is a wrapper over `treeo.map` that passes `self` as the second argument. Arguments: f: The function to apply to the leaves. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" return api . map ( f , self , * filters , inplace = inplace , flatten_mode = flatten_mode , is_leaf = is_leaf , ) merge ( self , other , * rest , * , inplace = False , flatten_mode = None , ignore_static = False ) inherited merge is a wrapper over treeo.merge that passes self as the first argument. Parameters: Name Type Description Default other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the merged values. If inplace is True , obj is returned. Source code in treex/nn/flatten.py def merge ( self : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" `merge` is a wrapper over `treeo.merge` that passes `self` as the first argument. Arguments: other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the merged values. If `inplace` is `True`, `obj` is returned. \"\"\" return api . merge ( self , other , * rest , inplace = inplace , flatten_mode = flatten_mode , ignore_static = ignore_static , ) metric_logs ( self , * filters ) inherited Returns a copy of the Module with only tx.Metric TreeParts, alias for filter(tx.Metric) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/flatten.py def metric_logs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Metric TreeParts, alias for `filter(tx.Metric)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . MetricLog , * filters ) model_states ( self , * filters ) inherited Returns a copy of the Module with only tx.ModelState TreeParts, alias for filter(tx.ModelState) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/flatten.py def model_states ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.ModelState TreeParts, alias for `filter(tx.ModelState)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . ModelState , * filters ) parameters ( self , * filters ) inherited Returns a copy of the Module with only tx.Parameter TreeParts, alias for filter(tx.Parameter) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/flatten.py def parameters ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Parameter TreeParts, alias for `filter(tx.Parameter)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . Parameter , * filters ) rngs ( self , * filters ) inherited Returns a copy of the Module with only tx.Rng TreeParts, alias for filter(tx.Rng) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/flatten.py def rngs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Rng TreeParts, alias for `filter(tx.Rng)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . Rng , * filters ) states ( self , * filters ) inherited Returns a copy of the Module with only tx.State TreeParts, alias for filter(tx.State) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/flatten.py def states ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.State TreeParts, alias for `filter(tx.State)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . State , * filters ) tabulate ( self , inputs =< treeo . types . Missing object at 0x7f29ce5c9220 > , depth =- 1 , signature = False , param_types = True ) inherited Returns a tabular representation of the module. Parameters: Name Type Description Default depth int The maximum depth of the representation in terms of nested Modules, -1 means no limit. -1 signature bool Whether to show the signature of the Module. False param_types bool Whether to show the types of the parameters. True Returns: Type Description str A string containing the tabular representation. Source code in treex/nn/flatten.py def tabulate ( self , inputs : tp . Union [ types . InputLike , to . Missing ] = to . MISSING , depth : int = - 1 , signature : bool = False , param_types : bool = True , ) -> str : \"\"\" Returns a tabular representation of the module. Arguments: depth: The maximum depth of the representation in terms of nested Modules, -1 means no limit. signature: Whether to show the signature of the Module. param_types: Whether to show the types of the parameters. Returns: A string containing the tabular representation. \"\"\" self = to . copy ( self ) if inputs is not to . MISSING : inputs = types . Inputs . from_value ( inputs ) if not isinstance ( self , tp . Callable ): raise TypeError ( \"`inputs` can only be specified if the module is a callable.\" ) with contexts . _Context ( call_info = {}): # call using self to preserve references def eval_call ( args , kwargs ): assert isinstance ( self , tp . Callable ) return self ( * args , ** kwargs ) jax . eval_shape ( eval_call , inputs . args , inputs . kwargs , ) call_info = contexts . _CONTEXT . call_info else : call_info = None with to . add_field_info (): flat : tp . List [ to . FieldInfo ] flat , _ = jax . tree_flatten ( self ) tree_part_types : tp . Tuple [ tp . Type [ types . TreePart ], ... ] = tuple ( { field_info . kind for field_info in flat if utils . _generic_issubclass ( field_info . kind , types . TreePart ) } ) path = () rows = list ( utils . _get_tabulate_rows ( path , self , depth , tree_part_types , signature , param_types ) ) modules = [ row [ 0 ] for row in rows ] rows = [ row [ 1 :] for row in rows ] if call_info is not None : for module , row in zip ( modules , rows ): if module in call_info : inputs , outputs = call_info [ module ] simplified_inputs = ( inputs . args [ 0 ] if len ( inputs . kwargs ) == 0 and len ( inputs . args ) == 1 else inputs . kwargs if len ( inputs . kwargs ) == 0 else inputs . kwargs if len ( inputs . args ) == 0 else ( inputs . args , inputs . kwargs ) ) inputs_repr = utils . _format_param_tree ( simplified_inputs ) outputs_repr = utils . _format_param_tree ( outputs ) else : inputs_repr = \"\" outputs_repr = \"\" row . insert ( 3 , outputs_repr ) row . insert ( 3 , inputs_repr ) n_non_treepart_cols = 2 if call_info is None else 4 rows [ 0 ][ 0 ] = \"*\" rows . append ( [ \"\" ] * n_non_treepart_cols + [ \"Total:\" ] + [ utils . _format_obj_size ( self . filter ( kind ), add_padding = True ) for kind in tree_part_types ] ) utils . _add_padding ( rows ) table = Table ( show_header = True , show_lines = True , show_footer = True , # box=rich.box.HORIZONTALS, ) table . add_column ( \"path\" ) table . add_column ( \"module\" ) table . add_column ( \"params\" ) if call_info is not None : table . add_column ( \"inputs\" ) table . add_column ( \"outputs\" ) for tree_part_type in tree_part_types : type_name = tree_part_type . __name__ if type_name . startswith ( \"_\" ): type_name = type_name [ 1 :] table . add_column ( type_name ) for row in rows [: - 1 ]: table . add_row ( * row ) table . columns [ n_non_treepart_cols ] . footer = Text . from_markup ( rows [ - 1 ][ n_non_treepart_cols ], justify = \"right\" ) for i in range ( len ( tree_part_types )): table . columns [ n_non_treepart_cols + 1 + i ] . footer = rows [ - 1 ][ n_non_treepart_cols + 1 + i ] table . caption_style = \"bold\" table . caption = \" \\n Total Parameters: \" + utils . _format_obj_size ( self , add_padding = False ) return utils . _get_rich_repr ( table ) to_dict ( self , * , private_fields = False , static_fields = True , type_info = False , field_info = False ) inherited to_dict is a wrapper over treeo.to_dict that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True type_info bool If True , type information is included. False field_info bool If True , field information is included. False Returns: Type Description Any A dict representation of the object. Source code in treex/nn/flatten.py def to_dict ( self , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : \"\"\" `to_dict` is a wrapper over `treeo.to_dict` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. type_info: If `True`, type information is included. field_info: If `True`, field information is included. Returns: A dict representation of the object. \"\"\" return api . to_dict ( self , private_fields = private_fields , static_fields = static_fields , type_info = type_info , field_info = field_info , ) to_string ( self , * , private_fields = False , static_fields = True , color = False ) inherited to_string is a wrapper over treeo.to_string that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True color bool If True , color is included. False Returns: Type Description str A string representation of the object. Source code in treex/nn/flatten.py def to_string ( self : A , * , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" `to_string` is a wrapper over `treeo.to_string` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. color: If `True`, color is included. Returns: A string representation of the object. \"\"\" return api . to_string ( self , private_fields = private_fields , static_fields = static_fields , color = color , ) train ( self , mode = True , inplace = False ) inherited Creates a new module with the same structure, but with Module.training set to the given value. Parameters: Name Type Description Default mode bool The new training mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module in with the training mode is set to the given value, if inplace is True then self is returned. Source code in treex/nn/flatten.py def train ( self : T , mode : bool = True , inplace : bool = False ) -> T : \"\"\" Creates a new module with the same structure, but with `Module.training` set to the given value. Arguments: mode: The new training mode. inplace: Whether to update the module inplace. Returns: The new module in with the training mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_training ( tree ): if isinstance ( tree , Treex ) and hasattr ( tree , \"_training\" ): tree . _training = mode return to . apply ( set_training , self , inplace = inplace ) unfreeze ( self , inplace = False ) inherited Creates a new module with .frozen set to False, equivalent to calling freeze(False) . Parameters: Name Type Description Default inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module with .frozen set to False, if inplace is True then self is returned. Source code in treex/nn/flatten.py def unfreeze ( self : T , inplace : bool = False ) -> T : \"\"\" Creates a new module with `.frozen` set to False, equivalent to calling `freeze(False)`. Arguments: inplace: Whether to update the module inplace. Returns: The new module with `.frozen` set to False, if `inplace` is `True` then `self` is returned. \"\"\" return self . freeze ( False , inplace = inplace )","title":"Flatten"},{"location":"api/Flatten/#treexflatten","text":"","title":"treex.Flatten"},{"location":"api/Flatten/#treex.nn.flatten.Flatten.first_run","text":"Returns: Type Description bool True if its currently the first run of a compact method.","title":"first_run"},{"location":"api/Flatten/#treex.nn.flatten.Flatten.__class__","text":"","title":"__class__"},{"location":"api/Flatten/#treex.nn.flatten.Flatten.__class__.__base__","text":"","title":"__base__"},{"location":"api/Flatten/#treex.nn.flatten.Flatten.__class__.__base__.__base__","text":"Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()).","title":"__base__"},{"location":"api/Flatten/#treex.nn.flatten.Flatten.__class__.__base__.__base__.__instancecheck__","text":"Override for isinstance(instance, cls). Source code in treex/nn/flatten.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance )","title":"__instancecheck__()"},{"location":"api/Flatten/#treex.nn.flatten.Flatten.__class__.__base__.__base__.__new__","text":"Create and return a new object. See help(type) for accurate signature. Source code in treex/nn/flatten.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls","title":"__new__()"},{"location":"api/Flatten/#treex.nn.flatten.Flatten.__class__.__base__.__base__.__subclasscheck__","text":"Override for issubclass(subclass, cls). Source code in treex/nn/flatten.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass )","title":"__subclasscheck__()"},{"location":"api/Flatten/#treex.nn.flatten.Flatten.__class__.__base__.__base__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/flatten.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/Flatten/#treex.nn.flatten.Flatten.__class__.__base__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/flatten.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/Flatten/#treex.nn.flatten.Flatten.__class__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/flatten.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/Flatten/#treex.nn.flatten.Flatten.apply","text":"apply is a wrapper over treeo.apply that passes self as the second argument. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treex/nn/flatten.py def apply ( self : A , f : tp . Callable [ ... , None ], * rest : A , inplace : bool = False ) -> A : \"\"\" `apply` is a wrapper over `treeo.apply` that passes `self` as the second argument. Arguments: f: The function to apply. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" return api . apply ( f , self , * rest , inplace = inplace )","title":"apply()"},{"location":"api/Flatten/#treex.nn.flatten.Flatten.batch_stats","text":"Returns a copy of the Module with only tx.BatchStat TreeParts, alias for filter(tx.BatchStat) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/flatten.py def batch_stats ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.BatchStat TreeParts, alias for `filter(tx.BatchStat)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . BatchStat , * filters )","title":"batch_stats()"},{"location":"api/Flatten/#treex.nn.flatten.Flatten.check_metadata_updates","text":"Checks for new fields, if found, adds them to the metadata. Source code in treex/nn/flatten.py def check_metadata_updates ( self ): \"\"\" Checks for new fields, if found, adds them to the metadata. \"\"\" with _CONTEXT . update ( flatten_mode = FlattenMode . all_fields ): jax . tree_flatten ( self )","title":"check_metadata_updates()"},{"location":"api/Flatten/#treex.nn.flatten.Flatten.copy","text":"copy is a wrapper over treeo.copy that passes self as the first argument. Source code in treex/nn/flatten.py def copy ( self : A ) -> A : \"\"\" `copy` is a wrapper over `treeo.copy` that passes `self` as the first argument. \"\"\" return tree_m . copy ( self )","title":"copy()"},{"location":"api/Flatten/#treex.nn.flatten.Flatten.eval","text":"Creates a new module with the training mode set to False, equivalent to calling train(False) . Returns: Type Description ~T The new module with the training mode set to False. Source code in treex/nn/flatten.py def eval ( self : T , inplace : bool = False ) -> T : \"\"\" Creates a new module with the training mode set to False, equivalent to calling `train(False)`. Returns: The new module with the training mode set to False. \"\"\" return self . train ( False , inplace = inplace )","title":"eval()"},{"location":"api/Flatten/#treex.nn.flatten.Flatten.filter","text":"filter is a wrapper over treeo.filter that passes self as the first argument. Parameters: Name Type Description Default *filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treex/nn/flatten.py def filter ( self : A , * filters : api . Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ) -> A : \"\"\" `filter` is a wrapper over `treeo.filter` that passes `self` as the first argument. Arguments: *filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" return api . filter ( self , * filters , inplace = inplace , flatten_mode = flatten_mode )","title":"filter()"},{"location":"api/Flatten/#treex.nn.flatten.Flatten.freeze","text":"Creates a new module with the same structure, but with Module.frozen set to the given value. Parameters: Name Type Description Default mode bool The new frozen mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module in with the frozen mode is set to the given value, if inplace is True then self is returned. Source code in treex/nn/flatten.py def freeze ( self : T , mode : bool = True , inplace : bool = False ) -> T : \"\"\" Creates a new module with the same structure, but with `Module.frozen` set to the given value. Arguments: mode: The new `frozen` mode. inplace: Whether to update the module inplace. Returns: The new module in with the `frozen` mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_frozen ( tree ): if isinstance ( tree , Treex ) and hasattr ( tree , \"_frozen\" ): tree . _frozen = mode return to . apply ( set_frozen , self , inplace = inplace )","title":"freeze()"},{"location":"api/Flatten/#treex.nn.flatten.Flatten.get_field","text":"A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: The field must be declared in the class definition. The method can only be called inside a compact context. Parameters: Name Type Description Default field_name str The name of the field to get. required initializer Callable[[], ~A] The function to initialize the field if it does not exist. required Returns: Type Description ~A The field value. Source code in treex/nn/flatten.py def get_field ( self , field_name : str , initializer : tp . Callable [[], A ], ) -> A : \"\"\" A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: * The field must be declared in the class definition. * The method can only be called inside a `compact` context. Arguments: field_name: The name of the field to get. initializer: The function to initialize the field if it does not exist. Returns: The field value. \"\"\" value : A if field_name not in self . _field_metadata : raise ValueError ( f \"Metadata for field ' { field_name } ' does not exist.\" ) if field_name in vars ( self ): value = getattr ( self , field_name ) else : if tree_m . _COMPACT_CONTEXT . in_compact and not self . first_run : raise RuntimeError ( f \"Trying to initialize field ' { field_name } ' after the first run of `compact`.\" ) value = initializer () setattr ( self , field_name , value ) return value","title":"get_field()"},{"location":"api/Flatten/#treex.nn.flatten.Flatten.init","text":"Method version of tx.init , it applies self as first argument. init creates a new module with the same structure, but with its fields initialized given a seed key . The following procedure is used: The input key is split and iteratively updated before passing a derived value to any process that requires initialization. Initializer s are called and applied to the module first. Module.rng_init methods are called last. Parameters: Name Type Description Default key Union[int, jax._src.numpy.lax_numpy.ndarray] The seed to use for initialization. required Returns: Type Description ~M The new module with the fields initialized. Source code in treex/nn/flatten.py def init ( self : M , key : tp . Union [ int , jnp . ndarray ], inputs : types . InputLike = to . MISSING , call_method : str = \"__call__\" , * , inplace : bool = False , _set_initialize : bool = True , ) -> M : \"\"\" Method version of `tx.init`, it applies `self` as first argument. `init` creates a new module with the same structure, but with its fields initialized given a seed `key`. The following procedure is used: 1. The input `key` is split and iteratively updated before passing a derived value to any process that requires initialization. 2. `Initializer`s are called and applied to the module first. 3. `Module.rng_init` methods are called last. Arguments: key: The seed to use for initialization. Returns: The new module with the fields initialized. \"\"\" module = self . copy () if not inplace else self key = utils . Key ( key ) with _INIT_CONTEXT . update ( key = key , initializing = True ): module : M = module . map ( lambda initializer : ( initializer ( next_key ()) if isinstance ( initializer , types . Initializer ) else initializer ), is_leaf = lambda x : isinstance ( x , types . Initializer ), inplace = True , ) def call_rng_init ( module : Module ): if isinstance ( module , Module ) and not module . _initialized : module . rng_init () module = to . apply ( call_rng_init , module , inplace = True ) if inputs is not to . MISSING : inputs = types . Inputs . from_value ( inputs ) method = getattr ( module , call_method ) method ( * inputs . args , ** inputs . kwargs ) if _set_initialize : def set_initialized ( module : Module ): if isinstance ( module , Module ) and not module . _initialized : module . _initialized = True module = to . apply ( set_initialized , module , inplace = True ) return module","title":"init()"},{"location":"api/Flatten/#treex.nn.flatten.Flatten.logs","text":"Returns a copy of the Module with only tx.Log TreeParts, alias for filter(tx.Log) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/flatten.py def logs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Log TreeParts, alias for `filter(tx.Log)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . Log , * filters )","title":"logs()"},{"location":"api/Flatten/#treex.nn.flatten.Flatten.loss_logs","text":"Returns a copy of the Module with only tx.Loss TreeParts, alias for filter(tx.Loss) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/flatten.py def loss_logs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Loss TreeParts, alias for `filter(tx.Loss)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . LossLog , * filters )","title":"loss_logs()"},{"location":"api/Flatten/#treex.nn.flatten.Flatten.map","text":"map is a wrapper over treeo.map that passes self as the second argument. Parameters: Name Type Description Default f Callable The function to apply to the leaves. required *filters Filter The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treex/nn/flatten.py def map ( self : A , f : tp . Callable , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , is_leaf : tp . Callable [[ tp . Any ], bool ] = None , ) -> A : \"\"\" `map` is a wrapper over `treeo.map` that passes `self` as the second argument. Arguments: f: The function to apply to the leaves. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" return api . map ( f , self , * filters , inplace = inplace , flatten_mode = flatten_mode , is_leaf = is_leaf , )","title":"map()"},{"location":"api/Flatten/#treex.nn.flatten.Flatten.merge","text":"merge is a wrapper over treeo.merge that passes self as the first argument. Parameters: Name Type Description Default other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the merged values. If inplace is True , obj is returned. Source code in treex/nn/flatten.py def merge ( self : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" `merge` is a wrapper over `treeo.merge` that passes `self` as the first argument. Arguments: other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the merged values. If `inplace` is `True`, `obj` is returned. \"\"\" return api . merge ( self , other , * rest , inplace = inplace , flatten_mode = flatten_mode , ignore_static = ignore_static , )","title":"merge()"},{"location":"api/Flatten/#treex.nn.flatten.Flatten.metric_logs","text":"Returns a copy of the Module with only tx.Metric TreeParts, alias for filter(tx.Metric) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/flatten.py def metric_logs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Metric TreeParts, alias for `filter(tx.Metric)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . MetricLog , * filters )","title":"metric_logs()"},{"location":"api/Flatten/#treex.nn.flatten.Flatten.model_states","text":"Returns a copy of the Module with only tx.ModelState TreeParts, alias for filter(tx.ModelState) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/flatten.py def model_states ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.ModelState TreeParts, alias for `filter(tx.ModelState)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . ModelState , * filters )","title":"model_states()"},{"location":"api/Flatten/#treex.nn.flatten.Flatten.parameters","text":"Returns a copy of the Module with only tx.Parameter TreeParts, alias for filter(tx.Parameter) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/flatten.py def parameters ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Parameter TreeParts, alias for `filter(tx.Parameter)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . Parameter , * filters )","title":"parameters()"},{"location":"api/Flatten/#treex.nn.flatten.Flatten.rngs","text":"Returns a copy of the Module with only tx.Rng TreeParts, alias for filter(tx.Rng) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/flatten.py def rngs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Rng TreeParts, alias for `filter(tx.Rng)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . Rng , * filters )","title":"rngs()"},{"location":"api/Flatten/#treex.nn.flatten.Flatten.states","text":"Returns a copy of the Module with only tx.State TreeParts, alias for filter(tx.State) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/flatten.py def states ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.State TreeParts, alias for `filter(tx.State)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . State , * filters )","title":"states()"},{"location":"api/Flatten/#treex.nn.flatten.Flatten.tabulate","text":"Returns a tabular representation of the module. Parameters: Name Type Description Default depth int The maximum depth of the representation in terms of nested Modules, -1 means no limit. -1 signature bool Whether to show the signature of the Module. False param_types bool Whether to show the types of the parameters. True Returns: Type Description str A string containing the tabular representation. Source code in treex/nn/flatten.py def tabulate ( self , inputs : tp . Union [ types . InputLike , to . Missing ] = to . MISSING , depth : int = - 1 , signature : bool = False , param_types : bool = True , ) -> str : \"\"\" Returns a tabular representation of the module. Arguments: depth: The maximum depth of the representation in terms of nested Modules, -1 means no limit. signature: Whether to show the signature of the Module. param_types: Whether to show the types of the parameters. Returns: A string containing the tabular representation. \"\"\" self = to . copy ( self ) if inputs is not to . MISSING : inputs = types . Inputs . from_value ( inputs ) if not isinstance ( self , tp . Callable ): raise TypeError ( \"`inputs` can only be specified if the module is a callable.\" ) with contexts . _Context ( call_info = {}): # call using self to preserve references def eval_call ( args , kwargs ): assert isinstance ( self , tp . Callable ) return self ( * args , ** kwargs ) jax . eval_shape ( eval_call , inputs . args , inputs . kwargs , ) call_info = contexts . _CONTEXT . call_info else : call_info = None with to . add_field_info (): flat : tp . List [ to . FieldInfo ] flat , _ = jax . tree_flatten ( self ) tree_part_types : tp . Tuple [ tp . Type [ types . TreePart ], ... ] = tuple ( { field_info . kind for field_info in flat if utils . _generic_issubclass ( field_info . kind , types . TreePart ) } ) path = () rows = list ( utils . _get_tabulate_rows ( path , self , depth , tree_part_types , signature , param_types ) ) modules = [ row [ 0 ] for row in rows ] rows = [ row [ 1 :] for row in rows ] if call_info is not None : for module , row in zip ( modules , rows ): if module in call_info : inputs , outputs = call_info [ module ] simplified_inputs = ( inputs . args [ 0 ] if len ( inputs . kwargs ) == 0 and len ( inputs . args ) == 1 else inputs . kwargs if len ( inputs . kwargs ) == 0 else inputs . kwargs if len ( inputs . args ) == 0 else ( inputs . args , inputs . kwargs ) ) inputs_repr = utils . _format_param_tree ( simplified_inputs ) outputs_repr = utils . _format_param_tree ( outputs ) else : inputs_repr = \"\" outputs_repr = \"\" row . insert ( 3 , outputs_repr ) row . insert ( 3 , inputs_repr ) n_non_treepart_cols = 2 if call_info is None else 4 rows [ 0 ][ 0 ] = \"*\" rows . append ( [ \"\" ] * n_non_treepart_cols + [ \"Total:\" ] + [ utils . _format_obj_size ( self . filter ( kind ), add_padding = True ) for kind in tree_part_types ] ) utils . _add_padding ( rows ) table = Table ( show_header = True , show_lines = True , show_footer = True , # box=rich.box.HORIZONTALS, ) table . add_column ( \"path\" ) table . add_column ( \"module\" ) table . add_column ( \"params\" ) if call_info is not None : table . add_column ( \"inputs\" ) table . add_column ( \"outputs\" ) for tree_part_type in tree_part_types : type_name = tree_part_type . __name__ if type_name . startswith ( \"_\" ): type_name = type_name [ 1 :] table . add_column ( type_name ) for row in rows [: - 1 ]: table . add_row ( * row ) table . columns [ n_non_treepart_cols ] . footer = Text . from_markup ( rows [ - 1 ][ n_non_treepart_cols ], justify = \"right\" ) for i in range ( len ( tree_part_types )): table . columns [ n_non_treepart_cols + 1 + i ] . footer = rows [ - 1 ][ n_non_treepart_cols + 1 + i ] table . caption_style = \"bold\" table . caption = \" \\n Total Parameters: \" + utils . _format_obj_size ( self , add_padding = False ) return utils . _get_rich_repr ( table )","title":"tabulate()"},{"location":"api/Flatten/#treex.nn.flatten.Flatten.to_dict","text":"to_dict is a wrapper over treeo.to_dict that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True type_info bool If True , type information is included. False field_info bool If True , field information is included. False Returns: Type Description Any A dict representation of the object. Source code in treex/nn/flatten.py def to_dict ( self , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : \"\"\" `to_dict` is a wrapper over `treeo.to_dict` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. type_info: If `True`, type information is included. field_info: If `True`, field information is included. Returns: A dict representation of the object. \"\"\" return api . to_dict ( self , private_fields = private_fields , static_fields = static_fields , type_info = type_info , field_info = field_info , )","title":"to_dict()"},{"location":"api/Flatten/#treex.nn.flatten.Flatten.to_string","text":"to_string is a wrapper over treeo.to_string that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True color bool If True , color is included. False Returns: Type Description str A string representation of the object. Source code in treex/nn/flatten.py def to_string ( self : A , * , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" `to_string` is a wrapper over `treeo.to_string` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. color: If `True`, color is included. Returns: A string representation of the object. \"\"\" return api . to_string ( self , private_fields = private_fields , static_fields = static_fields , color = color , )","title":"to_string()"},{"location":"api/Flatten/#treex.nn.flatten.Flatten.train","text":"Creates a new module with the same structure, but with Module.training set to the given value. Parameters: Name Type Description Default mode bool The new training mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module in with the training mode is set to the given value, if inplace is True then self is returned. Source code in treex/nn/flatten.py def train ( self : T , mode : bool = True , inplace : bool = False ) -> T : \"\"\" Creates a new module with the same structure, but with `Module.training` set to the given value. Arguments: mode: The new training mode. inplace: Whether to update the module inplace. Returns: The new module in with the training mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_training ( tree ): if isinstance ( tree , Treex ) and hasattr ( tree , \"_training\" ): tree . _training = mode return to . apply ( set_training , self , inplace = inplace )","title":"train()"},{"location":"api/Flatten/#treex.nn.flatten.Flatten.unfreeze","text":"Creates a new module with .frozen set to False, equivalent to calling freeze(False) . Parameters: Name Type Description Default inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module with .frozen set to False, if inplace is True then self is returned. Source code in treex/nn/flatten.py def unfreeze ( self : T , inplace : bool = False ) -> T : \"\"\" Creates a new module with `.frozen` set to False, equivalent to calling `freeze(False)`. Arguments: inplace: Whether to update the module inplace. Returns: The new module with `.frozen` set to False, if `inplace` is `True` then `self` is returned. \"\"\" return self . freeze ( False , inplace = inplace )","title":"unfreeze()"},{"location":"api/FlaxModule/","text":"treex.FlaxModule first_run : bool inherited property readonly Returns: Type Description bool True if its currently the first run of a compact method. __class__ inherited __base__ inherited __base__ inherited Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()). __instancecheck__ ( cls , instance ) special Override for isinstance(instance, cls). Source code in treex/nn/flax_module.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance ) __new__ ( mcls , name , bases , namespace , ** kwargs ) special staticmethod Create and return a new object. See help(type) for accurate signature. Source code in treex/nn/flax_module.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls __subclasscheck__ ( cls , subclass ) special Override for issubclass(subclass, cls). Source code in treex/nn/flax_module.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass ) register ( cls , subclass ) Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/flax_module.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) register ( cls , subclass ) inherited Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/flax_module.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) register ( cls , subclass ) inherited Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/flax_module.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) apply ( self , f , * rest , * , inplace = False ) inherited apply is a wrapper over treeo.apply that passes self as the second argument. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treex/nn/flax_module.py def apply ( self : A , f : tp . Callable [ ... , None ], * rest : A , inplace : bool = False ) -> A : \"\"\" `apply` is a wrapper over `treeo.apply` that passes `self` as the second argument. Arguments: f: The function to apply. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" return api . apply ( f , self , * rest , inplace = inplace ) check_metadata_updates ( self ) inherited Checks for new fields, if found, adds them to the metadata. Source code in treex/nn/flax_module.py def check_metadata_updates ( self ): \"\"\" Checks for new fields, if found, adds them to the metadata. \"\"\" with _CONTEXT . update ( flatten_mode = FlattenMode . all_fields ): jax . tree_flatten ( self ) copy ( self ) inherited copy is a wrapper over treeo.copy that passes self as the first argument. Source code in treex/nn/flax_module.py def copy ( self : A ) -> A : \"\"\" `copy` is a wrapper over `treeo.copy` that passes `self` as the first argument. \"\"\" return tree_m . copy ( self ) eval ( self , inplace = False ) inherited Creates a new module with the training mode set to False, equivalent to calling train(False) . Returns: Type Description ~T The new module with the training mode set to False. Source code in treex/nn/flax_module.py def eval ( self : T , inplace : bool = False ) -> T : \"\"\" Creates a new module with the training mode set to False, equivalent to calling `train(False)`. Returns: The new module with the training mode set to False. \"\"\" return self . train ( False , inplace = inplace ) filter ( self , * filters , * , inplace = False , flatten_mode = None ) inherited filter is a wrapper over treeo.filter that passes self as the first argument. Parameters: Name Type Description Default *filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treex/nn/flax_module.py def filter ( self : A , * filters : api . Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ) -> A : \"\"\" `filter` is a wrapper over `treeo.filter` that passes `self` as the first argument. Arguments: *filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" return api . filter ( self , * filters , inplace = inplace , flatten_mode = flatten_mode ) freeze ( self , mode = True , inplace = False ) inherited Creates a new module with the same structure, but with Module.frozen set to the given value. Parameters: Name Type Description Default mode bool The new frozen mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module in with the frozen mode is set to the given value, if inplace is True then self is returned. Source code in treex/nn/flax_module.py def freeze ( self : T , mode : bool = True , inplace : bool = False ) -> T : \"\"\" Creates a new module with the same structure, but with `Module.frozen` set to the given value. Arguments: mode: The new `frozen` mode. inplace: Whether to update the module inplace. Returns: The new module in with the `frozen` mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_frozen ( tree ): if isinstance ( tree , Treex ) and hasattr ( tree , \"_frozen\" ): tree . _frozen = mode return to . apply ( set_frozen , self , inplace = inplace ) get_field ( self , field_name , initializer ) inherited A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: The field must be declared in the class definition. The method can only be called inside a compact context. Parameters: Name Type Description Default field_name str The name of the field to get. required initializer Callable[[], ~A] The function to initialize the field if it does not exist. required Returns: Type Description ~A The field value. Source code in treex/nn/flax_module.py def get_field ( self , field_name : str , initializer : tp . Callable [[], A ], ) -> A : \"\"\" A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: * The field must be declared in the class definition. * The method can only be called inside a `compact` context. Arguments: field_name: The name of the field to get. initializer: The function to initialize the field if it does not exist. Returns: The field value. \"\"\" value : A if field_name not in self . _field_metadata : raise ValueError ( f \"Metadata for field ' { field_name } ' does not exist.\" ) if field_name in vars ( self ): value = getattr ( self , field_name ) else : if tree_m . _COMPACT_CONTEXT . in_compact and not self . first_run : raise RuntimeError ( f \"Trying to initialize field ' { field_name } ' after the first run of `compact`.\" ) value = initializer () setattr ( self , field_name , value ) return value init ( self , key , inputs =< treeo . types . Missing object at 0x7f29ce5c9220 > , call_method = '__call__' , * , inplace = False , _set_initialize = True ) inherited Method version of tx.init , it applies self as first argument. init creates a new module with the same structure, but with its fields initialized given a seed key . The following procedure is used: The input key is split and iteratively updated before passing a derived value to any process that requires initialization. Initializer s are called and applied to the module first. Module.rng_init methods are called last. Parameters: Name Type Description Default key Union[int, jax._src.numpy.lax_numpy.ndarray] The seed to use for initialization. required Returns: Type Description ~M The new module with the fields initialized. Source code in treex/nn/flax_module.py def init ( self : M , key : tp . Union [ int , jnp . ndarray ], inputs : types . InputLike = to . MISSING , call_method : str = \"__call__\" , * , inplace : bool = False , _set_initialize : bool = True , ) -> M : \"\"\" Method version of `tx.init`, it applies `self` as first argument. `init` creates a new module with the same structure, but with its fields initialized given a seed `key`. The following procedure is used: 1. The input `key` is split and iteratively updated before passing a derived value to any process that requires initialization. 2. `Initializer`s are called and applied to the module first. 3. `Module.rng_init` methods are called last. Arguments: key: The seed to use for initialization. Returns: The new module with the fields initialized. \"\"\" module = self . copy () if not inplace else self key = utils . Key ( key ) with _INIT_CONTEXT . update ( key = key , initializing = True ): module : M = module . map ( lambda initializer : ( initializer ( next_key ()) if isinstance ( initializer , types . Initializer ) else initializer ), is_leaf = lambda x : isinstance ( x , types . Initializer ), inplace = True , ) def call_rng_init ( module : Module ): if isinstance ( module , Module ) and not module . _initialized : module . rng_init () module = to . apply ( call_rng_init , module , inplace = True ) if inputs is not to . MISSING : inputs = types . Inputs . from_value ( inputs ) method = getattr ( module , call_method ) method ( * inputs . args , ** inputs . kwargs ) if _set_initialize : def set_initialized ( module : Module ): if isinstance ( module , Module ) and not module . _initialized : module . _initialized = True module = to . apply ( set_initialized , module , inplace = True ) return module logs ( self , * filters ) inherited Returns a copy of the Module with only tx.Log TreeParts, alias for filter(tx.Log) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/flax_module.py def logs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Log TreeParts, alias for `filter(tx.Log)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . Log , * filters ) loss_logs ( self , * filters ) inherited Returns a copy of the Module with only tx.Loss TreeParts, alias for filter(tx.Loss) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/flax_module.py def loss_logs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Loss TreeParts, alias for `filter(tx.Loss)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . LossLog , * filters ) map ( self , f , * filters , * , inplace = False , flatten_mode = None , is_leaf = None ) inherited map is a wrapper over treeo.map that passes self as the second argument. Parameters: Name Type Description Default f Callable The function to apply to the leaves. required *filters Filter The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treex/nn/flax_module.py def map ( self : A , f : tp . Callable , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , is_leaf : tp . Callable [[ tp . Any ], bool ] = None , ) -> A : \"\"\" `map` is a wrapper over `treeo.map` that passes `self` as the second argument. Arguments: f: The function to apply to the leaves. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" return api . map ( f , self , * filters , inplace = inplace , flatten_mode = flatten_mode , is_leaf = is_leaf , ) merge ( self , other , * rest , * , inplace = False , flatten_mode = None , ignore_static = False ) inherited merge is a wrapper over treeo.merge that passes self as the first argument. Parameters: Name Type Description Default other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the merged values. If inplace is True , obj is returned. Source code in treex/nn/flax_module.py def merge ( self : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" `merge` is a wrapper over `treeo.merge` that passes `self` as the first argument. Arguments: other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the merged values. If `inplace` is `True`, `obj` is returned. \"\"\" return api . merge ( self , other , * rest , inplace = inplace , flatten_mode = flatten_mode , ignore_static = ignore_static , ) metric_logs ( self , * filters ) inherited Returns a copy of the Module with only tx.Metric TreeParts, alias for filter(tx.Metric) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/flax_module.py def metric_logs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Metric TreeParts, alias for `filter(tx.Metric)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . MetricLog , * filters ) model_states ( self , * filters ) inherited Returns a copy of the Module with only tx.ModelState TreeParts, alias for filter(tx.ModelState) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/flax_module.py def model_states ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.ModelState TreeParts, alias for `filter(tx.ModelState)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . ModelState , * filters ) parameters ( self , * filters ) inherited Returns a copy of the Module with only tx.Parameter TreeParts, alias for filter(tx.Parameter) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/flax_module.py def parameters ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Parameter TreeParts, alias for `filter(tx.Parameter)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . Parameter , * filters ) rngs ( self , * filters ) inherited Returns a copy of the Module with only tx.Rng TreeParts, alias for filter(tx.Rng) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/flax_module.py def rngs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Rng TreeParts, alias for `filter(tx.Rng)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . Rng , * filters ) states ( self , * filters ) inherited Returns a copy of the Module with only tx.State TreeParts, alias for filter(tx.State) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/flax_module.py def states ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.State TreeParts, alias for `filter(tx.State)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . State , * filters ) tabulate ( self , inputs =< treeo . types . Missing object at 0x7f29ce5c9220 > , depth =- 1 , signature = False , param_types = True ) inherited Returns a tabular representation of the module. Parameters: Name Type Description Default depth int The maximum depth of the representation in terms of nested Modules, -1 means no limit. -1 signature bool Whether to show the signature of the Module. False param_types bool Whether to show the types of the parameters. True Returns: Type Description str A string containing the tabular representation. Source code in treex/nn/flax_module.py def tabulate ( self , inputs : tp . Union [ types . InputLike , to . Missing ] = to . MISSING , depth : int = - 1 , signature : bool = False , param_types : bool = True , ) -> str : \"\"\" Returns a tabular representation of the module. Arguments: depth: The maximum depth of the representation in terms of nested Modules, -1 means no limit. signature: Whether to show the signature of the Module. param_types: Whether to show the types of the parameters. Returns: A string containing the tabular representation. \"\"\" self = to . copy ( self ) if inputs is not to . MISSING : inputs = types . Inputs . from_value ( inputs ) if not isinstance ( self , tp . Callable ): raise TypeError ( \"`inputs` can only be specified if the module is a callable.\" ) with contexts . _Context ( call_info = {}): # call using self to preserve references def eval_call ( args , kwargs ): assert isinstance ( self , tp . Callable ) return self ( * args , ** kwargs ) jax . eval_shape ( eval_call , inputs . args , inputs . kwargs , ) call_info = contexts . _CONTEXT . call_info else : call_info = None with to . add_field_info (): flat : tp . List [ to . FieldInfo ] flat , _ = jax . tree_flatten ( self ) tree_part_types : tp . Tuple [ tp . Type [ types . TreePart ], ... ] = tuple ( { field_info . kind for field_info in flat if utils . _generic_issubclass ( field_info . kind , types . TreePart ) } ) path = () rows = list ( utils . _get_tabulate_rows ( path , self , depth , tree_part_types , signature , param_types ) ) modules = [ row [ 0 ] for row in rows ] rows = [ row [ 1 :] for row in rows ] if call_info is not None : for module , row in zip ( modules , rows ): if module in call_info : inputs , outputs = call_info [ module ] simplified_inputs = ( inputs . args [ 0 ] if len ( inputs . kwargs ) == 0 and len ( inputs . args ) == 1 else inputs . kwargs if len ( inputs . kwargs ) == 0 else inputs . kwargs if len ( inputs . args ) == 0 else ( inputs . args , inputs . kwargs ) ) inputs_repr = utils . _format_param_tree ( simplified_inputs ) outputs_repr = utils . _format_param_tree ( outputs ) else : inputs_repr = \"\" outputs_repr = \"\" row . insert ( 3 , outputs_repr ) row . insert ( 3 , inputs_repr ) n_non_treepart_cols = 2 if call_info is None else 4 rows [ 0 ][ 0 ] = \"*\" rows . append ( [ \"\" ] * n_non_treepart_cols + [ \"Total:\" ] + [ utils . _format_obj_size ( self . filter ( kind ), add_padding = True ) for kind in tree_part_types ] ) utils . _add_padding ( rows ) table = Table ( show_header = True , show_lines = True , show_footer = True , # box=rich.box.HORIZONTALS, ) table . add_column ( \"path\" ) table . add_column ( \"module\" ) table . add_column ( \"params\" ) if call_info is not None : table . add_column ( \"inputs\" ) table . add_column ( \"outputs\" ) for tree_part_type in tree_part_types : type_name = tree_part_type . __name__ if type_name . startswith ( \"_\" ): type_name = type_name [ 1 :] table . add_column ( type_name ) for row in rows [: - 1 ]: table . add_row ( * row ) table . columns [ n_non_treepart_cols ] . footer = Text . from_markup ( rows [ - 1 ][ n_non_treepart_cols ], justify = \"right\" ) for i in range ( len ( tree_part_types )): table . columns [ n_non_treepart_cols + 1 + i ] . footer = rows [ - 1 ][ n_non_treepart_cols + 1 + i ] table . caption_style = \"bold\" table . caption = \" \\n Total Parameters: \" + utils . _format_obj_size ( self , add_padding = False ) return utils . _get_rich_repr ( table ) to_dict ( self , * , private_fields = False , static_fields = True , type_info = False , field_info = False ) inherited to_dict is a wrapper over treeo.to_dict that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True type_info bool If True , type information is included. False field_info bool If True , field information is included. False Returns: Type Description Any A dict representation of the object. Source code in treex/nn/flax_module.py def to_dict ( self , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : \"\"\" `to_dict` is a wrapper over `treeo.to_dict` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. type_info: If `True`, type information is included. field_info: If `True`, field information is included. Returns: A dict representation of the object. \"\"\" return api . to_dict ( self , private_fields = private_fields , static_fields = static_fields , type_info = type_info , field_info = field_info , ) to_string ( self , * , private_fields = False , static_fields = True , color = False ) inherited to_string is a wrapper over treeo.to_string that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True color bool If True , color is included. False Returns: Type Description str A string representation of the object. Source code in treex/nn/flax_module.py def to_string ( self : A , * , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" `to_string` is a wrapper over `treeo.to_string` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. color: If `True`, color is included. Returns: A string representation of the object. \"\"\" return api . to_string ( self , private_fields = private_fields , static_fields = static_fields , color = color , ) train ( self , mode = True , inplace = False ) inherited Creates a new module with the same structure, but with Module.training set to the given value. Parameters: Name Type Description Default mode bool The new training mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module in with the training mode is set to the given value, if inplace is True then self is returned. Source code in treex/nn/flax_module.py def train ( self : T , mode : bool = True , inplace : bool = False ) -> T : \"\"\" Creates a new module with the same structure, but with `Module.training` set to the given value. Arguments: mode: The new training mode. inplace: Whether to update the module inplace. Returns: The new module in with the training mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_training ( tree ): if isinstance ( tree , Treex ) and hasattr ( tree , \"_training\" ): tree . _training = mode return to . apply ( set_training , self , inplace = inplace ) unfreeze ( self , inplace = False ) inherited Creates a new module with .frozen set to False, equivalent to calling freeze(False) . Parameters: Name Type Description Default inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module with .frozen set to False, if inplace is True then self is returned. Source code in treex/nn/flax_module.py def unfreeze ( self : T , inplace : bool = False ) -> T : \"\"\" Creates a new module with `.frozen` set to False, equivalent to calling `freeze(False)`. Arguments: inplace: Whether to update the module inplace. Returns: The new module with `.frozen` set to False, if `inplace` is `True` then `self` is returned. \"\"\" return self . freeze ( False , inplace = inplace )","title":"FlaxModule"},{"location":"api/FlaxModule/#treexflaxmodule","text":"","title":"treex.FlaxModule"},{"location":"api/FlaxModule/#treex.nn.flax_module.FlaxModule.first_run","text":"Returns: Type Description bool True if its currently the first run of a compact method.","title":"first_run"},{"location":"api/FlaxModule/#treex.nn.flax_module.FlaxModule.__class__","text":"","title":"__class__"},{"location":"api/FlaxModule/#treex.nn.flax_module.FlaxModule.__class__.__base__","text":"","title":"__base__"},{"location":"api/FlaxModule/#treex.nn.flax_module.FlaxModule.__class__.__base__.__base__","text":"Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()).","title":"__base__"},{"location":"api/FlaxModule/#treex.nn.flax_module.FlaxModule.__class__.__base__.__base__.__instancecheck__","text":"Override for isinstance(instance, cls). Source code in treex/nn/flax_module.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance )","title":"__instancecheck__()"},{"location":"api/FlaxModule/#treex.nn.flax_module.FlaxModule.__class__.__base__.__base__.__new__","text":"Create and return a new object. See help(type) for accurate signature. Source code in treex/nn/flax_module.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls","title":"__new__()"},{"location":"api/FlaxModule/#treex.nn.flax_module.FlaxModule.__class__.__base__.__base__.__subclasscheck__","text":"Override for issubclass(subclass, cls). Source code in treex/nn/flax_module.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass )","title":"__subclasscheck__()"},{"location":"api/FlaxModule/#treex.nn.flax_module.FlaxModule.__class__.__base__.__base__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/flax_module.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/FlaxModule/#treex.nn.flax_module.FlaxModule.__class__.__base__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/flax_module.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/FlaxModule/#treex.nn.flax_module.FlaxModule.__class__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/flax_module.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/FlaxModule/#treex.nn.flax_module.FlaxModule.apply","text":"apply is a wrapper over treeo.apply that passes self as the second argument. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treex/nn/flax_module.py def apply ( self : A , f : tp . Callable [ ... , None ], * rest : A , inplace : bool = False ) -> A : \"\"\" `apply` is a wrapper over `treeo.apply` that passes `self` as the second argument. Arguments: f: The function to apply. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" return api . apply ( f , self , * rest , inplace = inplace )","title":"apply()"},{"location":"api/FlaxModule/#treex.nn.flax_module.FlaxModule.check_metadata_updates","text":"Checks for new fields, if found, adds them to the metadata. Source code in treex/nn/flax_module.py def check_metadata_updates ( self ): \"\"\" Checks for new fields, if found, adds them to the metadata. \"\"\" with _CONTEXT . update ( flatten_mode = FlattenMode . all_fields ): jax . tree_flatten ( self )","title":"check_metadata_updates()"},{"location":"api/FlaxModule/#treex.nn.flax_module.FlaxModule.copy","text":"copy is a wrapper over treeo.copy that passes self as the first argument. Source code in treex/nn/flax_module.py def copy ( self : A ) -> A : \"\"\" `copy` is a wrapper over `treeo.copy` that passes `self` as the first argument. \"\"\" return tree_m . copy ( self )","title":"copy()"},{"location":"api/FlaxModule/#treex.nn.flax_module.FlaxModule.eval","text":"Creates a new module with the training mode set to False, equivalent to calling train(False) . Returns: Type Description ~T The new module with the training mode set to False. Source code in treex/nn/flax_module.py def eval ( self : T , inplace : bool = False ) -> T : \"\"\" Creates a new module with the training mode set to False, equivalent to calling `train(False)`. Returns: The new module with the training mode set to False. \"\"\" return self . train ( False , inplace = inplace )","title":"eval()"},{"location":"api/FlaxModule/#treex.nn.flax_module.FlaxModule.filter","text":"filter is a wrapper over treeo.filter that passes self as the first argument. Parameters: Name Type Description Default *filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treex/nn/flax_module.py def filter ( self : A , * filters : api . Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ) -> A : \"\"\" `filter` is a wrapper over `treeo.filter` that passes `self` as the first argument. Arguments: *filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" return api . filter ( self , * filters , inplace = inplace , flatten_mode = flatten_mode )","title":"filter()"},{"location":"api/FlaxModule/#treex.nn.flax_module.FlaxModule.freeze","text":"Creates a new module with the same structure, but with Module.frozen set to the given value. Parameters: Name Type Description Default mode bool The new frozen mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module in with the frozen mode is set to the given value, if inplace is True then self is returned. Source code in treex/nn/flax_module.py def freeze ( self : T , mode : bool = True , inplace : bool = False ) -> T : \"\"\" Creates a new module with the same structure, but with `Module.frozen` set to the given value. Arguments: mode: The new `frozen` mode. inplace: Whether to update the module inplace. Returns: The new module in with the `frozen` mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_frozen ( tree ): if isinstance ( tree , Treex ) and hasattr ( tree , \"_frozen\" ): tree . _frozen = mode return to . apply ( set_frozen , self , inplace = inplace )","title":"freeze()"},{"location":"api/FlaxModule/#treex.nn.flax_module.FlaxModule.get_field","text":"A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: The field must be declared in the class definition. The method can only be called inside a compact context. Parameters: Name Type Description Default field_name str The name of the field to get. required initializer Callable[[], ~A] The function to initialize the field if it does not exist. required Returns: Type Description ~A The field value. Source code in treex/nn/flax_module.py def get_field ( self , field_name : str , initializer : tp . Callable [[], A ], ) -> A : \"\"\" A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: * The field must be declared in the class definition. * The method can only be called inside a `compact` context. Arguments: field_name: The name of the field to get. initializer: The function to initialize the field if it does not exist. Returns: The field value. \"\"\" value : A if field_name not in self . _field_metadata : raise ValueError ( f \"Metadata for field ' { field_name } ' does not exist.\" ) if field_name in vars ( self ): value = getattr ( self , field_name ) else : if tree_m . _COMPACT_CONTEXT . in_compact and not self . first_run : raise RuntimeError ( f \"Trying to initialize field ' { field_name } ' after the first run of `compact`.\" ) value = initializer () setattr ( self , field_name , value ) return value","title":"get_field()"},{"location":"api/FlaxModule/#treex.nn.flax_module.FlaxModule.init","text":"Method version of tx.init , it applies self as first argument. init creates a new module with the same structure, but with its fields initialized given a seed key . The following procedure is used: The input key is split and iteratively updated before passing a derived value to any process that requires initialization. Initializer s are called and applied to the module first. Module.rng_init methods are called last. Parameters: Name Type Description Default key Union[int, jax._src.numpy.lax_numpy.ndarray] The seed to use for initialization. required Returns: Type Description ~M The new module with the fields initialized. Source code in treex/nn/flax_module.py def init ( self : M , key : tp . Union [ int , jnp . ndarray ], inputs : types . InputLike = to . MISSING , call_method : str = \"__call__\" , * , inplace : bool = False , _set_initialize : bool = True , ) -> M : \"\"\" Method version of `tx.init`, it applies `self` as first argument. `init` creates a new module with the same structure, but with its fields initialized given a seed `key`. The following procedure is used: 1. The input `key` is split and iteratively updated before passing a derived value to any process that requires initialization. 2. `Initializer`s are called and applied to the module first. 3. `Module.rng_init` methods are called last. Arguments: key: The seed to use for initialization. Returns: The new module with the fields initialized. \"\"\" module = self . copy () if not inplace else self key = utils . Key ( key ) with _INIT_CONTEXT . update ( key = key , initializing = True ): module : M = module . map ( lambda initializer : ( initializer ( next_key ()) if isinstance ( initializer , types . Initializer ) else initializer ), is_leaf = lambda x : isinstance ( x , types . Initializer ), inplace = True , ) def call_rng_init ( module : Module ): if isinstance ( module , Module ) and not module . _initialized : module . rng_init () module = to . apply ( call_rng_init , module , inplace = True ) if inputs is not to . MISSING : inputs = types . Inputs . from_value ( inputs ) method = getattr ( module , call_method ) method ( * inputs . args , ** inputs . kwargs ) if _set_initialize : def set_initialized ( module : Module ): if isinstance ( module , Module ) and not module . _initialized : module . _initialized = True module = to . apply ( set_initialized , module , inplace = True ) return module","title":"init()"},{"location":"api/FlaxModule/#treex.nn.flax_module.FlaxModule.logs","text":"Returns a copy of the Module with only tx.Log TreeParts, alias for filter(tx.Log) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/flax_module.py def logs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Log TreeParts, alias for `filter(tx.Log)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . Log , * filters )","title":"logs()"},{"location":"api/FlaxModule/#treex.nn.flax_module.FlaxModule.loss_logs","text":"Returns a copy of the Module with only tx.Loss TreeParts, alias for filter(tx.Loss) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/flax_module.py def loss_logs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Loss TreeParts, alias for `filter(tx.Loss)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . LossLog , * filters )","title":"loss_logs()"},{"location":"api/FlaxModule/#treex.nn.flax_module.FlaxModule.map","text":"map is a wrapper over treeo.map that passes self as the second argument. Parameters: Name Type Description Default f Callable The function to apply to the leaves. required *filters Filter The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treex/nn/flax_module.py def map ( self : A , f : tp . Callable , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , is_leaf : tp . Callable [[ tp . Any ], bool ] = None , ) -> A : \"\"\" `map` is a wrapper over `treeo.map` that passes `self` as the second argument. Arguments: f: The function to apply to the leaves. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" return api . map ( f , self , * filters , inplace = inplace , flatten_mode = flatten_mode , is_leaf = is_leaf , )","title":"map()"},{"location":"api/FlaxModule/#treex.nn.flax_module.FlaxModule.merge","text":"merge is a wrapper over treeo.merge that passes self as the first argument. Parameters: Name Type Description Default other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the merged values. If inplace is True , obj is returned. Source code in treex/nn/flax_module.py def merge ( self : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" `merge` is a wrapper over `treeo.merge` that passes `self` as the first argument. Arguments: other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the merged values. If `inplace` is `True`, `obj` is returned. \"\"\" return api . merge ( self , other , * rest , inplace = inplace , flatten_mode = flatten_mode , ignore_static = ignore_static , )","title":"merge()"},{"location":"api/FlaxModule/#treex.nn.flax_module.FlaxModule.metric_logs","text":"Returns a copy of the Module with only tx.Metric TreeParts, alias for filter(tx.Metric) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/flax_module.py def metric_logs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Metric TreeParts, alias for `filter(tx.Metric)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . MetricLog , * filters )","title":"metric_logs()"},{"location":"api/FlaxModule/#treex.nn.flax_module.FlaxModule.model_states","text":"Returns a copy of the Module with only tx.ModelState TreeParts, alias for filter(tx.ModelState) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/flax_module.py def model_states ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.ModelState TreeParts, alias for `filter(tx.ModelState)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . ModelState , * filters )","title":"model_states()"},{"location":"api/FlaxModule/#treex.nn.flax_module.FlaxModule.parameters","text":"Returns a copy of the Module with only tx.Parameter TreeParts, alias for filter(tx.Parameter) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/flax_module.py def parameters ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Parameter TreeParts, alias for `filter(tx.Parameter)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . Parameter , * filters )","title":"parameters()"},{"location":"api/FlaxModule/#treex.nn.flax_module.FlaxModule.rngs","text":"Returns a copy of the Module with only tx.Rng TreeParts, alias for filter(tx.Rng) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/flax_module.py def rngs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Rng TreeParts, alias for `filter(tx.Rng)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . Rng , * filters )","title":"rngs()"},{"location":"api/FlaxModule/#treex.nn.flax_module.FlaxModule.states","text":"Returns a copy of the Module with only tx.State TreeParts, alias for filter(tx.State) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/flax_module.py def states ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.State TreeParts, alias for `filter(tx.State)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . State , * filters )","title":"states()"},{"location":"api/FlaxModule/#treex.nn.flax_module.FlaxModule.tabulate","text":"Returns a tabular representation of the module. Parameters: Name Type Description Default depth int The maximum depth of the representation in terms of nested Modules, -1 means no limit. -1 signature bool Whether to show the signature of the Module. False param_types bool Whether to show the types of the parameters. True Returns: Type Description str A string containing the tabular representation. Source code in treex/nn/flax_module.py def tabulate ( self , inputs : tp . Union [ types . InputLike , to . Missing ] = to . MISSING , depth : int = - 1 , signature : bool = False , param_types : bool = True , ) -> str : \"\"\" Returns a tabular representation of the module. Arguments: depth: The maximum depth of the representation in terms of nested Modules, -1 means no limit. signature: Whether to show the signature of the Module. param_types: Whether to show the types of the parameters. Returns: A string containing the tabular representation. \"\"\" self = to . copy ( self ) if inputs is not to . MISSING : inputs = types . Inputs . from_value ( inputs ) if not isinstance ( self , tp . Callable ): raise TypeError ( \"`inputs` can only be specified if the module is a callable.\" ) with contexts . _Context ( call_info = {}): # call using self to preserve references def eval_call ( args , kwargs ): assert isinstance ( self , tp . Callable ) return self ( * args , ** kwargs ) jax . eval_shape ( eval_call , inputs . args , inputs . kwargs , ) call_info = contexts . _CONTEXT . call_info else : call_info = None with to . add_field_info (): flat : tp . List [ to . FieldInfo ] flat , _ = jax . tree_flatten ( self ) tree_part_types : tp . Tuple [ tp . Type [ types . TreePart ], ... ] = tuple ( { field_info . kind for field_info in flat if utils . _generic_issubclass ( field_info . kind , types . TreePart ) } ) path = () rows = list ( utils . _get_tabulate_rows ( path , self , depth , tree_part_types , signature , param_types ) ) modules = [ row [ 0 ] for row in rows ] rows = [ row [ 1 :] for row in rows ] if call_info is not None : for module , row in zip ( modules , rows ): if module in call_info : inputs , outputs = call_info [ module ] simplified_inputs = ( inputs . args [ 0 ] if len ( inputs . kwargs ) == 0 and len ( inputs . args ) == 1 else inputs . kwargs if len ( inputs . kwargs ) == 0 else inputs . kwargs if len ( inputs . args ) == 0 else ( inputs . args , inputs . kwargs ) ) inputs_repr = utils . _format_param_tree ( simplified_inputs ) outputs_repr = utils . _format_param_tree ( outputs ) else : inputs_repr = \"\" outputs_repr = \"\" row . insert ( 3 , outputs_repr ) row . insert ( 3 , inputs_repr ) n_non_treepart_cols = 2 if call_info is None else 4 rows [ 0 ][ 0 ] = \"*\" rows . append ( [ \"\" ] * n_non_treepart_cols + [ \"Total:\" ] + [ utils . _format_obj_size ( self . filter ( kind ), add_padding = True ) for kind in tree_part_types ] ) utils . _add_padding ( rows ) table = Table ( show_header = True , show_lines = True , show_footer = True , # box=rich.box.HORIZONTALS, ) table . add_column ( \"path\" ) table . add_column ( \"module\" ) table . add_column ( \"params\" ) if call_info is not None : table . add_column ( \"inputs\" ) table . add_column ( \"outputs\" ) for tree_part_type in tree_part_types : type_name = tree_part_type . __name__ if type_name . startswith ( \"_\" ): type_name = type_name [ 1 :] table . add_column ( type_name ) for row in rows [: - 1 ]: table . add_row ( * row ) table . columns [ n_non_treepart_cols ] . footer = Text . from_markup ( rows [ - 1 ][ n_non_treepart_cols ], justify = \"right\" ) for i in range ( len ( tree_part_types )): table . columns [ n_non_treepart_cols + 1 + i ] . footer = rows [ - 1 ][ n_non_treepart_cols + 1 + i ] table . caption_style = \"bold\" table . caption = \" \\n Total Parameters: \" + utils . _format_obj_size ( self , add_padding = False ) return utils . _get_rich_repr ( table )","title":"tabulate()"},{"location":"api/FlaxModule/#treex.nn.flax_module.FlaxModule.to_dict","text":"to_dict is a wrapper over treeo.to_dict that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True type_info bool If True , type information is included. False field_info bool If True , field information is included. False Returns: Type Description Any A dict representation of the object. Source code in treex/nn/flax_module.py def to_dict ( self , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : \"\"\" `to_dict` is a wrapper over `treeo.to_dict` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. type_info: If `True`, type information is included. field_info: If `True`, field information is included. Returns: A dict representation of the object. \"\"\" return api . to_dict ( self , private_fields = private_fields , static_fields = static_fields , type_info = type_info , field_info = field_info , )","title":"to_dict()"},{"location":"api/FlaxModule/#treex.nn.flax_module.FlaxModule.to_string","text":"to_string is a wrapper over treeo.to_string that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True color bool If True , color is included. False Returns: Type Description str A string representation of the object. Source code in treex/nn/flax_module.py def to_string ( self : A , * , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" `to_string` is a wrapper over `treeo.to_string` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. color: If `True`, color is included. Returns: A string representation of the object. \"\"\" return api . to_string ( self , private_fields = private_fields , static_fields = static_fields , color = color , )","title":"to_string()"},{"location":"api/FlaxModule/#treex.nn.flax_module.FlaxModule.train","text":"Creates a new module with the same structure, but with Module.training set to the given value. Parameters: Name Type Description Default mode bool The new training mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module in with the training mode is set to the given value, if inplace is True then self is returned. Source code in treex/nn/flax_module.py def train ( self : T , mode : bool = True , inplace : bool = False ) -> T : \"\"\" Creates a new module with the same structure, but with `Module.training` set to the given value. Arguments: mode: The new training mode. inplace: Whether to update the module inplace. Returns: The new module in with the training mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_training ( tree ): if isinstance ( tree , Treex ) and hasattr ( tree , \"_training\" ): tree . _training = mode return to . apply ( set_training , self , inplace = inplace )","title":"train()"},{"location":"api/FlaxModule/#treex.nn.flax_module.FlaxModule.unfreeze","text":"Creates a new module with .frozen set to False, equivalent to calling freeze(False) . Parameters: Name Type Description Default inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module with .frozen set to False, if inplace is True then self is returned. Source code in treex/nn/flax_module.py def unfreeze ( self : T , inplace : bool = False ) -> T : \"\"\" Creates a new module with `.frozen` set to False, equivalent to calling `freeze(False)`. Arguments: inplace: Whether to update the module inplace. Returns: The new module with `.frozen` set to False, if `inplace` is `True` then `self` is returned. \"\"\" return self . freeze ( False , inplace = inplace )","title":"unfreeze()"},{"location":"api/Hashable/","text":"treex.Hashable A hashable immutable wrapper around non-hashable values","title":"Hashable"},{"location":"api/Hashable/#treexhashable","text":"A hashable immutable wrapper around non-hashable values","title":"treex.Hashable"},{"location":"api/Initializer/","text":"treex.Initializer Initialize a field from a function that expects a single argument with a PRNGKey. Initializers are called by Module.init and replace the value of the field they are assigned to. __class__ inherited __base__ inherited Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()). __instancecheck__ ( cls , instance ) special Override for isinstance(instance, cls). Source code in treex/types.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance ) __new__ ( mcls , name , bases , namespace , ** kwargs ) special staticmethod Create and return a new object. See help(type) for accurate signature. Source code in treex/types.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls __subclasscheck__ ( cls , subclass ) special Override for issubclass(subclass, cls). Source code in treex/types.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass ) register ( cls , subclass ) Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/types.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) register ( cls , subclass ) inherited Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/types.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) __init__ ( self , f ) special Parameters: Name Type Description Default f Callable[[jax._src.numpy.lax_numpy.ndarray], Any] A function that takes a PRNGKey and returns the initial value of the field. required Source code in treex/types.py def __init__ ( self , f : tp . Callable [[ jnp . ndarray ], tp . Any ]): \"\"\" Arguments: f: A function that takes a PRNGKey and returns the initial value of the field. \"\"\" self . f = f check_metadata_updates ( self ) inherited Checks for new fields, if found, adds them to the metadata. Source code in treex/types.py def check_metadata_updates ( self ): \"\"\" Checks for new fields, if found, adds them to the metadata. \"\"\" with _CONTEXT . update ( flatten_mode = FlattenMode . all_fields ): jax . tree_flatten ( self )","title":"Initializer"},{"location":"api/Initializer/#treexinitializer","text":"Initialize a field from a function that expects a single argument with a PRNGKey. Initializers are called by Module.init and replace the value of the field they are assigned to.","title":"treex.Initializer"},{"location":"api/Initializer/#treex.types.Initializer.__class__","text":"","title":"__class__"},{"location":"api/Initializer/#treex.types.Initializer.__class__.__base__","text":"Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()).","title":"__base__"},{"location":"api/Initializer/#treex.types.Initializer.__class__.__base__.__instancecheck__","text":"Override for isinstance(instance, cls). Source code in treex/types.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance )","title":"__instancecheck__()"},{"location":"api/Initializer/#treex.types.Initializer.__class__.__base__.__new__","text":"Create and return a new object. See help(type) for accurate signature. Source code in treex/types.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls","title":"__new__()"},{"location":"api/Initializer/#treex.types.Initializer.__class__.__base__.__subclasscheck__","text":"Override for issubclass(subclass, cls). Source code in treex/types.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass )","title":"__subclasscheck__()"},{"location":"api/Initializer/#treex.types.Initializer.__class__.__base__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/types.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/Initializer/#treex.types.Initializer.__class__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/types.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/Initializer/#treex.types.Initializer.__init__","text":"Parameters: Name Type Description Default f Callable[[jax._src.numpy.lax_numpy.ndarray], Any] A function that takes a PRNGKey and returns the initial value of the field. required Source code in treex/types.py def __init__ ( self , f : tp . Callable [[ jnp . ndarray ], tp . Any ]): \"\"\" Arguments: f: A function that takes a PRNGKey and returns the initial value of the field. \"\"\" self . f = f","title":"__init__()"},{"location":"api/Initializer/#treex.types.Initializer.check_metadata_updates","text":"Checks for new fields, if found, adds them to the metadata. Source code in treex/types.py def check_metadata_updates ( self ): \"\"\" Checks for new fields, if found, adds them to the metadata. \"\"\" with _CONTEXT . update ( flatten_mode = FlattenMode . all_fields ): jax . tree_flatten ( self )","title":"check_metadata_updates()"},{"location":"api/Inputs/","text":"treex.Inputs","title":"Inputs"},{"location":"api/Inputs/#treexinputs","text":"","title":"treex.Inputs"},{"location":"api/Key/","text":"treex.Key Source code in treex/utils.py def Key ( seed : tp . Union [ int , jnp . ndarray ]) -> jnp . ndarray : return jax . random . PRNGKey ( seed ) if isinstance ( seed , int ) else seed","title":"Key"},{"location":"api/Key/#treexkey","text":"Source code in treex/utils.py def Key ( seed : tp . Union [ int , jnp . ndarray ]) -> jnp . ndarray : return jax . random . PRNGKey ( seed ) if isinstance ( seed , int ) else seed","title":"treex.Key"},{"location":"api/KeySeq/","text":"treex.KeySeq KeySeq is simple module that can produce a sequence of PRNGKeys. Examples: class Dropout ( Module ): rng : KeySeq () def __init__ ( self , rate : float ): self . next_key = KeySeq () ... def __call__ ( self , x : jnp . ndarray ) -> jnp . ndarray : key = self . next_key () mask = jax . random . bernoulli ( key , 1.0 - self . rate ) ... first_run : bool inherited property readonly Returns: Type Description bool True if its currently the first run of a compact method. __class__ inherited __base__ inherited __base__ inherited Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()). __instancecheck__ ( cls , instance ) special Override for isinstance(instance, cls). Source code in treex/key_seq.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance ) __new__ ( mcls , name , bases , namespace , ** kwargs ) special staticmethod Create and return a new object. See help(type) for accurate signature. Source code in treex/key_seq.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls __subclasscheck__ ( cls , subclass ) special Override for issubclass(subclass, cls). Source code in treex/key_seq.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass ) register ( cls , subclass ) Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/key_seq.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) register ( cls , subclass ) inherited Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/key_seq.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) register ( cls , subclass ) inherited Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/key_seq.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) __call__ ( self ) special Return a new PRNGKey and updates the internal rng state. Returns: Type Description ndarray A PRNGKey. Source code in treex/key_seq.py def __call__ ( self ) -> jnp . ndarray : \"\"\" Return a new PRNGKey and updates the internal rng state. Returns: A PRNGKey. \"\"\" assert isinstance ( self . key , jnp . ndarray ) key , self . key = utils . iter_split ( self . key ) return key __init__ ( self , key = None ) special Parameters: Name Type Description Default key Union[jax._src.numpy.lax_numpy.ndarray, int] An optional PRNGKey to initialize the KeySeq with. None Source code in treex/key_seq.py def __init__ ( self , key : tp . Optional [ tp . Union [ jnp . ndarray , int ]] = None ): \"\"\" Arguments: key: An optional PRNGKey to initialize the KeySeq with. \"\"\" self . key = ( utils . Key ( key ) if isinstance ( key , int ) else key if isinstance ( key , ( jnp . ndarray , np . ndarray )) else types . Initializer ( lambda key : key ) ) apply ( self , f , * rest , * , inplace = False ) inherited apply is a wrapper over treeo.apply that passes self as the second argument. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treex/key_seq.py def apply ( self : A , f : tp . Callable [ ... , None ], * rest : A , inplace : bool = False ) -> A : \"\"\" `apply` is a wrapper over `treeo.apply` that passes `self` as the second argument. Arguments: f: The function to apply. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" return api . apply ( f , self , * rest , inplace = inplace ) batch_stats ( self , * filters ) inherited Returns a copy of the Module with only tx.BatchStat TreeParts, alias for filter(tx.BatchStat) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/key_seq.py def batch_stats ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.BatchStat TreeParts, alias for `filter(tx.BatchStat)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . BatchStat , * filters ) check_metadata_updates ( self ) inherited Checks for new fields, if found, adds them to the metadata. Source code in treex/key_seq.py def check_metadata_updates ( self ): \"\"\" Checks for new fields, if found, adds them to the metadata. \"\"\" with _CONTEXT . update ( flatten_mode = FlattenMode . all_fields ): jax . tree_flatten ( self ) copy ( self ) inherited copy is a wrapper over treeo.copy that passes self as the first argument. Source code in treex/key_seq.py def copy ( self : A ) -> A : \"\"\" `copy` is a wrapper over `treeo.copy` that passes `self` as the first argument. \"\"\" return tree_m . copy ( self ) eval ( self , inplace = False ) inherited Creates a new module with the training mode set to False, equivalent to calling train(False) . Returns: Type Description ~T The new module with the training mode set to False. Source code in treex/key_seq.py def eval ( self : T , inplace : bool = False ) -> T : \"\"\" Creates a new module with the training mode set to False, equivalent to calling `train(False)`. Returns: The new module with the training mode set to False. \"\"\" return self . train ( False , inplace = inplace ) filter ( self , * filters , * , inplace = False , flatten_mode = None ) inherited filter is a wrapper over treeo.filter that passes self as the first argument. Parameters: Name Type Description Default *filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treex/key_seq.py def filter ( self : A , * filters : api . Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ) -> A : \"\"\" `filter` is a wrapper over `treeo.filter` that passes `self` as the first argument. Arguments: *filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" return api . filter ( self , * filters , inplace = inplace , flatten_mode = flatten_mode ) freeze ( self , mode = True , inplace = False ) inherited Creates a new module with the same structure, but with Module.frozen set to the given value. Parameters: Name Type Description Default mode bool The new frozen mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module in with the frozen mode is set to the given value, if inplace is True then self is returned. Source code in treex/key_seq.py def freeze ( self : T , mode : bool = True , inplace : bool = False ) -> T : \"\"\" Creates a new module with the same structure, but with `Module.frozen` set to the given value. Arguments: mode: The new `frozen` mode. inplace: Whether to update the module inplace. Returns: The new module in with the `frozen` mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_frozen ( tree ): if isinstance ( tree , Treex ) and hasattr ( tree , \"_frozen\" ): tree . _frozen = mode return to . apply ( set_frozen , self , inplace = inplace ) get_field ( self , field_name , initializer ) inherited A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: The field must be declared in the class definition. The method can only be called inside a compact context. Parameters: Name Type Description Default field_name str The name of the field to get. required initializer Callable[[], ~A] The function to initialize the field if it does not exist. required Returns: Type Description ~A The field value. Source code in treex/key_seq.py def get_field ( self , field_name : str , initializer : tp . Callable [[], A ], ) -> A : \"\"\" A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: * The field must be declared in the class definition. * The method can only be called inside a `compact` context. Arguments: field_name: The name of the field to get. initializer: The function to initialize the field if it does not exist. Returns: The field value. \"\"\" value : A if field_name not in self . _field_metadata : raise ValueError ( f \"Metadata for field ' { field_name } ' does not exist.\" ) if field_name in vars ( self ): value = getattr ( self , field_name ) else : if tree_m . _COMPACT_CONTEXT . in_compact and not self . first_run : raise RuntimeError ( f \"Trying to initialize field ' { field_name } ' after the first run of `compact`.\" ) value = initializer () setattr ( self , field_name , value ) return value init ( self , key , inputs =< treeo . types . Missing object at 0x7f29ce5c9220 > , call_method = '__call__' , * , inplace = False , _set_initialize = True ) inherited Method version of tx.init , it applies self as first argument. init creates a new module with the same structure, but with its fields initialized given a seed key . The following procedure is used: The input key is split and iteratively updated before passing a derived value to any process that requires initialization. Initializer s are called and applied to the module first. Module.rng_init methods are called last. Parameters: Name Type Description Default key Union[int, jax._src.numpy.lax_numpy.ndarray] The seed to use for initialization. required Returns: Type Description ~M The new module with the fields initialized. Source code in treex/key_seq.py def init ( self : M , key : tp . Union [ int , jnp . ndarray ], inputs : types . InputLike = to . MISSING , call_method : str = \"__call__\" , * , inplace : bool = False , _set_initialize : bool = True , ) -> M : \"\"\" Method version of `tx.init`, it applies `self` as first argument. `init` creates a new module with the same structure, but with its fields initialized given a seed `key`. The following procedure is used: 1. The input `key` is split and iteratively updated before passing a derived value to any process that requires initialization. 2. `Initializer`s are called and applied to the module first. 3. `Module.rng_init` methods are called last. Arguments: key: The seed to use for initialization. Returns: The new module with the fields initialized. \"\"\" module = self . copy () if not inplace else self key = utils . Key ( key ) with _INIT_CONTEXT . update ( key = key , initializing = True ): module : M = module . map ( lambda initializer : ( initializer ( next_key ()) if isinstance ( initializer , types . Initializer ) else initializer ), is_leaf = lambda x : isinstance ( x , types . Initializer ), inplace = True , ) def call_rng_init ( module : Module ): if isinstance ( module , Module ) and not module . _initialized : module . rng_init () module = to . apply ( call_rng_init , module , inplace = True ) if inputs is not to . MISSING : inputs = types . Inputs . from_value ( inputs ) method = getattr ( module , call_method ) method ( * inputs . args , ** inputs . kwargs ) if _set_initialize : def set_initialized ( module : Module ): if isinstance ( module , Module ) and not module . _initialized : module . _initialized = True module = to . apply ( set_initialized , module , inplace = True ) return module logs ( self , * filters ) inherited Returns a copy of the Module with only tx.Log TreeParts, alias for filter(tx.Log) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/key_seq.py def logs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Log TreeParts, alias for `filter(tx.Log)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . Log , * filters ) loss_logs ( self , * filters ) inherited Returns a copy of the Module with only tx.Loss TreeParts, alias for filter(tx.Loss) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/key_seq.py def loss_logs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Loss TreeParts, alias for `filter(tx.Loss)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . LossLog , * filters ) map ( self , f , * filters , * , inplace = False , flatten_mode = None , is_leaf = None ) inherited map is a wrapper over treeo.map that passes self as the second argument. Parameters: Name Type Description Default f Callable The function to apply to the leaves. required *filters Filter The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treex/key_seq.py def map ( self : A , f : tp . Callable , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , is_leaf : tp . Callable [[ tp . Any ], bool ] = None , ) -> A : \"\"\" `map` is a wrapper over `treeo.map` that passes `self` as the second argument. Arguments: f: The function to apply to the leaves. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" return api . map ( f , self , * filters , inplace = inplace , flatten_mode = flatten_mode , is_leaf = is_leaf , ) merge ( self , other , * rest , * , inplace = False , flatten_mode = None , ignore_static = False ) inherited merge is a wrapper over treeo.merge that passes self as the first argument. Parameters: Name Type Description Default other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the merged values. If inplace is True , obj is returned. Source code in treex/key_seq.py def merge ( self : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" `merge` is a wrapper over `treeo.merge` that passes `self` as the first argument. Arguments: other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the merged values. If `inplace` is `True`, `obj` is returned. \"\"\" return api . merge ( self , other , * rest , inplace = inplace , flatten_mode = flatten_mode , ignore_static = ignore_static , ) metric_logs ( self , * filters ) inherited Returns a copy of the Module with only tx.Metric TreeParts, alias for filter(tx.Metric) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/key_seq.py def metric_logs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Metric TreeParts, alias for `filter(tx.Metric)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . MetricLog , * filters ) model_states ( self , * filters ) inherited Returns a copy of the Module with only tx.ModelState TreeParts, alias for filter(tx.ModelState) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/key_seq.py def model_states ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.ModelState TreeParts, alias for `filter(tx.ModelState)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . ModelState , * filters ) parameters ( self , * filters ) inherited Returns a copy of the Module with only tx.Parameter TreeParts, alias for filter(tx.Parameter) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/key_seq.py def parameters ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Parameter TreeParts, alias for `filter(tx.Parameter)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . Parameter , * filters ) rngs ( self , * filters ) inherited Returns a copy of the Module with only tx.Rng TreeParts, alias for filter(tx.Rng) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/key_seq.py def rngs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Rng TreeParts, alias for `filter(tx.Rng)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . Rng , * filters ) states ( self , * filters ) inherited Returns a copy of the Module with only tx.State TreeParts, alias for filter(tx.State) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/key_seq.py def states ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.State TreeParts, alias for `filter(tx.State)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . State , * filters ) tabulate ( self , inputs =< treeo . types . Missing object at 0x7f29ce5c9220 > , depth =- 1 , signature = False , param_types = True ) inherited Returns a tabular representation of the module. Parameters: Name Type Description Default depth int The maximum depth of the representation in terms of nested Modules, -1 means no limit. -1 signature bool Whether to show the signature of the Module. False param_types bool Whether to show the types of the parameters. True Returns: Type Description str A string containing the tabular representation. Source code in treex/key_seq.py def tabulate ( self , inputs : tp . Union [ types . InputLike , to . Missing ] = to . MISSING , depth : int = - 1 , signature : bool = False , param_types : bool = True , ) -> str : \"\"\" Returns a tabular representation of the module. Arguments: depth: The maximum depth of the representation in terms of nested Modules, -1 means no limit. signature: Whether to show the signature of the Module. param_types: Whether to show the types of the parameters. Returns: A string containing the tabular representation. \"\"\" self = to . copy ( self ) if inputs is not to . MISSING : inputs = types . Inputs . from_value ( inputs ) if not isinstance ( self , tp . Callable ): raise TypeError ( \"`inputs` can only be specified if the module is a callable.\" ) with contexts . _Context ( call_info = {}): # call using self to preserve references def eval_call ( args , kwargs ): assert isinstance ( self , tp . Callable ) return self ( * args , ** kwargs ) jax . eval_shape ( eval_call , inputs . args , inputs . kwargs , ) call_info = contexts . _CONTEXT . call_info else : call_info = None with to . add_field_info (): flat : tp . List [ to . FieldInfo ] flat , _ = jax . tree_flatten ( self ) tree_part_types : tp . Tuple [ tp . Type [ types . TreePart ], ... ] = tuple ( { field_info . kind for field_info in flat if utils . _generic_issubclass ( field_info . kind , types . TreePart ) } ) path = () rows = list ( utils . _get_tabulate_rows ( path , self , depth , tree_part_types , signature , param_types ) ) modules = [ row [ 0 ] for row in rows ] rows = [ row [ 1 :] for row in rows ] if call_info is not None : for module , row in zip ( modules , rows ): if module in call_info : inputs , outputs = call_info [ module ] simplified_inputs = ( inputs . args [ 0 ] if len ( inputs . kwargs ) == 0 and len ( inputs . args ) == 1 else inputs . kwargs if len ( inputs . kwargs ) == 0 else inputs . kwargs if len ( inputs . args ) == 0 else ( inputs . args , inputs . kwargs ) ) inputs_repr = utils . _format_param_tree ( simplified_inputs ) outputs_repr = utils . _format_param_tree ( outputs ) else : inputs_repr = \"\" outputs_repr = \"\" row . insert ( 3 , outputs_repr ) row . insert ( 3 , inputs_repr ) n_non_treepart_cols = 2 if call_info is None else 4 rows [ 0 ][ 0 ] = \"*\" rows . append ( [ \"\" ] * n_non_treepart_cols + [ \"Total:\" ] + [ utils . _format_obj_size ( self . filter ( kind ), add_padding = True ) for kind in tree_part_types ] ) utils . _add_padding ( rows ) table = Table ( show_header = True , show_lines = True , show_footer = True , # box=rich.box.HORIZONTALS, ) table . add_column ( \"path\" ) table . add_column ( \"module\" ) table . add_column ( \"params\" ) if call_info is not None : table . add_column ( \"inputs\" ) table . add_column ( \"outputs\" ) for tree_part_type in tree_part_types : type_name = tree_part_type . __name__ if type_name . startswith ( \"_\" ): type_name = type_name [ 1 :] table . add_column ( type_name ) for row in rows [: - 1 ]: table . add_row ( * row ) table . columns [ n_non_treepart_cols ] . footer = Text . from_markup ( rows [ - 1 ][ n_non_treepart_cols ], justify = \"right\" ) for i in range ( len ( tree_part_types )): table . columns [ n_non_treepart_cols + 1 + i ] . footer = rows [ - 1 ][ n_non_treepart_cols + 1 + i ] table . caption_style = \"bold\" table . caption = \" \\n Total Parameters: \" + utils . _format_obj_size ( self , add_padding = False ) return utils . _get_rich_repr ( table ) to_dict ( self , * , private_fields = False , static_fields = True , type_info = False , field_info = False ) inherited to_dict is a wrapper over treeo.to_dict that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True type_info bool If True , type information is included. False field_info bool If True , field information is included. False Returns: Type Description Any A dict representation of the object. Source code in treex/key_seq.py def to_dict ( self , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : \"\"\" `to_dict` is a wrapper over `treeo.to_dict` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. type_info: If `True`, type information is included. field_info: If `True`, field information is included. Returns: A dict representation of the object. \"\"\" return api . to_dict ( self , private_fields = private_fields , static_fields = static_fields , type_info = type_info , field_info = field_info , ) to_string ( self , * , private_fields = False , static_fields = True , color = False ) inherited to_string is a wrapper over treeo.to_string that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True color bool If True , color is included. False Returns: Type Description str A string representation of the object. Source code in treex/key_seq.py def to_string ( self : A , * , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" `to_string` is a wrapper over `treeo.to_string` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. color: If `True`, color is included. Returns: A string representation of the object. \"\"\" return api . to_string ( self , private_fields = private_fields , static_fields = static_fields , color = color , ) train ( self , mode = True , inplace = False ) inherited Creates a new module with the same structure, but with Module.training set to the given value. Parameters: Name Type Description Default mode bool The new training mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module in with the training mode is set to the given value, if inplace is True then self is returned. Source code in treex/key_seq.py def train ( self : T , mode : bool = True , inplace : bool = False ) -> T : \"\"\" Creates a new module with the same structure, but with `Module.training` set to the given value. Arguments: mode: The new training mode. inplace: Whether to update the module inplace. Returns: The new module in with the training mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_training ( tree ): if isinstance ( tree , Treex ) and hasattr ( tree , \"_training\" ): tree . _training = mode return to . apply ( set_training , self , inplace = inplace ) unfreeze ( self , inplace = False ) inherited Creates a new module with .frozen set to False, equivalent to calling freeze(False) . Parameters: Name Type Description Default inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module with .frozen set to False, if inplace is True then self is returned. Source code in treex/key_seq.py def unfreeze ( self : T , inplace : bool = False ) -> T : \"\"\" Creates a new module with `.frozen` set to False, equivalent to calling `freeze(False)`. Arguments: inplace: Whether to update the module inplace. Returns: The new module with `.frozen` set to False, if `inplace` is `True` then `self` is returned. \"\"\" return self . freeze ( False , inplace = inplace )","title":"KeySeq"},{"location":"api/KeySeq/#treexkeyseq","text":"KeySeq is simple module that can produce a sequence of PRNGKeys. Examples: class Dropout ( Module ): rng : KeySeq () def __init__ ( self , rate : float ): self . next_key = KeySeq () ... def __call__ ( self , x : jnp . ndarray ) -> jnp . ndarray : key = self . next_key () mask = jax . random . bernoulli ( key , 1.0 - self . rate ) ...","title":"treex.KeySeq"},{"location":"api/KeySeq/#treex.key_seq.KeySeq.first_run","text":"Returns: Type Description bool True if its currently the first run of a compact method.","title":"first_run"},{"location":"api/KeySeq/#treex.key_seq.KeySeq.__class__","text":"","title":"__class__"},{"location":"api/KeySeq/#treex.key_seq.KeySeq.__class__.__base__","text":"","title":"__base__"},{"location":"api/KeySeq/#treex.key_seq.KeySeq.__class__.__base__.__base__","text":"Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()).","title":"__base__"},{"location":"api/KeySeq/#treex.key_seq.KeySeq.__class__.__base__.__base__.__instancecheck__","text":"Override for isinstance(instance, cls). Source code in treex/key_seq.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance )","title":"__instancecheck__()"},{"location":"api/KeySeq/#treex.key_seq.KeySeq.__class__.__base__.__base__.__new__","text":"Create and return a new object. See help(type) for accurate signature. Source code in treex/key_seq.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls","title":"__new__()"},{"location":"api/KeySeq/#treex.key_seq.KeySeq.__class__.__base__.__base__.__subclasscheck__","text":"Override for issubclass(subclass, cls). Source code in treex/key_seq.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass )","title":"__subclasscheck__()"},{"location":"api/KeySeq/#treex.key_seq.KeySeq.__class__.__base__.__base__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/key_seq.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/KeySeq/#treex.key_seq.KeySeq.__class__.__base__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/key_seq.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/KeySeq/#treex.key_seq.KeySeq.__class__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/key_seq.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/KeySeq/#treex.key_seq.KeySeq.__call__","text":"Return a new PRNGKey and updates the internal rng state. Returns: Type Description ndarray A PRNGKey. Source code in treex/key_seq.py def __call__ ( self ) -> jnp . ndarray : \"\"\" Return a new PRNGKey and updates the internal rng state. Returns: A PRNGKey. \"\"\" assert isinstance ( self . key , jnp . ndarray ) key , self . key = utils . iter_split ( self . key ) return key","title":"__call__()"},{"location":"api/KeySeq/#treex.key_seq.KeySeq.__init__","text":"Parameters: Name Type Description Default key Union[jax._src.numpy.lax_numpy.ndarray, int] An optional PRNGKey to initialize the KeySeq with. None Source code in treex/key_seq.py def __init__ ( self , key : tp . Optional [ tp . Union [ jnp . ndarray , int ]] = None ): \"\"\" Arguments: key: An optional PRNGKey to initialize the KeySeq with. \"\"\" self . key = ( utils . Key ( key ) if isinstance ( key , int ) else key if isinstance ( key , ( jnp . ndarray , np . ndarray )) else types . Initializer ( lambda key : key ) )","title":"__init__()"},{"location":"api/KeySeq/#treex.key_seq.KeySeq.apply","text":"apply is a wrapper over treeo.apply that passes self as the second argument. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treex/key_seq.py def apply ( self : A , f : tp . Callable [ ... , None ], * rest : A , inplace : bool = False ) -> A : \"\"\" `apply` is a wrapper over `treeo.apply` that passes `self` as the second argument. Arguments: f: The function to apply. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" return api . apply ( f , self , * rest , inplace = inplace )","title":"apply()"},{"location":"api/KeySeq/#treex.key_seq.KeySeq.batch_stats","text":"Returns a copy of the Module with only tx.BatchStat TreeParts, alias for filter(tx.BatchStat) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/key_seq.py def batch_stats ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.BatchStat TreeParts, alias for `filter(tx.BatchStat)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . BatchStat , * filters )","title":"batch_stats()"},{"location":"api/KeySeq/#treex.key_seq.KeySeq.check_metadata_updates","text":"Checks for new fields, if found, adds them to the metadata. Source code in treex/key_seq.py def check_metadata_updates ( self ): \"\"\" Checks for new fields, if found, adds them to the metadata. \"\"\" with _CONTEXT . update ( flatten_mode = FlattenMode . all_fields ): jax . tree_flatten ( self )","title":"check_metadata_updates()"},{"location":"api/KeySeq/#treex.key_seq.KeySeq.copy","text":"copy is a wrapper over treeo.copy that passes self as the first argument. Source code in treex/key_seq.py def copy ( self : A ) -> A : \"\"\" `copy` is a wrapper over `treeo.copy` that passes `self` as the first argument. \"\"\" return tree_m . copy ( self )","title":"copy()"},{"location":"api/KeySeq/#treex.key_seq.KeySeq.eval","text":"Creates a new module with the training mode set to False, equivalent to calling train(False) . Returns: Type Description ~T The new module with the training mode set to False. Source code in treex/key_seq.py def eval ( self : T , inplace : bool = False ) -> T : \"\"\" Creates a new module with the training mode set to False, equivalent to calling `train(False)`. Returns: The new module with the training mode set to False. \"\"\" return self . train ( False , inplace = inplace )","title":"eval()"},{"location":"api/KeySeq/#treex.key_seq.KeySeq.filter","text":"filter is a wrapper over treeo.filter that passes self as the first argument. Parameters: Name Type Description Default *filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treex/key_seq.py def filter ( self : A , * filters : api . Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ) -> A : \"\"\" `filter` is a wrapper over `treeo.filter` that passes `self` as the first argument. Arguments: *filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" return api . filter ( self , * filters , inplace = inplace , flatten_mode = flatten_mode )","title":"filter()"},{"location":"api/KeySeq/#treex.key_seq.KeySeq.freeze","text":"Creates a new module with the same structure, but with Module.frozen set to the given value. Parameters: Name Type Description Default mode bool The new frozen mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module in with the frozen mode is set to the given value, if inplace is True then self is returned. Source code in treex/key_seq.py def freeze ( self : T , mode : bool = True , inplace : bool = False ) -> T : \"\"\" Creates a new module with the same structure, but with `Module.frozen` set to the given value. Arguments: mode: The new `frozen` mode. inplace: Whether to update the module inplace. Returns: The new module in with the `frozen` mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_frozen ( tree ): if isinstance ( tree , Treex ) and hasattr ( tree , \"_frozen\" ): tree . _frozen = mode return to . apply ( set_frozen , self , inplace = inplace )","title":"freeze()"},{"location":"api/KeySeq/#treex.key_seq.KeySeq.get_field","text":"A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: The field must be declared in the class definition. The method can only be called inside a compact context. Parameters: Name Type Description Default field_name str The name of the field to get. required initializer Callable[[], ~A] The function to initialize the field if it does not exist. required Returns: Type Description ~A The field value. Source code in treex/key_seq.py def get_field ( self , field_name : str , initializer : tp . Callable [[], A ], ) -> A : \"\"\" A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: * The field must be declared in the class definition. * The method can only be called inside a `compact` context. Arguments: field_name: The name of the field to get. initializer: The function to initialize the field if it does not exist. Returns: The field value. \"\"\" value : A if field_name not in self . _field_metadata : raise ValueError ( f \"Metadata for field ' { field_name } ' does not exist.\" ) if field_name in vars ( self ): value = getattr ( self , field_name ) else : if tree_m . _COMPACT_CONTEXT . in_compact and not self . first_run : raise RuntimeError ( f \"Trying to initialize field ' { field_name } ' after the first run of `compact`.\" ) value = initializer () setattr ( self , field_name , value ) return value","title":"get_field()"},{"location":"api/KeySeq/#treex.key_seq.KeySeq.init","text":"Method version of tx.init , it applies self as first argument. init creates a new module with the same structure, but with its fields initialized given a seed key . The following procedure is used: The input key is split and iteratively updated before passing a derived value to any process that requires initialization. Initializer s are called and applied to the module first. Module.rng_init methods are called last. Parameters: Name Type Description Default key Union[int, jax._src.numpy.lax_numpy.ndarray] The seed to use for initialization. required Returns: Type Description ~M The new module with the fields initialized. Source code in treex/key_seq.py def init ( self : M , key : tp . Union [ int , jnp . ndarray ], inputs : types . InputLike = to . MISSING , call_method : str = \"__call__\" , * , inplace : bool = False , _set_initialize : bool = True , ) -> M : \"\"\" Method version of `tx.init`, it applies `self` as first argument. `init` creates a new module with the same structure, but with its fields initialized given a seed `key`. The following procedure is used: 1. The input `key` is split and iteratively updated before passing a derived value to any process that requires initialization. 2. `Initializer`s are called and applied to the module first. 3. `Module.rng_init` methods are called last. Arguments: key: The seed to use for initialization. Returns: The new module with the fields initialized. \"\"\" module = self . copy () if not inplace else self key = utils . Key ( key ) with _INIT_CONTEXT . update ( key = key , initializing = True ): module : M = module . map ( lambda initializer : ( initializer ( next_key ()) if isinstance ( initializer , types . Initializer ) else initializer ), is_leaf = lambda x : isinstance ( x , types . Initializer ), inplace = True , ) def call_rng_init ( module : Module ): if isinstance ( module , Module ) and not module . _initialized : module . rng_init () module = to . apply ( call_rng_init , module , inplace = True ) if inputs is not to . MISSING : inputs = types . Inputs . from_value ( inputs ) method = getattr ( module , call_method ) method ( * inputs . args , ** inputs . kwargs ) if _set_initialize : def set_initialized ( module : Module ): if isinstance ( module , Module ) and not module . _initialized : module . _initialized = True module = to . apply ( set_initialized , module , inplace = True ) return module","title":"init()"},{"location":"api/KeySeq/#treex.key_seq.KeySeq.logs","text":"Returns a copy of the Module with only tx.Log TreeParts, alias for filter(tx.Log) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/key_seq.py def logs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Log TreeParts, alias for `filter(tx.Log)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . Log , * filters )","title":"logs()"},{"location":"api/KeySeq/#treex.key_seq.KeySeq.loss_logs","text":"Returns a copy of the Module with only tx.Loss TreeParts, alias for filter(tx.Loss) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/key_seq.py def loss_logs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Loss TreeParts, alias for `filter(tx.Loss)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . LossLog , * filters )","title":"loss_logs()"},{"location":"api/KeySeq/#treex.key_seq.KeySeq.map","text":"map is a wrapper over treeo.map that passes self as the second argument. Parameters: Name Type Description Default f Callable The function to apply to the leaves. required *filters Filter The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treex/key_seq.py def map ( self : A , f : tp . Callable , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , is_leaf : tp . Callable [[ tp . Any ], bool ] = None , ) -> A : \"\"\" `map` is a wrapper over `treeo.map` that passes `self` as the second argument. Arguments: f: The function to apply to the leaves. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" return api . map ( f , self , * filters , inplace = inplace , flatten_mode = flatten_mode , is_leaf = is_leaf , )","title":"map()"},{"location":"api/KeySeq/#treex.key_seq.KeySeq.merge","text":"merge is a wrapper over treeo.merge that passes self as the first argument. Parameters: Name Type Description Default other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the merged values. If inplace is True , obj is returned. Source code in treex/key_seq.py def merge ( self : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" `merge` is a wrapper over `treeo.merge` that passes `self` as the first argument. Arguments: other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the merged values. If `inplace` is `True`, `obj` is returned. \"\"\" return api . merge ( self , other , * rest , inplace = inplace , flatten_mode = flatten_mode , ignore_static = ignore_static , )","title":"merge()"},{"location":"api/KeySeq/#treex.key_seq.KeySeq.metric_logs","text":"Returns a copy of the Module with only tx.Metric TreeParts, alias for filter(tx.Metric) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/key_seq.py def metric_logs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Metric TreeParts, alias for `filter(tx.Metric)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . MetricLog , * filters )","title":"metric_logs()"},{"location":"api/KeySeq/#treex.key_seq.KeySeq.model_states","text":"Returns a copy of the Module with only tx.ModelState TreeParts, alias for filter(tx.ModelState) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/key_seq.py def model_states ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.ModelState TreeParts, alias for `filter(tx.ModelState)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . ModelState , * filters )","title":"model_states()"},{"location":"api/KeySeq/#treex.key_seq.KeySeq.parameters","text":"Returns a copy of the Module with only tx.Parameter TreeParts, alias for filter(tx.Parameter) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/key_seq.py def parameters ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Parameter TreeParts, alias for `filter(tx.Parameter)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . Parameter , * filters )","title":"parameters()"},{"location":"api/KeySeq/#treex.key_seq.KeySeq.rngs","text":"Returns a copy of the Module with only tx.Rng TreeParts, alias for filter(tx.Rng) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/key_seq.py def rngs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Rng TreeParts, alias for `filter(tx.Rng)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . Rng , * filters )","title":"rngs()"},{"location":"api/KeySeq/#treex.key_seq.KeySeq.states","text":"Returns a copy of the Module with only tx.State TreeParts, alias for filter(tx.State) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/key_seq.py def states ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.State TreeParts, alias for `filter(tx.State)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . State , * filters )","title":"states()"},{"location":"api/KeySeq/#treex.key_seq.KeySeq.tabulate","text":"Returns a tabular representation of the module. Parameters: Name Type Description Default depth int The maximum depth of the representation in terms of nested Modules, -1 means no limit. -1 signature bool Whether to show the signature of the Module. False param_types bool Whether to show the types of the parameters. True Returns: Type Description str A string containing the tabular representation. Source code in treex/key_seq.py def tabulate ( self , inputs : tp . Union [ types . InputLike , to . Missing ] = to . MISSING , depth : int = - 1 , signature : bool = False , param_types : bool = True , ) -> str : \"\"\" Returns a tabular representation of the module. Arguments: depth: The maximum depth of the representation in terms of nested Modules, -1 means no limit. signature: Whether to show the signature of the Module. param_types: Whether to show the types of the parameters. Returns: A string containing the tabular representation. \"\"\" self = to . copy ( self ) if inputs is not to . MISSING : inputs = types . Inputs . from_value ( inputs ) if not isinstance ( self , tp . Callable ): raise TypeError ( \"`inputs` can only be specified if the module is a callable.\" ) with contexts . _Context ( call_info = {}): # call using self to preserve references def eval_call ( args , kwargs ): assert isinstance ( self , tp . Callable ) return self ( * args , ** kwargs ) jax . eval_shape ( eval_call , inputs . args , inputs . kwargs , ) call_info = contexts . _CONTEXT . call_info else : call_info = None with to . add_field_info (): flat : tp . List [ to . FieldInfo ] flat , _ = jax . tree_flatten ( self ) tree_part_types : tp . Tuple [ tp . Type [ types . TreePart ], ... ] = tuple ( { field_info . kind for field_info in flat if utils . _generic_issubclass ( field_info . kind , types . TreePart ) } ) path = () rows = list ( utils . _get_tabulate_rows ( path , self , depth , tree_part_types , signature , param_types ) ) modules = [ row [ 0 ] for row in rows ] rows = [ row [ 1 :] for row in rows ] if call_info is not None : for module , row in zip ( modules , rows ): if module in call_info : inputs , outputs = call_info [ module ] simplified_inputs = ( inputs . args [ 0 ] if len ( inputs . kwargs ) == 0 and len ( inputs . args ) == 1 else inputs . kwargs if len ( inputs . kwargs ) == 0 else inputs . kwargs if len ( inputs . args ) == 0 else ( inputs . args , inputs . kwargs ) ) inputs_repr = utils . _format_param_tree ( simplified_inputs ) outputs_repr = utils . _format_param_tree ( outputs ) else : inputs_repr = \"\" outputs_repr = \"\" row . insert ( 3 , outputs_repr ) row . insert ( 3 , inputs_repr ) n_non_treepart_cols = 2 if call_info is None else 4 rows [ 0 ][ 0 ] = \"*\" rows . append ( [ \"\" ] * n_non_treepart_cols + [ \"Total:\" ] + [ utils . _format_obj_size ( self . filter ( kind ), add_padding = True ) for kind in tree_part_types ] ) utils . _add_padding ( rows ) table = Table ( show_header = True , show_lines = True , show_footer = True , # box=rich.box.HORIZONTALS, ) table . add_column ( \"path\" ) table . add_column ( \"module\" ) table . add_column ( \"params\" ) if call_info is not None : table . add_column ( \"inputs\" ) table . add_column ( \"outputs\" ) for tree_part_type in tree_part_types : type_name = tree_part_type . __name__ if type_name . startswith ( \"_\" ): type_name = type_name [ 1 :] table . add_column ( type_name ) for row in rows [: - 1 ]: table . add_row ( * row ) table . columns [ n_non_treepart_cols ] . footer = Text . from_markup ( rows [ - 1 ][ n_non_treepart_cols ], justify = \"right\" ) for i in range ( len ( tree_part_types )): table . columns [ n_non_treepart_cols + 1 + i ] . footer = rows [ - 1 ][ n_non_treepart_cols + 1 + i ] table . caption_style = \"bold\" table . caption = \" \\n Total Parameters: \" + utils . _format_obj_size ( self , add_padding = False ) return utils . _get_rich_repr ( table )","title":"tabulate()"},{"location":"api/KeySeq/#treex.key_seq.KeySeq.to_dict","text":"to_dict is a wrapper over treeo.to_dict that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True type_info bool If True , type information is included. False field_info bool If True , field information is included. False Returns: Type Description Any A dict representation of the object. Source code in treex/key_seq.py def to_dict ( self , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : \"\"\" `to_dict` is a wrapper over `treeo.to_dict` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. type_info: If `True`, type information is included. field_info: If `True`, field information is included. Returns: A dict representation of the object. \"\"\" return api . to_dict ( self , private_fields = private_fields , static_fields = static_fields , type_info = type_info , field_info = field_info , )","title":"to_dict()"},{"location":"api/KeySeq/#treex.key_seq.KeySeq.to_string","text":"to_string is a wrapper over treeo.to_string that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True color bool If True , color is included. False Returns: Type Description str A string representation of the object. Source code in treex/key_seq.py def to_string ( self : A , * , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" `to_string` is a wrapper over `treeo.to_string` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. color: If `True`, color is included. Returns: A string representation of the object. \"\"\" return api . to_string ( self , private_fields = private_fields , static_fields = static_fields , color = color , )","title":"to_string()"},{"location":"api/KeySeq/#treex.key_seq.KeySeq.train","text":"Creates a new module with the same structure, but with Module.training set to the given value. Parameters: Name Type Description Default mode bool The new training mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module in with the training mode is set to the given value, if inplace is True then self is returned. Source code in treex/key_seq.py def train ( self : T , mode : bool = True , inplace : bool = False ) -> T : \"\"\" Creates a new module with the same structure, but with `Module.training` set to the given value. Arguments: mode: The new training mode. inplace: Whether to update the module inplace. Returns: The new module in with the training mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_training ( tree ): if isinstance ( tree , Treex ) and hasattr ( tree , \"_training\" ): tree . _training = mode return to . apply ( set_training , self , inplace = inplace )","title":"train()"},{"location":"api/KeySeq/#treex.key_seq.KeySeq.unfreeze","text":"Creates a new module with .frozen set to False, equivalent to calling freeze(False) . Parameters: Name Type Description Default inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module with .frozen set to False, if inplace is True then self is returned. Source code in treex/key_seq.py def unfreeze ( self : T , inplace : bool = False ) -> T : \"\"\" Creates a new module with `.frozen` set to False, equivalent to calling `freeze(False)`. Arguments: inplace: Whether to update the module inplace. Returns: The new module with `.frozen` set to False, if `inplace` is `True` then `self` is returned. \"\"\" return self . freeze ( False , inplace = inplace )","title":"unfreeze()"},{"location":"api/KindMixin/","text":"treex.KindMixin","title":"KindMixin"},{"location":"api/KindMixin/#treexkindmixin","text":"","title":"treex.KindMixin"},{"location":"api/Lambda/","text":"treex.Lambda A Module that applies a pure function to its input. first_run : bool inherited property readonly Returns: Type Description bool True if its currently the first run of a compact method. __class__ inherited __base__ inherited __base__ inherited Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()). __instancecheck__ ( cls , instance ) special Override for isinstance(instance, cls). Source code in treex/nn/sequential.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance ) __new__ ( mcls , name , bases , namespace , ** kwargs ) special staticmethod Create and return a new object. See help(type) for accurate signature. Source code in treex/nn/sequential.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls __subclasscheck__ ( cls , subclass ) special Override for issubclass(subclass, cls). Source code in treex/nn/sequential.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass ) register ( cls , subclass ) Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/sequential.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) register ( cls , subclass ) inherited Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/sequential.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) register ( cls , subclass ) inherited Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/sequential.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) __call__ ( self , x ) special Parameters: Name Type Description Default x ndarray The input to the function. required Returns: Type Description ndarray The output of the function. Source code in treex/nn/sequential.py def __call__ ( self , x : jnp . ndarray ) -> jnp . ndarray : \"\"\" Arguments: x: The input to the function. Returns: The output of the function. \"\"\" return self . f ( x ) __init__ ( self , f ) special Parameters: Name Type Description Default f Callable[[jax._src.numpy.lax_numpy.ndarray], jax._src.numpy.lax_numpy.ndarray] A function to apply to the input. required Source code in treex/nn/sequential.py def __init__ ( self , f : tp . Callable [[ jnp . ndarray ], jnp . ndarray ]): \"\"\" Arguments: f: A function to apply to the input. \"\"\" self . f = f self . f = f apply ( self , f , * rest , * , inplace = False ) inherited apply is a wrapper over treeo.apply that passes self as the second argument. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treex/nn/sequential.py def apply ( self : A , f : tp . Callable [ ... , None ], * rest : A , inplace : bool = False ) -> A : \"\"\" `apply` is a wrapper over `treeo.apply` that passes `self` as the second argument. Arguments: f: The function to apply. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" return api . apply ( f , self , * rest , inplace = inplace ) batch_stats ( self , * filters ) inherited Returns a copy of the Module with only tx.BatchStat TreeParts, alias for filter(tx.BatchStat) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/sequential.py def batch_stats ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.BatchStat TreeParts, alias for `filter(tx.BatchStat)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . BatchStat , * filters ) check_metadata_updates ( self ) inherited Checks for new fields, if found, adds them to the metadata. Source code in treex/nn/sequential.py def check_metadata_updates ( self ): \"\"\" Checks for new fields, if found, adds them to the metadata. \"\"\" with _CONTEXT . update ( flatten_mode = FlattenMode . all_fields ): jax . tree_flatten ( self ) copy ( self ) inherited copy is a wrapper over treeo.copy that passes self as the first argument. Source code in treex/nn/sequential.py def copy ( self : A ) -> A : \"\"\" `copy` is a wrapper over `treeo.copy` that passes `self` as the first argument. \"\"\" return tree_m . copy ( self ) eval ( self , inplace = False ) inherited Creates a new module with the training mode set to False, equivalent to calling train(False) . Returns: Type Description ~T The new module with the training mode set to False. Source code in treex/nn/sequential.py def eval ( self : T , inplace : bool = False ) -> T : \"\"\" Creates a new module with the training mode set to False, equivalent to calling `train(False)`. Returns: The new module with the training mode set to False. \"\"\" return self . train ( False , inplace = inplace ) filter ( self , * filters , * , inplace = False , flatten_mode = None ) inherited filter is a wrapper over treeo.filter that passes self as the first argument. Parameters: Name Type Description Default *filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treex/nn/sequential.py def filter ( self : A , * filters : api . Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ) -> A : \"\"\" `filter` is a wrapper over `treeo.filter` that passes `self` as the first argument. Arguments: *filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" return api . filter ( self , * filters , inplace = inplace , flatten_mode = flatten_mode ) freeze ( self , mode = True , inplace = False ) inherited Creates a new module with the same structure, but with Module.frozen set to the given value. Parameters: Name Type Description Default mode bool The new frozen mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module in with the frozen mode is set to the given value, if inplace is True then self is returned. Source code in treex/nn/sequential.py def freeze ( self : T , mode : bool = True , inplace : bool = False ) -> T : \"\"\" Creates a new module with the same structure, but with `Module.frozen` set to the given value. Arguments: mode: The new `frozen` mode. inplace: Whether to update the module inplace. Returns: The new module in with the `frozen` mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_frozen ( tree ): if isinstance ( tree , Treex ) and hasattr ( tree , \"_frozen\" ): tree . _frozen = mode return to . apply ( set_frozen , self , inplace = inplace ) get_field ( self , field_name , initializer ) inherited A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: The field must be declared in the class definition. The method can only be called inside a compact context. Parameters: Name Type Description Default field_name str The name of the field to get. required initializer Callable[[], ~A] The function to initialize the field if it does not exist. required Returns: Type Description ~A The field value. Source code in treex/nn/sequential.py def get_field ( self , field_name : str , initializer : tp . Callable [[], A ], ) -> A : \"\"\" A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: * The field must be declared in the class definition. * The method can only be called inside a `compact` context. Arguments: field_name: The name of the field to get. initializer: The function to initialize the field if it does not exist. Returns: The field value. \"\"\" value : A if field_name not in self . _field_metadata : raise ValueError ( f \"Metadata for field ' { field_name } ' does not exist.\" ) if field_name in vars ( self ): value = getattr ( self , field_name ) else : if tree_m . _COMPACT_CONTEXT . in_compact and not self . first_run : raise RuntimeError ( f \"Trying to initialize field ' { field_name } ' after the first run of `compact`.\" ) value = initializer () setattr ( self , field_name , value ) return value init ( self , key , inputs =< treeo . types . Missing object at 0x7f29ce5c9220 > , call_method = '__call__' , * , inplace = False , _set_initialize = True ) inherited Method version of tx.init , it applies self as first argument. init creates a new module with the same structure, but with its fields initialized given a seed key . The following procedure is used: The input key is split and iteratively updated before passing a derived value to any process that requires initialization. Initializer s are called and applied to the module first. Module.rng_init methods are called last. Parameters: Name Type Description Default key Union[int, jax._src.numpy.lax_numpy.ndarray] The seed to use for initialization. required Returns: Type Description ~M The new module with the fields initialized. Source code in treex/nn/sequential.py def init ( self : M , key : tp . Union [ int , jnp . ndarray ], inputs : types . InputLike = to . MISSING , call_method : str = \"__call__\" , * , inplace : bool = False , _set_initialize : bool = True , ) -> M : \"\"\" Method version of `tx.init`, it applies `self` as first argument. `init` creates a new module with the same structure, but with its fields initialized given a seed `key`. The following procedure is used: 1. The input `key` is split and iteratively updated before passing a derived value to any process that requires initialization. 2. `Initializer`s are called and applied to the module first. 3. `Module.rng_init` methods are called last. Arguments: key: The seed to use for initialization. Returns: The new module with the fields initialized. \"\"\" module = self . copy () if not inplace else self key = utils . Key ( key ) with _INIT_CONTEXT . update ( key = key , initializing = True ): module : M = module . map ( lambda initializer : ( initializer ( next_key ()) if isinstance ( initializer , types . Initializer ) else initializer ), is_leaf = lambda x : isinstance ( x , types . Initializer ), inplace = True , ) def call_rng_init ( module : Module ): if isinstance ( module , Module ) and not module . _initialized : module . rng_init () module = to . apply ( call_rng_init , module , inplace = True ) if inputs is not to . MISSING : inputs = types . Inputs . from_value ( inputs ) method = getattr ( module , call_method ) method ( * inputs . args , ** inputs . kwargs ) if _set_initialize : def set_initialized ( module : Module ): if isinstance ( module , Module ) and not module . _initialized : module . _initialized = True module = to . apply ( set_initialized , module , inplace = True ) return module logs ( self , * filters ) inherited Returns a copy of the Module with only tx.Log TreeParts, alias for filter(tx.Log) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/sequential.py def logs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Log TreeParts, alias for `filter(tx.Log)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . Log , * filters ) loss_logs ( self , * filters ) inherited Returns a copy of the Module with only tx.Loss TreeParts, alias for filter(tx.Loss) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/sequential.py def loss_logs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Loss TreeParts, alias for `filter(tx.Loss)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . LossLog , * filters ) map ( self , f , * filters , * , inplace = False , flatten_mode = None , is_leaf = None ) inherited map is a wrapper over treeo.map that passes self as the second argument. Parameters: Name Type Description Default f Callable The function to apply to the leaves. required *filters Filter The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treex/nn/sequential.py def map ( self : A , f : tp . Callable , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , is_leaf : tp . Callable [[ tp . Any ], bool ] = None , ) -> A : \"\"\" `map` is a wrapper over `treeo.map` that passes `self` as the second argument. Arguments: f: The function to apply to the leaves. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" return api . map ( f , self , * filters , inplace = inplace , flatten_mode = flatten_mode , is_leaf = is_leaf , ) merge ( self , other , * rest , * , inplace = False , flatten_mode = None , ignore_static = False ) inherited merge is a wrapper over treeo.merge that passes self as the first argument. Parameters: Name Type Description Default other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the merged values. If inplace is True , obj is returned. Source code in treex/nn/sequential.py def merge ( self : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" `merge` is a wrapper over `treeo.merge` that passes `self` as the first argument. Arguments: other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the merged values. If `inplace` is `True`, `obj` is returned. \"\"\" return api . merge ( self , other , * rest , inplace = inplace , flatten_mode = flatten_mode , ignore_static = ignore_static , ) metric_logs ( self , * filters ) inherited Returns a copy of the Module with only tx.Metric TreeParts, alias for filter(tx.Metric) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/sequential.py def metric_logs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Metric TreeParts, alias for `filter(tx.Metric)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . MetricLog , * filters ) model_states ( self , * filters ) inherited Returns a copy of the Module with only tx.ModelState TreeParts, alias for filter(tx.ModelState) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/sequential.py def model_states ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.ModelState TreeParts, alias for `filter(tx.ModelState)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . ModelState , * filters ) parameters ( self , * filters ) inherited Returns a copy of the Module with only tx.Parameter TreeParts, alias for filter(tx.Parameter) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/sequential.py def parameters ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Parameter TreeParts, alias for `filter(tx.Parameter)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . Parameter , * filters ) rngs ( self , * filters ) inherited Returns a copy of the Module with only tx.Rng TreeParts, alias for filter(tx.Rng) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/sequential.py def rngs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Rng TreeParts, alias for `filter(tx.Rng)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . Rng , * filters ) states ( self , * filters ) inherited Returns a copy of the Module with only tx.State TreeParts, alias for filter(tx.State) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/sequential.py def states ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.State TreeParts, alias for `filter(tx.State)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . State , * filters ) tabulate ( self , inputs =< treeo . types . Missing object at 0x7f29ce5c9220 > , depth =- 1 , signature = False , param_types = True ) inherited Returns a tabular representation of the module. Parameters: Name Type Description Default depth int The maximum depth of the representation in terms of nested Modules, -1 means no limit. -1 signature bool Whether to show the signature of the Module. False param_types bool Whether to show the types of the parameters. True Returns: Type Description str A string containing the tabular representation. Source code in treex/nn/sequential.py def tabulate ( self , inputs : tp . Union [ types . InputLike , to . Missing ] = to . MISSING , depth : int = - 1 , signature : bool = False , param_types : bool = True , ) -> str : \"\"\" Returns a tabular representation of the module. Arguments: depth: The maximum depth of the representation in terms of nested Modules, -1 means no limit. signature: Whether to show the signature of the Module. param_types: Whether to show the types of the parameters. Returns: A string containing the tabular representation. \"\"\" self = to . copy ( self ) if inputs is not to . MISSING : inputs = types . Inputs . from_value ( inputs ) if not isinstance ( self , tp . Callable ): raise TypeError ( \"`inputs` can only be specified if the module is a callable.\" ) with contexts . _Context ( call_info = {}): # call using self to preserve references def eval_call ( args , kwargs ): assert isinstance ( self , tp . Callable ) return self ( * args , ** kwargs ) jax . eval_shape ( eval_call , inputs . args , inputs . kwargs , ) call_info = contexts . _CONTEXT . call_info else : call_info = None with to . add_field_info (): flat : tp . List [ to . FieldInfo ] flat , _ = jax . tree_flatten ( self ) tree_part_types : tp . Tuple [ tp . Type [ types . TreePart ], ... ] = tuple ( { field_info . kind for field_info in flat if utils . _generic_issubclass ( field_info . kind , types . TreePart ) } ) path = () rows = list ( utils . _get_tabulate_rows ( path , self , depth , tree_part_types , signature , param_types ) ) modules = [ row [ 0 ] for row in rows ] rows = [ row [ 1 :] for row in rows ] if call_info is not None : for module , row in zip ( modules , rows ): if module in call_info : inputs , outputs = call_info [ module ] simplified_inputs = ( inputs . args [ 0 ] if len ( inputs . kwargs ) == 0 and len ( inputs . args ) == 1 else inputs . kwargs if len ( inputs . kwargs ) == 0 else inputs . kwargs if len ( inputs . args ) == 0 else ( inputs . args , inputs . kwargs ) ) inputs_repr = utils . _format_param_tree ( simplified_inputs ) outputs_repr = utils . _format_param_tree ( outputs ) else : inputs_repr = \"\" outputs_repr = \"\" row . insert ( 3 , outputs_repr ) row . insert ( 3 , inputs_repr ) n_non_treepart_cols = 2 if call_info is None else 4 rows [ 0 ][ 0 ] = \"*\" rows . append ( [ \"\" ] * n_non_treepart_cols + [ \"Total:\" ] + [ utils . _format_obj_size ( self . filter ( kind ), add_padding = True ) for kind in tree_part_types ] ) utils . _add_padding ( rows ) table = Table ( show_header = True , show_lines = True , show_footer = True , # box=rich.box.HORIZONTALS, ) table . add_column ( \"path\" ) table . add_column ( \"module\" ) table . add_column ( \"params\" ) if call_info is not None : table . add_column ( \"inputs\" ) table . add_column ( \"outputs\" ) for tree_part_type in tree_part_types : type_name = tree_part_type . __name__ if type_name . startswith ( \"_\" ): type_name = type_name [ 1 :] table . add_column ( type_name ) for row in rows [: - 1 ]: table . add_row ( * row ) table . columns [ n_non_treepart_cols ] . footer = Text . from_markup ( rows [ - 1 ][ n_non_treepart_cols ], justify = \"right\" ) for i in range ( len ( tree_part_types )): table . columns [ n_non_treepart_cols + 1 + i ] . footer = rows [ - 1 ][ n_non_treepart_cols + 1 + i ] table . caption_style = \"bold\" table . caption = \" \\n Total Parameters: \" + utils . _format_obj_size ( self , add_padding = False ) return utils . _get_rich_repr ( table ) to_dict ( self , * , private_fields = False , static_fields = True , type_info = False , field_info = False ) inherited to_dict is a wrapper over treeo.to_dict that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True type_info bool If True , type information is included. False field_info bool If True , field information is included. False Returns: Type Description Any A dict representation of the object. Source code in treex/nn/sequential.py def to_dict ( self , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : \"\"\" `to_dict` is a wrapper over `treeo.to_dict` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. type_info: If `True`, type information is included. field_info: If `True`, field information is included. Returns: A dict representation of the object. \"\"\" return api . to_dict ( self , private_fields = private_fields , static_fields = static_fields , type_info = type_info , field_info = field_info , ) to_string ( self , * , private_fields = False , static_fields = True , color = False ) inherited to_string is a wrapper over treeo.to_string that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True color bool If True , color is included. False Returns: Type Description str A string representation of the object. Source code in treex/nn/sequential.py def to_string ( self : A , * , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" `to_string` is a wrapper over `treeo.to_string` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. color: If `True`, color is included. Returns: A string representation of the object. \"\"\" return api . to_string ( self , private_fields = private_fields , static_fields = static_fields , color = color , ) train ( self , mode = True , inplace = False ) inherited Creates a new module with the same structure, but with Module.training set to the given value. Parameters: Name Type Description Default mode bool The new training mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module in with the training mode is set to the given value, if inplace is True then self is returned. Source code in treex/nn/sequential.py def train ( self : T , mode : bool = True , inplace : bool = False ) -> T : \"\"\" Creates a new module with the same structure, but with `Module.training` set to the given value. Arguments: mode: The new training mode. inplace: Whether to update the module inplace. Returns: The new module in with the training mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_training ( tree ): if isinstance ( tree , Treex ) and hasattr ( tree , \"_training\" ): tree . _training = mode return to . apply ( set_training , self , inplace = inplace ) unfreeze ( self , inplace = False ) inherited Creates a new module with .frozen set to False, equivalent to calling freeze(False) . Parameters: Name Type Description Default inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module with .frozen set to False, if inplace is True then self is returned. Source code in treex/nn/sequential.py def unfreeze ( self : T , inplace : bool = False ) -> T : \"\"\" Creates a new module with `.frozen` set to False, equivalent to calling `freeze(False)`. Arguments: inplace: Whether to update the module inplace. Returns: The new module with `.frozen` set to False, if `inplace` is `True` then `self` is returned. \"\"\" return self . freeze ( False , inplace = inplace )","title":"Lambda"},{"location":"api/Lambda/#treexlambda","text":"A Module that applies a pure function to its input.","title":"treex.Lambda"},{"location":"api/Lambda/#treex.nn.sequential.Lambda.first_run","text":"Returns: Type Description bool True if its currently the first run of a compact method.","title":"first_run"},{"location":"api/Lambda/#treex.nn.sequential.Lambda.__class__","text":"","title":"__class__"},{"location":"api/Lambda/#treex.nn.sequential.Lambda.__class__.__base__","text":"","title":"__base__"},{"location":"api/Lambda/#treex.nn.sequential.Lambda.__class__.__base__.__base__","text":"Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()).","title":"__base__"},{"location":"api/Lambda/#treex.nn.sequential.Lambda.__class__.__base__.__base__.__instancecheck__","text":"Override for isinstance(instance, cls). Source code in treex/nn/sequential.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance )","title":"__instancecheck__()"},{"location":"api/Lambda/#treex.nn.sequential.Lambda.__class__.__base__.__base__.__new__","text":"Create and return a new object. See help(type) for accurate signature. Source code in treex/nn/sequential.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls","title":"__new__()"},{"location":"api/Lambda/#treex.nn.sequential.Lambda.__class__.__base__.__base__.__subclasscheck__","text":"Override for issubclass(subclass, cls). Source code in treex/nn/sequential.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass )","title":"__subclasscheck__()"},{"location":"api/Lambda/#treex.nn.sequential.Lambda.__class__.__base__.__base__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/sequential.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/Lambda/#treex.nn.sequential.Lambda.__class__.__base__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/sequential.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/Lambda/#treex.nn.sequential.Lambda.__class__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/sequential.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/Lambda/#treex.nn.sequential.Lambda.__call__","text":"Parameters: Name Type Description Default x ndarray The input to the function. required Returns: Type Description ndarray The output of the function. Source code in treex/nn/sequential.py def __call__ ( self , x : jnp . ndarray ) -> jnp . ndarray : \"\"\" Arguments: x: The input to the function. Returns: The output of the function. \"\"\" return self . f ( x )","title":"__call__()"},{"location":"api/Lambda/#treex.nn.sequential.Lambda.__init__","text":"Parameters: Name Type Description Default f Callable[[jax._src.numpy.lax_numpy.ndarray], jax._src.numpy.lax_numpy.ndarray] A function to apply to the input. required Source code in treex/nn/sequential.py def __init__ ( self , f : tp . Callable [[ jnp . ndarray ], jnp . ndarray ]): \"\"\" Arguments: f: A function to apply to the input. \"\"\" self . f = f self . f = f","title":"__init__()"},{"location":"api/Lambda/#treex.nn.sequential.Lambda.apply","text":"apply is a wrapper over treeo.apply that passes self as the second argument. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treex/nn/sequential.py def apply ( self : A , f : tp . Callable [ ... , None ], * rest : A , inplace : bool = False ) -> A : \"\"\" `apply` is a wrapper over `treeo.apply` that passes `self` as the second argument. Arguments: f: The function to apply. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" return api . apply ( f , self , * rest , inplace = inplace )","title":"apply()"},{"location":"api/Lambda/#treex.nn.sequential.Lambda.batch_stats","text":"Returns a copy of the Module with only tx.BatchStat TreeParts, alias for filter(tx.BatchStat) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/sequential.py def batch_stats ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.BatchStat TreeParts, alias for `filter(tx.BatchStat)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . BatchStat , * filters )","title":"batch_stats()"},{"location":"api/Lambda/#treex.nn.sequential.Lambda.check_metadata_updates","text":"Checks for new fields, if found, adds them to the metadata. Source code in treex/nn/sequential.py def check_metadata_updates ( self ): \"\"\" Checks for new fields, if found, adds them to the metadata. \"\"\" with _CONTEXT . update ( flatten_mode = FlattenMode . all_fields ): jax . tree_flatten ( self )","title":"check_metadata_updates()"},{"location":"api/Lambda/#treex.nn.sequential.Lambda.copy","text":"copy is a wrapper over treeo.copy that passes self as the first argument. Source code in treex/nn/sequential.py def copy ( self : A ) -> A : \"\"\" `copy` is a wrapper over `treeo.copy` that passes `self` as the first argument. \"\"\" return tree_m . copy ( self )","title":"copy()"},{"location":"api/Lambda/#treex.nn.sequential.Lambda.eval","text":"Creates a new module with the training mode set to False, equivalent to calling train(False) . Returns: Type Description ~T The new module with the training mode set to False. Source code in treex/nn/sequential.py def eval ( self : T , inplace : bool = False ) -> T : \"\"\" Creates a new module with the training mode set to False, equivalent to calling `train(False)`. Returns: The new module with the training mode set to False. \"\"\" return self . train ( False , inplace = inplace )","title":"eval()"},{"location":"api/Lambda/#treex.nn.sequential.Lambda.filter","text":"filter is a wrapper over treeo.filter that passes self as the first argument. Parameters: Name Type Description Default *filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treex/nn/sequential.py def filter ( self : A , * filters : api . Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ) -> A : \"\"\" `filter` is a wrapper over `treeo.filter` that passes `self` as the first argument. Arguments: *filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" return api . filter ( self , * filters , inplace = inplace , flatten_mode = flatten_mode )","title":"filter()"},{"location":"api/Lambda/#treex.nn.sequential.Lambda.freeze","text":"Creates a new module with the same structure, but with Module.frozen set to the given value. Parameters: Name Type Description Default mode bool The new frozen mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module in with the frozen mode is set to the given value, if inplace is True then self is returned. Source code in treex/nn/sequential.py def freeze ( self : T , mode : bool = True , inplace : bool = False ) -> T : \"\"\" Creates a new module with the same structure, but with `Module.frozen` set to the given value. Arguments: mode: The new `frozen` mode. inplace: Whether to update the module inplace. Returns: The new module in with the `frozen` mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_frozen ( tree ): if isinstance ( tree , Treex ) and hasattr ( tree , \"_frozen\" ): tree . _frozen = mode return to . apply ( set_frozen , self , inplace = inplace )","title":"freeze()"},{"location":"api/Lambda/#treex.nn.sequential.Lambda.get_field","text":"A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: The field must be declared in the class definition. The method can only be called inside a compact context. Parameters: Name Type Description Default field_name str The name of the field to get. required initializer Callable[[], ~A] The function to initialize the field if it does not exist. required Returns: Type Description ~A The field value. Source code in treex/nn/sequential.py def get_field ( self , field_name : str , initializer : tp . Callable [[], A ], ) -> A : \"\"\" A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: * The field must be declared in the class definition. * The method can only be called inside a `compact` context. Arguments: field_name: The name of the field to get. initializer: The function to initialize the field if it does not exist. Returns: The field value. \"\"\" value : A if field_name not in self . _field_metadata : raise ValueError ( f \"Metadata for field ' { field_name } ' does not exist.\" ) if field_name in vars ( self ): value = getattr ( self , field_name ) else : if tree_m . _COMPACT_CONTEXT . in_compact and not self . first_run : raise RuntimeError ( f \"Trying to initialize field ' { field_name } ' after the first run of `compact`.\" ) value = initializer () setattr ( self , field_name , value ) return value","title":"get_field()"},{"location":"api/Lambda/#treex.nn.sequential.Lambda.init","text":"Method version of tx.init , it applies self as first argument. init creates a new module with the same structure, but with its fields initialized given a seed key . The following procedure is used: The input key is split and iteratively updated before passing a derived value to any process that requires initialization. Initializer s are called and applied to the module first. Module.rng_init methods are called last. Parameters: Name Type Description Default key Union[int, jax._src.numpy.lax_numpy.ndarray] The seed to use for initialization. required Returns: Type Description ~M The new module with the fields initialized. Source code in treex/nn/sequential.py def init ( self : M , key : tp . Union [ int , jnp . ndarray ], inputs : types . InputLike = to . MISSING , call_method : str = \"__call__\" , * , inplace : bool = False , _set_initialize : bool = True , ) -> M : \"\"\" Method version of `tx.init`, it applies `self` as first argument. `init` creates a new module with the same structure, but with its fields initialized given a seed `key`. The following procedure is used: 1. The input `key` is split and iteratively updated before passing a derived value to any process that requires initialization. 2. `Initializer`s are called and applied to the module first. 3. `Module.rng_init` methods are called last. Arguments: key: The seed to use for initialization. Returns: The new module with the fields initialized. \"\"\" module = self . copy () if not inplace else self key = utils . Key ( key ) with _INIT_CONTEXT . update ( key = key , initializing = True ): module : M = module . map ( lambda initializer : ( initializer ( next_key ()) if isinstance ( initializer , types . Initializer ) else initializer ), is_leaf = lambda x : isinstance ( x , types . Initializer ), inplace = True , ) def call_rng_init ( module : Module ): if isinstance ( module , Module ) and not module . _initialized : module . rng_init () module = to . apply ( call_rng_init , module , inplace = True ) if inputs is not to . MISSING : inputs = types . Inputs . from_value ( inputs ) method = getattr ( module , call_method ) method ( * inputs . args , ** inputs . kwargs ) if _set_initialize : def set_initialized ( module : Module ): if isinstance ( module , Module ) and not module . _initialized : module . _initialized = True module = to . apply ( set_initialized , module , inplace = True ) return module","title":"init()"},{"location":"api/Lambda/#treex.nn.sequential.Lambda.logs","text":"Returns a copy of the Module with only tx.Log TreeParts, alias for filter(tx.Log) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/sequential.py def logs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Log TreeParts, alias for `filter(tx.Log)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . Log , * filters )","title":"logs()"},{"location":"api/Lambda/#treex.nn.sequential.Lambda.loss_logs","text":"Returns a copy of the Module with only tx.Loss TreeParts, alias for filter(tx.Loss) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/sequential.py def loss_logs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Loss TreeParts, alias for `filter(tx.Loss)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . LossLog , * filters )","title":"loss_logs()"},{"location":"api/Lambda/#treex.nn.sequential.Lambda.map","text":"map is a wrapper over treeo.map that passes self as the second argument. Parameters: Name Type Description Default f Callable The function to apply to the leaves. required *filters Filter The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treex/nn/sequential.py def map ( self : A , f : tp . Callable , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , is_leaf : tp . Callable [[ tp . Any ], bool ] = None , ) -> A : \"\"\" `map` is a wrapper over `treeo.map` that passes `self` as the second argument. Arguments: f: The function to apply to the leaves. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" return api . map ( f , self , * filters , inplace = inplace , flatten_mode = flatten_mode , is_leaf = is_leaf , )","title":"map()"},{"location":"api/Lambda/#treex.nn.sequential.Lambda.merge","text":"merge is a wrapper over treeo.merge that passes self as the first argument. Parameters: Name Type Description Default other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the merged values. If inplace is True , obj is returned. Source code in treex/nn/sequential.py def merge ( self : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" `merge` is a wrapper over `treeo.merge` that passes `self` as the first argument. Arguments: other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the merged values. If `inplace` is `True`, `obj` is returned. \"\"\" return api . merge ( self , other , * rest , inplace = inplace , flatten_mode = flatten_mode , ignore_static = ignore_static , )","title":"merge()"},{"location":"api/Lambda/#treex.nn.sequential.Lambda.metric_logs","text":"Returns a copy of the Module with only tx.Metric TreeParts, alias for filter(tx.Metric) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/sequential.py def metric_logs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Metric TreeParts, alias for `filter(tx.Metric)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . MetricLog , * filters )","title":"metric_logs()"},{"location":"api/Lambda/#treex.nn.sequential.Lambda.model_states","text":"Returns a copy of the Module with only tx.ModelState TreeParts, alias for filter(tx.ModelState) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/sequential.py def model_states ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.ModelState TreeParts, alias for `filter(tx.ModelState)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . ModelState , * filters )","title":"model_states()"},{"location":"api/Lambda/#treex.nn.sequential.Lambda.parameters","text":"Returns a copy of the Module with only tx.Parameter TreeParts, alias for filter(tx.Parameter) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/sequential.py def parameters ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Parameter TreeParts, alias for `filter(tx.Parameter)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . Parameter , * filters )","title":"parameters()"},{"location":"api/Lambda/#treex.nn.sequential.Lambda.rngs","text":"Returns a copy of the Module with only tx.Rng TreeParts, alias for filter(tx.Rng) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/sequential.py def rngs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Rng TreeParts, alias for `filter(tx.Rng)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . Rng , * filters )","title":"rngs()"},{"location":"api/Lambda/#treex.nn.sequential.Lambda.states","text":"Returns a copy of the Module with only tx.State TreeParts, alias for filter(tx.State) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/sequential.py def states ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.State TreeParts, alias for `filter(tx.State)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . State , * filters )","title":"states()"},{"location":"api/Lambda/#treex.nn.sequential.Lambda.tabulate","text":"Returns a tabular representation of the module. Parameters: Name Type Description Default depth int The maximum depth of the representation in terms of nested Modules, -1 means no limit. -1 signature bool Whether to show the signature of the Module. False param_types bool Whether to show the types of the parameters. True Returns: Type Description str A string containing the tabular representation. Source code in treex/nn/sequential.py def tabulate ( self , inputs : tp . Union [ types . InputLike , to . Missing ] = to . MISSING , depth : int = - 1 , signature : bool = False , param_types : bool = True , ) -> str : \"\"\" Returns a tabular representation of the module. Arguments: depth: The maximum depth of the representation in terms of nested Modules, -1 means no limit. signature: Whether to show the signature of the Module. param_types: Whether to show the types of the parameters. Returns: A string containing the tabular representation. \"\"\" self = to . copy ( self ) if inputs is not to . MISSING : inputs = types . Inputs . from_value ( inputs ) if not isinstance ( self , tp . Callable ): raise TypeError ( \"`inputs` can only be specified if the module is a callable.\" ) with contexts . _Context ( call_info = {}): # call using self to preserve references def eval_call ( args , kwargs ): assert isinstance ( self , tp . Callable ) return self ( * args , ** kwargs ) jax . eval_shape ( eval_call , inputs . args , inputs . kwargs , ) call_info = contexts . _CONTEXT . call_info else : call_info = None with to . add_field_info (): flat : tp . List [ to . FieldInfo ] flat , _ = jax . tree_flatten ( self ) tree_part_types : tp . Tuple [ tp . Type [ types . TreePart ], ... ] = tuple ( { field_info . kind for field_info in flat if utils . _generic_issubclass ( field_info . kind , types . TreePart ) } ) path = () rows = list ( utils . _get_tabulate_rows ( path , self , depth , tree_part_types , signature , param_types ) ) modules = [ row [ 0 ] for row in rows ] rows = [ row [ 1 :] for row in rows ] if call_info is not None : for module , row in zip ( modules , rows ): if module in call_info : inputs , outputs = call_info [ module ] simplified_inputs = ( inputs . args [ 0 ] if len ( inputs . kwargs ) == 0 and len ( inputs . args ) == 1 else inputs . kwargs if len ( inputs . kwargs ) == 0 else inputs . kwargs if len ( inputs . args ) == 0 else ( inputs . args , inputs . kwargs ) ) inputs_repr = utils . _format_param_tree ( simplified_inputs ) outputs_repr = utils . _format_param_tree ( outputs ) else : inputs_repr = \"\" outputs_repr = \"\" row . insert ( 3 , outputs_repr ) row . insert ( 3 , inputs_repr ) n_non_treepart_cols = 2 if call_info is None else 4 rows [ 0 ][ 0 ] = \"*\" rows . append ( [ \"\" ] * n_non_treepart_cols + [ \"Total:\" ] + [ utils . _format_obj_size ( self . filter ( kind ), add_padding = True ) for kind in tree_part_types ] ) utils . _add_padding ( rows ) table = Table ( show_header = True , show_lines = True , show_footer = True , # box=rich.box.HORIZONTALS, ) table . add_column ( \"path\" ) table . add_column ( \"module\" ) table . add_column ( \"params\" ) if call_info is not None : table . add_column ( \"inputs\" ) table . add_column ( \"outputs\" ) for tree_part_type in tree_part_types : type_name = tree_part_type . __name__ if type_name . startswith ( \"_\" ): type_name = type_name [ 1 :] table . add_column ( type_name ) for row in rows [: - 1 ]: table . add_row ( * row ) table . columns [ n_non_treepart_cols ] . footer = Text . from_markup ( rows [ - 1 ][ n_non_treepart_cols ], justify = \"right\" ) for i in range ( len ( tree_part_types )): table . columns [ n_non_treepart_cols + 1 + i ] . footer = rows [ - 1 ][ n_non_treepart_cols + 1 + i ] table . caption_style = \"bold\" table . caption = \" \\n Total Parameters: \" + utils . _format_obj_size ( self , add_padding = False ) return utils . _get_rich_repr ( table )","title":"tabulate()"},{"location":"api/Lambda/#treex.nn.sequential.Lambda.to_dict","text":"to_dict is a wrapper over treeo.to_dict that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True type_info bool If True , type information is included. False field_info bool If True , field information is included. False Returns: Type Description Any A dict representation of the object. Source code in treex/nn/sequential.py def to_dict ( self , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : \"\"\" `to_dict` is a wrapper over `treeo.to_dict` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. type_info: If `True`, type information is included. field_info: If `True`, field information is included. Returns: A dict representation of the object. \"\"\" return api . to_dict ( self , private_fields = private_fields , static_fields = static_fields , type_info = type_info , field_info = field_info , )","title":"to_dict()"},{"location":"api/Lambda/#treex.nn.sequential.Lambda.to_string","text":"to_string is a wrapper over treeo.to_string that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True color bool If True , color is included. False Returns: Type Description str A string representation of the object. Source code in treex/nn/sequential.py def to_string ( self : A , * , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" `to_string` is a wrapper over `treeo.to_string` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. color: If `True`, color is included. Returns: A string representation of the object. \"\"\" return api . to_string ( self , private_fields = private_fields , static_fields = static_fields , color = color , )","title":"to_string()"},{"location":"api/Lambda/#treex.nn.sequential.Lambda.train","text":"Creates a new module with the same structure, but with Module.training set to the given value. Parameters: Name Type Description Default mode bool The new training mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module in with the training mode is set to the given value, if inplace is True then self is returned. Source code in treex/nn/sequential.py def train ( self : T , mode : bool = True , inplace : bool = False ) -> T : \"\"\" Creates a new module with the same structure, but with `Module.training` set to the given value. Arguments: mode: The new training mode. inplace: Whether to update the module inplace. Returns: The new module in with the training mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_training ( tree ): if isinstance ( tree , Treex ) and hasattr ( tree , \"_training\" ): tree . _training = mode return to . apply ( set_training , self , inplace = inplace )","title":"train()"},{"location":"api/Lambda/#treex.nn.sequential.Lambda.unfreeze","text":"Creates a new module with .frozen set to False, equivalent to calling freeze(False) . Parameters: Name Type Description Default inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module with .frozen set to False, if inplace is True then self is returned. Source code in treex/nn/sequential.py def unfreeze ( self : T , inplace : bool = False ) -> T : \"\"\" Creates a new module with `.frozen` set to False, equivalent to calling `freeze(False)`. Arguments: inplace: Whether to update the module inplace. Returns: The new module with `.frozen` set to False, if `inplace` is `True` then `self` is returned. \"\"\" return self . freeze ( False , inplace = inplace )","title":"unfreeze()"},{"location":"api/Linear/","text":"treex.Linear A linear transformation applied over the last dimension of the input. Linear is implemented as a wrapper over flax.linen.Dense , its constructor arguments accept almost the same arguments including any Flax artifacts such as initializers. Main differences: receives features_in as a first argument since shapes must be statically known. features argument is renamed to features_out . first_run : bool inherited property readonly Returns: Type Description bool True if its currently the first run of a compact method. __class__ inherited __base__ inherited __base__ inherited Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()). __instancecheck__ ( cls , instance ) special Override for isinstance(instance, cls). Source code in treex/nn/linear.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance ) __new__ ( mcls , name , bases , namespace , ** kwargs ) special staticmethod Create and return a new object. See help(type) for accurate signature. Source code in treex/nn/linear.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls __subclasscheck__ ( cls , subclass ) special Override for issubclass(subclass, cls). Source code in treex/nn/linear.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass ) register ( cls , subclass ) Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/linear.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) register ( cls , subclass ) inherited Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/linear.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) register ( cls , subclass ) inherited Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/linear.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) __call__ ( self , x ) special Applies a linear transformation to the inputs along the last dimension. Parameters: Name Type Description Default x ndarray The nd-array to be transformed. required Returns: Type Description ndarray The transformed input. Source code in treex/nn/linear.py def __call__ ( self , x : jnp . ndarray ) -> jnp . ndarray : \"\"\"Applies a linear transformation to the inputs along the last dimension. Arguments: x: The nd-array to be transformed. Returns: The transformed input. \"\"\" if self . initializing (): variables = self . module . init ({ \"params\" : next_key ()}, x ) # Extract collections params = variables [ \"params\" ] . unfreeze () self . kernel = params [ \"kernel\" ] if self . use_bias : self . bias = params [ \"bias\" ] assert self . kernel is not None params = { \"kernel\" : self . kernel } if self . use_bias : assert self . bias is not None params [ \"bias\" ] = self . bias output = self . module . apply ({ \"params\" : params }, x ) return tp . cast ( jnp . ndarray , output ) __init__ ( self , features_out , * , use_bias = True , dtype =< class ' jax . _src . numpy . lax_numpy . float32 '>, precision=None, kernel_init=<function variance_scaling.<locals>.init at 0x7f29cde939d0>, bias_init=<function zeros at 0x7f29d70075e0>, name=None) special Parameters: Name Type Description Default features_in the number of input features. required features_out int the number of output features. required use_bias bool whether to add a bias to the output (default: True). True dtype Any the dtype of the computation (default: float32). <class 'jax._src.numpy.lax_numpy.float32'> precision Any numerical precision of the computation see jax.lax.Precision for details. None kernel_init Callable[[Any, Iterable[int], Any], Any] initializer function for the weight matrix. <function variance_scaling.<locals>.init at 0x7f29cde939d0> bias_init Callable[[Any, Iterable[int], Any], Any] initializer function for the bias. <function zeros at 0x7f29d70075e0> Source code in treex/nn/linear.py def __init__ ( self , features_out : int , * , use_bias : bool = True , dtype : tp . Any = jnp . float32 , precision : tp . Any = None , kernel_init : tp . Callable [ [ flax_module . PRNGKey , flax_module . Shape , flax_module . Dtype ], flax_module . Array , ] = flax_module . default_kernel_init , bias_init : tp . Callable [ [ flax_module . PRNGKey , flax_module . Shape , flax_module . Dtype ], flax_module . Array , ] = flax_module . zeros , name : tp . Optional [ str ] = None , ): \"\"\" Arguments: features_in: the number of input features. features_out: the number of output features. use_bias: whether to add a bias to the output (default: True). dtype: the dtype of the computation (default: float32). precision: numerical precision of the computation see `jax.lax.Precision` for details. kernel_init: initializer function for the weight matrix. bias_init: initializer function for the bias. \"\"\" super () . __init__ ( name = name ) self . features_out = features_out self . use_bias = use_bias self . dtype = dtype self . precision = precision self . kernel_init = kernel_init self . bias_init = bias_init self . kernel = None self . bias = None apply ( self , f , * rest , * , inplace = False ) inherited apply is a wrapper over treeo.apply that passes self as the second argument. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treex/nn/linear.py def apply ( self : A , f : tp . Callable [ ... , None ], * rest : A , inplace : bool = False ) -> A : \"\"\" `apply` is a wrapper over `treeo.apply` that passes `self` as the second argument. Arguments: f: The function to apply. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" return api . apply ( f , self , * rest , inplace = inplace ) batch_stats ( self , * filters ) inherited Returns a copy of the Module with only tx.BatchStat TreeParts, alias for filter(tx.BatchStat) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/linear.py def batch_stats ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.BatchStat TreeParts, alias for `filter(tx.BatchStat)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . BatchStat , * filters ) check_metadata_updates ( self ) inherited Checks for new fields, if found, adds them to the metadata. Source code in treex/nn/linear.py def check_metadata_updates ( self ): \"\"\" Checks for new fields, if found, adds them to the metadata. \"\"\" with _CONTEXT . update ( flatten_mode = FlattenMode . all_fields ): jax . tree_flatten ( self ) copy ( self ) inherited copy is a wrapper over treeo.copy that passes self as the first argument. Source code in treex/nn/linear.py def copy ( self : A ) -> A : \"\"\" `copy` is a wrapper over `treeo.copy` that passes `self` as the first argument. \"\"\" return tree_m . copy ( self ) eval ( self , inplace = False ) inherited Creates a new module with the training mode set to False, equivalent to calling train(False) . Returns: Type Description ~T The new module with the training mode set to False. Source code in treex/nn/linear.py def eval ( self : T , inplace : bool = False ) -> T : \"\"\" Creates a new module with the training mode set to False, equivalent to calling `train(False)`. Returns: The new module with the training mode set to False. \"\"\" return self . train ( False , inplace = inplace ) filter ( self , * filters , * , inplace = False , flatten_mode = None ) inherited filter is a wrapper over treeo.filter that passes self as the first argument. Parameters: Name Type Description Default *filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treex/nn/linear.py def filter ( self : A , * filters : api . Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ) -> A : \"\"\" `filter` is a wrapper over `treeo.filter` that passes `self` as the first argument. Arguments: *filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" return api . filter ( self , * filters , inplace = inplace , flatten_mode = flatten_mode ) freeze ( self , mode = True , inplace = False ) inherited Creates a new module with the same structure, but with Module.frozen set to the given value. Parameters: Name Type Description Default mode bool The new frozen mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module in with the frozen mode is set to the given value, if inplace is True then self is returned. Source code in treex/nn/linear.py def freeze ( self : T , mode : bool = True , inplace : bool = False ) -> T : \"\"\" Creates a new module with the same structure, but with `Module.frozen` set to the given value. Arguments: mode: The new `frozen` mode. inplace: Whether to update the module inplace. Returns: The new module in with the `frozen` mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_frozen ( tree ): if isinstance ( tree , Treex ) and hasattr ( tree , \"_frozen\" ): tree . _frozen = mode return to . apply ( set_frozen , self , inplace = inplace ) get_field ( self , field_name , initializer ) inherited A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: The field must be declared in the class definition. The method can only be called inside a compact context. Parameters: Name Type Description Default field_name str The name of the field to get. required initializer Callable[[], ~A] The function to initialize the field if it does not exist. required Returns: Type Description ~A The field value. Source code in treex/nn/linear.py def get_field ( self , field_name : str , initializer : tp . Callable [[], A ], ) -> A : \"\"\" A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: * The field must be declared in the class definition. * The method can only be called inside a `compact` context. Arguments: field_name: The name of the field to get. initializer: The function to initialize the field if it does not exist. Returns: The field value. \"\"\" value : A if field_name not in self . _field_metadata : raise ValueError ( f \"Metadata for field ' { field_name } ' does not exist.\" ) if field_name in vars ( self ): value = getattr ( self , field_name ) else : if tree_m . _COMPACT_CONTEXT . in_compact and not self . first_run : raise RuntimeError ( f \"Trying to initialize field ' { field_name } ' after the first run of `compact`.\" ) value = initializer () setattr ( self , field_name , value ) return value init ( self , key , inputs =< treeo . types . Missing object at 0x7f29ce5c9220 > , call_method = '__call__' , * , inplace = False , _set_initialize = True ) inherited Method version of tx.init , it applies self as first argument. init creates a new module with the same structure, but with its fields initialized given a seed key . The following procedure is used: The input key is split and iteratively updated before passing a derived value to any process that requires initialization. Initializer s are called and applied to the module first. Module.rng_init methods are called last. Parameters: Name Type Description Default key Union[int, jax._src.numpy.lax_numpy.ndarray] The seed to use for initialization. required Returns: Type Description ~M The new module with the fields initialized. Source code in treex/nn/linear.py def init ( self : M , key : tp . Union [ int , jnp . ndarray ], inputs : types . InputLike = to . MISSING , call_method : str = \"__call__\" , * , inplace : bool = False , _set_initialize : bool = True , ) -> M : \"\"\" Method version of `tx.init`, it applies `self` as first argument. `init` creates a new module with the same structure, but with its fields initialized given a seed `key`. The following procedure is used: 1. The input `key` is split and iteratively updated before passing a derived value to any process that requires initialization. 2. `Initializer`s are called and applied to the module first. 3. `Module.rng_init` methods are called last. Arguments: key: The seed to use for initialization. Returns: The new module with the fields initialized. \"\"\" module = self . copy () if not inplace else self key = utils . Key ( key ) with _INIT_CONTEXT . update ( key = key , initializing = True ): module : M = module . map ( lambda initializer : ( initializer ( next_key ()) if isinstance ( initializer , types . Initializer ) else initializer ), is_leaf = lambda x : isinstance ( x , types . Initializer ), inplace = True , ) def call_rng_init ( module : Module ): if isinstance ( module , Module ) and not module . _initialized : module . rng_init () module = to . apply ( call_rng_init , module , inplace = True ) if inputs is not to . MISSING : inputs = types . Inputs . from_value ( inputs ) method = getattr ( module , call_method ) method ( * inputs . args , ** inputs . kwargs ) if _set_initialize : def set_initialized ( module : Module ): if isinstance ( module , Module ) and not module . _initialized : module . _initialized = True module = to . apply ( set_initialized , module , inplace = True ) return module logs ( self , * filters ) inherited Returns a copy of the Module with only tx.Log TreeParts, alias for filter(tx.Log) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/linear.py def logs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Log TreeParts, alias for `filter(tx.Log)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . Log , * filters ) loss_logs ( self , * filters ) inherited Returns a copy of the Module with only tx.Loss TreeParts, alias for filter(tx.Loss) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/linear.py def loss_logs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Loss TreeParts, alias for `filter(tx.Loss)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . LossLog , * filters ) map ( self , f , * filters , * , inplace = False , flatten_mode = None , is_leaf = None ) inherited map is a wrapper over treeo.map that passes self as the second argument. Parameters: Name Type Description Default f Callable The function to apply to the leaves. required *filters Filter The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treex/nn/linear.py def map ( self : A , f : tp . Callable , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , is_leaf : tp . Callable [[ tp . Any ], bool ] = None , ) -> A : \"\"\" `map` is a wrapper over `treeo.map` that passes `self` as the second argument. Arguments: f: The function to apply to the leaves. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" return api . map ( f , self , * filters , inplace = inplace , flatten_mode = flatten_mode , is_leaf = is_leaf , ) merge ( self , other , * rest , * , inplace = False , flatten_mode = None , ignore_static = False ) inherited merge is a wrapper over treeo.merge that passes self as the first argument. Parameters: Name Type Description Default other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the merged values. If inplace is True , obj is returned. Source code in treex/nn/linear.py def merge ( self : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" `merge` is a wrapper over `treeo.merge` that passes `self` as the first argument. Arguments: other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the merged values. If `inplace` is `True`, `obj` is returned. \"\"\" return api . merge ( self , other , * rest , inplace = inplace , flatten_mode = flatten_mode , ignore_static = ignore_static , ) metric_logs ( self , * filters ) inherited Returns a copy of the Module with only tx.Metric TreeParts, alias for filter(tx.Metric) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/linear.py def metric_logs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Metric TreeParts, alias for `filter(tx.Metric)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . MetricLog , * filters ) model_states ( self , * filters ) inherited Returns a copy of the Module with only tx.ModelState TreeParts, alias for filter(tx.ModelState) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/linear.py def model_states ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.ModelState TreeParts, alias for `filter(tx.ModelState)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . ModelState , * filters ) parameters ( self , * filters ) inherited Returns a copy of the Module with only tx.Parameter TreeParts, alias for filter(tx.Parameter) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/linear.py def parameters ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Parameter TreeParts, alias for `filter(tx.Parameter)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . Parameter , * filters ) rngs ( self , * filters ) inherited Returns a copy of the Module with only tx.Rng TreeParts, alias for filter(tx.Rng) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/linear.py def rngs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Rng TreeParts, alias for `filter(tx.Rng)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . Rng , * filters ) states ( self , * filters ) inherited Returns a copy of the Module with only tx.State TreeParts, alias for filter(tx.State) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/linear.py def states ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.State TreeParts, alias for `filter(tx.State)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . State , * filters ) tabulate ( self , inputs =< treeo . types . Missing object at 0x7f29ce5c9220 > , depth =- 1 , signature = False , param_types = True ) inherited Returns a tabular representation of the module. Parameters: Name Type Description Default depth int The maximum depth of the representation in terms of nested Modules, -1 means no limit. -1 signature bool Whether to show the signature of the Module. False param_types bool Whether to show the types of the parameters. True Returns: Type Description str A string containing the tabular representation. Source code in treex/nn/linear.py def tabulate ( self , inputs : tp . Union [ types . InputLike , to . Missing ] = to . MISSING , depth : int = - 1 , signature : bool = False , param_types : bool = True , ) -> str : \"\"\" Returns a tabular representation of the module. Arguments: depth: The maximum depth of the representation in terms of nested Modules, -1 means no limit. signature: Whether to show the signature of the Module. param_types: Whether to show the types of the parameters. Returns: A string containing the tabular representation. \"\"\" self = to . copy ( self ) if inputs is not to . MISSING : inputs = types . Inputs . from_value ( inputs ) if not isinstance ( self , tp . Callable ): raise TypeError ( \"`inputs` can only be specified if the module is a callable.\" ) with contexts . _Context ( call_info = {}): # call using self to preserve references def eval_call ( args , kwargs ): assert isinstance ( self , tp . Callable ) return self ( * args , ** kwargs ) jax . eval_shape ( eval_call , inputs . args , inputs . kwargs , ) call_info = contexts . _CONTEXT . call_info else : call_info = None with to . add_field_info (): flat : tp . List [ to . FieldInfo ] flat , _ = jax . tree_flatten ( self ) tree_part_types : tp . Tuple [ tp . Type [ types . TreePart ], ... ] = tuple ( { field_info . kind for field_info in flat if utils . _generic_issubclass ( field_info . kind , types . TreePart ) } ) path = () rows = list ( utils . _get_tabulate_rows ( path , self , depth , tree_part_types , signature , param_types ) ) modules = [ row [ 0 ] for row in rows ] rows = [ row [ 1 :] for row in rows ] if call_info is not None : for module , row in zip ( modules , rows ): if module in call_info : inputs , outputs = call_info [ module ] simplified_inputs = ( inputs . args [ 0 ] if len ( inputs . kwargs ) == 0 and len ( inputs . args ) == 1 else inputs . kwargs if len ( inputs . kwargs ) == 0 else inputs . kwargs if len ( inputs . args ) == 0 else ( inputs . args , inputs . kwargs ) ) inputs_repr = utils . _format_param_tree ( simplified_inputs ) outputs_repr = utils . _format_param_tree ( outputs ) else : inputs_repr = \"\" outputs_repr = \"\" row . insert ( 3 , outputs_repr ) row . insert ( 3 , inputs_repr ) n_non_treepart_cols = 2 if call_info is None else 4 rows [ 0 ][ 0 ] = \"*\" rows . append ( [ \"\" ] * n_non_treepart_cols + [ \"Total:\" ] + [ utils . _format_obj_size ( self . filter ( kind ), add_padding = True ) for kind in tree_part_types ] ) utils . _add_padding ( rows ) table = Table ( show_header = True , show_lines = True , show_footer = True , # box=rich.box.HORIZONTALS, ) table . add_column ( \"path\" ) table . add_column ( \"module\" ) table . add_column ( \"params\" ) if call_info is not None : table . add_column ( \"inputs\" ) table . add_column ( \"outputs\" ) for tree_part_type in tree_part_types : type_name = tree_part_type . __name__ if type_name . startswith ( \"_\" ): type_name = type_name [ 1 :] table . add_column ( type_name ) for row in rows [: - 1 ]: table . add_row ( * row ) table . columns [ n_non_treepart_cols ] . footer = Text . from_markup ( rows [ - 1 ][ n_non_treepart_cols ], justify = \"right\" ) for i in range ( len ( tree_part_types )): table . columns [ n_non_treepart_cols + 1 + i ] . footer = rows [ - 1 ][ n_non_treepart_cols + 1 + i ] table . caption_style = \"bold\" table . caption = \" \\n Total Parameters: \" + utils . _format_obj_size ( self , add_padding = False ) return utils . _get_rich_repr ( table ) to_dict ( self , * , private_fields = False , static_fields = True , type_info = False , field_info = False ) inherited to_dict is a wrapper over treeo.to_dict that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True type_info bool If True , type information is included. False field_info bool If True , field information is included. False Returns: Type Description Any A dict representation of the object. Source code in treex/nn/linear.py def to_dict ( self , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : \"\"\" `to_dict` is a wrapper over `treeo.to_dict` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. type_info: If `True`, type information is included. field_info: If `True`, field information is included. Returns: A dict representation of the object. \"\"\" return api . to_dict ( self , private_fields = private_fields , static_fields = static_fields , type_info = type_info , field_info = field_info , ) to_string ( self , * , private_fields = False , static_fields = True , color = False ) inherited to_string is a wrapper over treeo.to_string that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True color bool If True , color is included. False Returns: Type Description str A string representation of the object. Source code in treex/nn/linear.py def to_string ( self : A , * , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" `to_string` is a wrapper over `treeo.to_string` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. color: If `True`, color is included. Returns: A string representation of the object. \"\"\" return api . to_string ( self , private_fields = private_fields , static_fields = static_fields , color = color , ) train ( self , mode = True , inplace = False ) inherited Creates a new module with the same structure, but with Module.training set to the given value. Parameters: Name Type Description Default mode bool The new training mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module in with the training mode is set to the given value, if inplace is True then self is returned. Source code in treex/nn/linear.py def train ( self : T , mode : bool = True , inplace : bool = False ) -> T : \"\"\" Creates a new module with the same structure, but with `Module.training` set to the given value. Arguments: mode: The new training mode. inplace: Whether to update the module inplace. Returns: The new module in with the training mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_training ( tree ): if isinstance ( tree , Treex ) and hasattr ( tree , \"_training\" ): tree . _training = mode return to . apply ( set_training , self , inplace = inplace ) unfreeze ( self , inplace = False ) inherited Creates a new module with .frozen set to False, equivalent to calling freeze(False) . Parameters: Name Type Description Default inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module with .frozen set to False, if inplace is True then self is returned. Source code in treex/nn/linear.py def unfreeze ( self : T , inplace : bool = False ) -> T : \"\"\" Creates a new module with `.frozen` set to False, equivalent to calling `freeze(False)`. Arguments: inplace: Whether to update the module inplace. Returns: The new module with `.frozen` set to False, if `inplace` is `True` then `self` is returned. \"\"\" return self . freeze ( False , inplace = inplace )","title":"Linear"},{"location":"api/Linear/#treexlinear","text":"A linear transformation applied over the last dimension of the input. Linear is implemented as a wrapper over flax.linen.Dense , its constructor arguments accept almost the same arguments including any Flax artifacts such as initializers. Main differences: receives features_in as a first argument since shapes must be statically known. features argument is renamed to features_out .","title":"treex.Linear"},{"location":"api/Linear/#treex.nn.linear.Linear.first_run","text":"Returns: Type Description bool True if its currently the first run of a compact method.","title":"first_run"},{"location":"api/Linear/#treex.nn.linear.Linear.__class__","text":"","title":"__class__"},{"location":"api/Linear/#treex.nn.linear.Linear.__class__.__base__","text":"","title":"__base__"},{"location":"api/Linear/#treex.nn.linear.Linear.__class__.__base__.__base__","text":"Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()).","title":"__base__"},{"location":"api/Linear/#treex.nn.linear.Linear.__class__.__base__.__base__.__instancecheck__","text":"Override for isinstance(instance, cls). Source code in treex/nn/linear.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance )","title":"__instancecheck__()"},{"location":"api/Linear/#treex.nn.linear.Linear.__class__.__base__.__base__.__new__","text":"Create and return a new object. See help(type) for accurate signature. Source code in treex/nn/linear.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls","title":"__new__()"},{"location":"api/Linear/#treex.nn.linear.Linear.__class__.__base__.__base__.__subclasscheck__","text":"Override for issubclass(subclass, cls). Source code in treex/nn/linear.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass )","title":"__subclasscheck__()"},{"location":"api/Linear/#treex.nn.linear.Linear.__class__.__base__.__base__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/linear.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/Linear/#treex.nn.linear.Linear.__class__.__base__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/linear.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/Linear/#treex.nn.linear.Linear.__class__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/linear.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/Linear/#treex.nn.linear.Linear.__call__","text":"Applies a linear transformation to the inputs along the last dimension. Parameters: Name Type Description Default x ndarray The nd-array to be transformed. required Returns: Type Description ndarray The transformed input. Source code in treex/nn/linear.py def __call__ ( self , x : jnp . ndarray ) -> jnp . ndarray : \"\"\"Applies a linear transformation to the inputs along the last dimension. Arguments: x: The nd-array to be transformed. Returns: The transformed input. \"\"\" if self . initializing (): variables = self . module . init ({ \"params\" : next_key ()}, x ) # Extract collections params = variables [ \"params\" ] . unfreeze () self . kernel = params [ \"kernel\" ] if self . use_bias : self . bias = params [ \"bias\" ] assert self . kernel is not None params = { \"kernel\" : self . kernel } if self . use_bias : assert self . bias is not None params [ \"bias\" ] = self . bias output = self . module . apply ({ \"params\" : params }, x ) return tp . cast ( jnp . ndarray , output )","title":"__call__()"},{"location":"api/Linear/#treex.nn.linear.Linear.__init__","text":"Parameters: Name Type Description Default features_in the number of input features. required features_out int the number of output features. required use_bias bool whether to add a bias to the output (default: True). True dtype Any the dtype of the computation (default: float32). <class 'jax._src.numpy.lax_numpy.float32'> precision Any numerical precision of the computation see jax.lax.Precision for details. None kernel_init Callable[[Any, Iterable[int], Any], Any] initializer function for the weight matrix. <function variance_scaling.<locals>.init at 0x7f29cde939d0> bias_init Callable[[Any, Iterable[int], Any], Any] initializer function for the bias. <function zeros at 0x7f29d70075e0> Source code in treex/nn/linear.py def __init__ ( self , features_out : int , * , use_bias : bool = True , dtype : tp . Any = jnp . float32 , precision : tp . Any = None , kernel_init : tp . Callable [ [ flax_module . PRNGKey , flax_module . Shape , flax_module . Dtype ], flax_module . Array , ] = flax_module . default_kernel_init , bias_init : tp . Callable [ [ flax_module . PRNGKey , flax_module . Shape , flax_module . Dtype ], flax_module . Array , ] = flax_module . zeros , name : tp . Optional [ str ] = None , ): \"\"\" Arguments: features_in: the number of input features. features_out: the number of output features. use_bias: whether to add a bias to the output (default: True). dtype: the dtype of the computation (default: float32). precision: numerical precision of the computation see `jax.lax.Precision` for details. kernel_init: initializer function for the weight matrix. bias_init: initializer function for the bias. \"\"\" super () . __init__ ( name = name ) self . features_out = features_out self . use_bias = use_bias self . dtype = dtype self . precision = precision self . kernel_init = kernel_init self . bias_init = bias_init self . kernel = None self . bias = None","title":"__init__()"},{"location":"api/Linear/#treex.nn.linear.Linear.apply","text":"apply is a wrapper over treeo.apply that passes self as the second argument. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treex/nn/linear.py def apply ( self : A , f : tp . Callable [ ... , None ], * rest : A , inplace : bool = False ) -> A : \"\"\" `apply` is a wrapper over `treeo.apply` that passes `self` as the second argument. Arguments: f: The function to apply. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" return api . apply ( f , self , * rest , inplace = inplace )","title":"apply()"},{"location":"api/Linear/#treex.nn.linear.Linear.batch_stats","text":"Returns a copy of the Module with only tx.BatchStat TreeParts, alias for filter(tx.BatchStat) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/linear.py def batch_stats ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.BatchStat TreeParts, alias for `filter(tx.BatchStat)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . BatchStat , * filters )","title":"batch_stats()"},{"location":"api/Linear/#treex.nn.linear.Linear.check_metadata_updates","text":"Checks for new fields, if found, adds them to the metadata. Source code in treex/nn/linear.py def check_metadata_updates ( self ): \"\"\" Checks for new fields, if found, adds them to the metadata. \"\"\" with _CONTEXT . update ( flatten_mode = FlattenMode . all_fields ): jax . tree_flatten ( self )","title":"check_metadata_updates()"},{"location":"api/Linear/#treex.nn.linear.Linear.copy","text":"copy is a wrapper over treeo.copy that passes self as the first argument. Source code in treex/nn/linear.py def copy ( self : A ) -> A : \"\"\" `copy` is a wrapper over `treeo.copy` that passes `self` as the first argument. \"\"\" return tree_m . copy ( self )","title":"copy()"},{"location":"api/Linear/#treex.nn.linear.Linear.eval","text":"Creates a new module with the training mode set to False, equivalent to calling train(False) . Returns: Type Description ~T The new module with the training mode set to False. Source code in treex/nn/linear.py def eval ( self : T , inplace : bool = False ) -> T : \"\"\" Creates a new module with the training mode set to False, equivalent to calling `train(False)`. Returns: The new module with the training mode set to False. \"\"\" return self . train ( False , inplace = inplace )","title":"eval()"},{"location":"api/Linear/#treex.nn.linear.Linear.filter","text":"filter is a wrapper over treeo.filter that passes self as the first argument. Parameters: Name Type Description Default *filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treex/nn/linear.py def filter ( self : A , * filters : api . Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ) -> A : \"\"\" `filter` is a wrapper over `treeo.filter` that passes `self` as the first argument. Arguments: *filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" return api . filter ( self , * filters , inplace = inplace , flatten_mode = flatten_mode )","title":"filter()"},{"location":"api/Linear/#treex.nn.linear.Linear.freeze","text":"Creates a new module with the same structure, but with Module.frozen set to the given value. Parameters: Name Type Description Default mode bool The new frozen mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module in with the frozen mode is set to the given value, if inplace is True then self is returned. Source code in treex/nn/linear.py def freeze ( self : T , mode : bool = True , inplace : bool = False ) -> T : \"\"\" Creates a new module with the same structure, but with `Module.frozen` set to the given value. Arguments: mode: The new `frozen` mode. inplace: Whether to update the module inplace. Returns: The new module in with the `frozen` mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_frozen ( tree ): if isinstance ( tree , Treex ) and hasattr ( tree , \"_frozen\" ): tree . _frozen = mode return to . apply ( set_frozen , self , inplace = inplace )","title":"freeze()"},{"location":"api/Linear/#treex.nn.linear.Linear.get_field","text":"A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: The field must be declared in the class definition. The method can only be called inside a compact context. Parameters: Name Type Description Default field_name str The name of the field to get. required initializer Callable[[], ~A] The function to initialize the field if it does not exist. required Returns: Type Description ~A The field value. Source code in treex/nn/linear.py def get_field ( self , field_name : str , initializer : tp . Callable [[], A ], ) -> A : \"\"\" A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: * The field must be declared in the class definition. * The method can only be called inside a `compact` context. Arguments: field_name: The name of the field to get. initializer: The function to initialize the field if it does not exist. Returns: The field value. \"\"\" value : A if field_name not in self . _field_metadata : raise ValueError ( f \"Metadata for field ' { field_name } ' does not exist.\" ) if field_name in vars ( self ): value = getattr ( self , field_name ) else : if tree_m . _COMPACT_CONTEXT . in_compact and not self . first_run : raise RuntimeError ( f \"Trying to initialize field ' { field_name } ' after the first run of `compact`.\" ) value = initializer () setattr ( self , field_name , value ) return value","title":"get_field()"},{"location":"api/Linear/#treex.nn.linear.Linear.init","text":"Method version of tx.init , it applies self as first argument. init creates a new module with the same structure, but with its fields initialized given a seed key . The following procedure is used: The input key is split and iteratively updated before passing a derived value to any process that requires initialization. Initializer s are called and applied to the module first. Module.rng_init methods are called last. Parameters: Name Type Description Default key Union[int, jax._src.numpy.lax_numpy.ndarray] The seed to use for initialization. required Returns: Type Description ~M The new module with the fields initialized. Source code in treex/nn/linear.py def init ( self : M , key : tp . Union [ int , jnp . ndarray ], inputs : types . InputLike = to . MISSING , call_method : str = \"__call__\" , * , inplace : bool = False , _set_initialize : bool = True , ) -> M : \"\"\" Method version of `tx.init`, it applies `self` as first argument. `init` creates a new module with the same structure, but with its fields initialized given a seed `key`. The following procedure is used: 1. The input `key` is split and iteratively updated before passing a derived value to any process that requires initialization. 2. `Initializer`s are called and applied to the module first. 3. `Module.rng_init` methods are called last. Arguments: key: The seed to use for initialization. Returns: The new module with the fields initialized. \"\"\" module = self . copy () if not inplace else self key = utils . Key ( key ) with _INIT_CONTEXT . update ( key = key , initializing = True ): module : M = module . map ( lambda initializer : ( initializer ( next_key ()) if isinstance ( initializer , types . Initializer ) else initializer ), is_leaf = lambda x : isinstance ( x , types . Initializer ), inplace = True , ) def call_rng_init ( module : Module ): if isinstance ( module , Module ) and not module . _initialized : module . rng_init () module = to . apply ( call_rng_init , module , inplace = True ) if inputs is not to . MISSING : inputs = types . Inputs . from_value ( inputs ) method = getattr ( module , call_method ) method ( * inputs . args , ** inputs . kwargs ) if _set_initialize : def set_initialized ( module : Module ): if isinstance ( module , Module ) and not module . _initialized : module . _initialized = True module = to . apply ( set_initialized , module , inplace = True ) return module","title":"init()"},{"location":"api/Linear/#treex.nn.linear.Linear.logs","text":"Returns a copy of the Module with only tx.Log TreeParts, alias for filter(tx.Log) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/linear.py def logs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Log TreeParts, alias for `filter(tx.Log)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . Log , * filters )","title":"logs()"},{"location":"api/Linear/#treex.nn.linear.Linear.loss_logs","text":"Returns a copy of the Module with only tx.Loss TreeParts, alias for filter(tx.Loss) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/linear.py def loss_logs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Loss TreeParts, alias for `filter(tx.Loss)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . LossLog , * filters )","title":"loss_logs()"},{"location":"api/Linear/#treex.nn.linear.Linear.map","text":"map is a wrapper over treeo.map that passes self as the second argument. Parameters: Name Type Description Default f Callable The function to apply to the leaves. required *filters Filter The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treex/nn/linear.py def map ( self : A , f : tp . Callable , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , is_leaf : tp . Callable [[ tp . Any ], bool ] = None , ) -> A : \"\"\" `map` is a wrapper over `treeo.map` that passes `self` as the second argument. Arguments: f: The function to apply to the leaves. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" return api . map ( f , self , * filters , inplace = inplace , flatten_mode = flatten_mode , is_leaf = is_leaf , )","title":"map()"},{"location":"api/Linear/#treex.nn.linear.Linear.merge","text":"merge is a wrapper over treeo.merge that passes self as the first argument. Parameters: Name Type Description Default other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the merged values. If inplace is True , obj is returned. Source code in treex/nn/linear.py def merge ( self : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" `merge` is a wrapper over `treeo.merge` that passes `self` as the first argument. Arguments: other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the merged values. If `inplace` is `True`, `obj` is returned. \"\"\" return api . merge ( self , other , * rest , inplace = inplace , flatten_mode = flatten_mode , ignore_static = ignore_static , )","title":"merge()"},{"location":"api/Linear/#treex.nn.linear.Linear.metric_logs","text":"Returns a copy of the Module with only tx.Metric TreeParts, alias for filter(tx.Metric) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/linear.py def metric_logs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Metric TreeParts, alias for `filter(tx.Metric)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . MetricLog , * filters )","title":"metric_logs()"},{"location":"api/Linear/#treex.nn.linear.Linear.model_states","text":"Returns a copy of the Module with only tx.ModelState TreeParts, alias for filter(tx.ModelState) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/linear.py def model_states ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.ModelState TreeParts, alias for `filter(tx.ModelState)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . ModelState , * filters )","title":"model_states()"},{"location":"api/Linear/#treex.nn.linear.Linear.parameters","text":"Returns a copy of the Module with only tx.Parameter TreeParts, alias for filter(tx.Parameter) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/linear.py def parameters ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Parameter TreeParts, alias for `filter(tx.Parameter)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . Parameter , * filters )","title":"parameters()"},{"location":"api/Linear/#treex.nn.linear.Linear.rngs","text":"Returns a copy of the Module with only tx.Rng TreeParts, alias for filter(tx.Rng) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/linear.py def rngs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Rng TreeParts, alias for `filter(tx.Rng)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . Rng , * filters )","title":"rngs()"},{"location":"api/Linear/#treex.nn.linear.Linear.states","text":"Returns a copy of the Module with only tx.State TreeParts, alias for filter(tx.State) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/linear.py def states ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.State TreeParts, alias for `filter(tx.State)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . State , * filters )","title":"states()"},{"location":"api/Linear/#treex.nn.linear.Linear.tabulate","text":"Returns a tabular representation of the module. Parameters: Name Type Description Default depth int The maximum depth of the representation in terms of nested Modules, -1 means no limit. -1 signature bool Whether to show the signature of the Module. False param_types bool Whether to show the types of the parameters. True Returns: Type Description str A string containing the tabular representation. Source code in treex/nn/linear.py def tabulate ( self , inputs : tp . Union [ types . InputLike , to . Missing ] = to . MISSING , depth : int = - 1 , signature : bool = False , param_types : bool = True , ) -> str : \"\"\" Returns a tabular representation of the module. Arguments: depth: The maximum depth of the representation in terms of nested Modules, -1 means no limit. signature: Whether to show the signature of the Module. param_types: Whether to show the types of the parameters. Returns: A string containing the tabular representation. \"\"\" self = to . copy ( self ) if inputs is not to . MISSING : inputs = types . Inputs . from_value ( inputs ) if not isinstance ( self , tp . Callable ): raise TypeError ( \"`inputs` can only be specified if the module is a callable.\" ) with contexts . _Context ( call_info = {}): # call using self to preserve references def eval_call ( args , kwargs ): assert isinstance ( self , tp . Callable ) return self ( * args , ** kwargs ) jax . eval_shape ( eval_call , inputs . args , inputs . kwargs , ) call_info = contexts . _CONTEXT . call_info else : call_info = None with to . add_field_info (): flat : tp . List [ to . FieldInfo ] flat , _ = jax . tree_flatten ( self ) tree_part_types : tp . Tuple [ tp . Type [ types . TreePart ], ... ] = tuple ( { field_info . kind for field_info in flat if utils . _generic_issubclass ( field_info . kind , types . TreePart ) } ) path = () rows = list ( utils . _get_tabulate_rows ( path , self , depth , tree_part_types , signature , param_types ) ) modules = [ row [ 0 ] for row in rows ] rows = [ row [ 1 :] for row in rows ] if call_info is not None : for module , row in zip ( modules , rows ): if module in call_info : inputs , outputs = call_info [ module ] simplified_inputs = ( inputs . args [ 0 ] if len ( inputs . kwargs ) == 0 and len ( inputs . args ) == 1 else inputs . kwargs if len ( inputs . kwargs ) == 0 else inputs . kwargs if len ( inputs . args ) == 0 else ( inputs . args , inputs . kwargs ) ) inputs_repr = utils . _format_param_tree ( simplified_inputs ) outputs_repr = utils . _format_param_tree ( outputs ) else : inputs_repr = \"\" outputs_repr = \"\" row . insert ( 3 , outputs_repr ) row . insert ( 3 , inputs_repr ) n_non_treepart_cols = 2 if call_info is None else 4 rows [ 0 ][ 0 ] = \"*\" rows . append ( [ \"\" ] * n_non_treepart_cols + [ \"Total:\" ] + [ utils . _format_obj_size ( self . filter ( kind ), add_padding = True ) for kind in tree_part_types ] ) utils . _add_padding ( rows ) table = Table ( show_header = True , show_lines = True , show_footer = True , # box=rich.box.HORIZONTALS, ) table . add_column ( \"path\" ) table . add_column ( \"module\" ) table . add_column ( \"params\" ) if call_info is not None : table . add_column ( \"inputs\" ) table . add_column ( \"outputs\" ) for tree_part_type in tree_part_types : type_name = tree_part_type . __name__ if type_name . startswith ( \"_\" ): type_name = type_name [ 1 :] table . add_column ( type_name ) for row in rows [: - 1 ]: table . add_row ( * row ) table . columns [ n_non_treepart_cols ] . footer = Text . from_markup ( rows [ - 1 ][ n_non_treepart_cols ], justify = \"right\" ) for i in range ( len ( tree_part_types )): table . columns [ n_non_treepart_cols + 1 + i ] . footer = rows [ - 1 ][ n_non_treepart_cols + 1 + i ] table . caption_style = \"bold\" table . caption = \" \\n Total Parameters: \" + utils . _format_obj_size ( self , add_padding = False ) return utils . _get_rich_repr ( table )","title":"tabulate()"},{"location":"api/Linear/#treex.nn.linear.Linear.to_dict","text":"to_dict is a wrapper over treeo.to_dict that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True type_info bool If True , type information is included. False field_info bool If True , field information is included. False Returns: Type Description Any A dict representation of the object. Source code in treex/nn/linear.py def to_dict ( self , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : \"\"\" `to_dict` is a wrapper over `treeo.to_dict` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. type_info: If `True`, type information is included. field_info: If `True`, field information is included. Returns: A dict representation of the object. \"\"\" return api . to_dict ( self , private_fields = private_fields , static_fields = static_fields , type_info = type_info , field_info = field_info , )","title":"to_dict()"},{"location":"api/Linear/#treex.nn.linear.Linear.to_string","text":"to_string is a wrapper over treeo.to_string that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True color bool If True , color is included. False Returns: Type Description str A string representation of the object. Source code in treex/nn/linear.py def to_string ( self : A , * , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" `to_string` is a wrapper over `treeo.to_string` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. color: If `True`, color is included. Returns: A string representation of the object. \"\"\" return api . to_string ( self , private_fields = private_fields , static_fields = static_fields , color = color , )","title":"to_string()"},{"location":"api/Linear/#treex.nn.linear.Linear.train","text":"Creates a new module with the same structure, but with Module.training set to the given value. Parameters: Name Type Description Default mode bool The new training mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module in with the training mode is set to the given value, if inplace is True then self is returned. Source code in treex/nn/linear.py def train ( self : T , mode : bool = True , inplace : bool = False ) -> T : \"\"\" Creates a new module with the same structure, but with `Module.training` set to the given value. Arguments: mode: The new training mode. inplace: Whether to update the module inplace. Returns: The new module in with the training mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_training ( tree ): if isinstance ( tree , Treex ) and hasattr ( tree , \"_training\" ): tree . _training = mode return to . apply ( set_training , self , inplace = inplace )","title":"train()"},{"location":"api/Linear/#treex.nn.linear.Linear.unfreeze","text":"Creates a new module with .frozen set to False, equivalent to calling freeze(False) . Parameters: Name Type Description Default inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module with .frozen set to False, if inplace is True then self is returned. Source code in treex/nn/linear.py def unfreeze ( self : T , inplace : bool = False ) -> T : \"\"\" Creates a new module with `.frozen` set to False, equivalent to calling `freeze(False)`. Arguments: inplace: Whether to update the module inplace. Returns: The new module with `.frozen` set to False, if `inplace` is `True` then `self` is returned. \"\"\" return self . freeze ( False , inplace = inplace )","title":"unfreeze()"},{"location":"api/Log/","text":"treex.Log","title":"Log"},{"location":"api/Log/#treexlog","text":"","title":"treex.Log"},{"location":"api/Loss/","text":"treex.Loss Loss base class. To be implemented by subclasses: call() : Contains the logic for loss calculation. Example subclass implementation: class MeanSquaredError ( Loss ): def call ( self , target , preds ): return jnp . mean ( jnp . square ( preds - target ), axis =- 1 ) Please see the [Modules, Losses, and Metrics Guide] (https://poets-ai.github.io/elegy/guides/modules-losses-metrics/#losses) for more details on this. __init__ ( self , reduction = None , weight = None , on = None , name = None ) special Initializes Loss class. Parameters: Name Type Description Default reduction Optional[treex.losses.loss.Reduction] (Optional) Type of tx.losses.Reduction to apply to loss. Default value is SUM_OVER_BATCH_SIZE . For almost all cases this defaults to SUM_OVER_BATCH_SIZE . None weight Union[float, numpy.ndarray, jax._src.numpy.lax_numpy.ndarray] Optional weight contribution for the total loss. Defaults to 1 . None on Union[str, int, Sequence[Union[str, int]]] A string or integer, or iterable of string or integers, that indicate how to index/filter the target and preds arguments before passing them to call . For example if on = \"a\" then target = target[\"a\"] . If on is an iterable the structures will be indexed iteratively, for example if on = [\"a\", 0, \"b\"] then target = target[\"a\"][0][\"b\"] , same for preds . For more information check out Keras-like behavior . None name Optional[str] Optional name for the instance, if not provided lower snake_case version of the name of the class is used instead. None Source code in treex/losses/loss.py def __init__ ( self , reduction : tp . Optional [ Reduction ] = None , weight : tp . Optional [ types . ScalarLike ] = None , on : tp . Optional [ types . IndexLike ] = None , name : tp . Optional [ str ] = None , ): \"\"\" Initializes `Loss` class. Arguments: reduction: (Optional) Type of `tx.losses.Reduction` to apply to loss. Default value is `SUM_OVER_BATCH_SIZE`. For almost all cases this defaults to `SUM_OVER_BATCH_SIZE`. weight: Optional weight contribution for the total loss. Defaults to `1`. on: A string or integer, or iterable of string or integers, that indicate how to index/filter the `target` and `preds` arguments before passing them to `call`. For example if `on = \"a\"` then `target = target[\"a\"]`. If `on` is an iterable the structures will be indexed iteratively, for example if `on = [\"a\", 0, \"b\"]` then `target = target[\"a\"][0][\"b\"]`, same for `preds`. For more information check out [Keras-like behavior](https://poets-ai.github.io/elegy/guides/modules-losses-metrics/#keras-like-behavior). name: Optional name for the instance, if not provided lower snake_case version of the name of the class is used instead. \"\"\" self . name = name if name is not None else utils . _get_name ( self ) self . weight = ( jnp . asarray ( weight , dtype = jnp . float32 ) if weight is not None else jnp . array ( 1.0 , dtype = jnp . float32 ) ) self . _reduction = ( reduction if reduction is not None else Reduction . SUM_OVER_BATCH_SIZE ) self . _labels_filter = ( on ,) if isinstance ( on , ( str , int )) else on self . _signature_f = self . call","title":"Loss"},{"location":"api/Loss/#treexloss","text":"Loss base class. To be implemented by subclasses: call() : Contains the logic for loss calculation. Example subclass implementation: class MeanSquaredError ( Loss ): def call ( self , target , preds ): return jnp . mean ( jnp . square ( preds - target ), axis =- 1 ) Please see the [Modules, Losses, and Metrics Guide] (https://poets-ai.github.io/elegy/guides/modules-losses-metrics/#losses) for more details on this.","title":"treex.Loss"},{"location":"api/Loss/#treex.losses.loss.Loss.__init__","text":"Initializes Loss class. Parameters: Name Type Description Default reduction Optional[treex.losses.loss.Reduction] (Optional) Type of tx.losses.Reduction to apply to loss. Default value is SUM_OVER_BATCH_SIZE . For almost all cases this defaults to SUM_OVER_BATCH_SIZE . None weight Union[float, numpy.ndarray, jax._src.numpy.lax_numpy.ndarray] Optional weight contribution for the total loss. Defaults to 1 . None on Union[str, int, Sequence[Union[str, int]]] A string or integer, or iterable of string or integers, that indicate how to index/filter the target and preds arguments before passing them to call . For example if on = \"a\" then target = target[\"a\"] . If on is an iterable the structures will be indexed iteratively, for example if on = [\"a\", 0, \"b\"] then target = target[\"a\"][0][\"b\"] , same for preds . For more information check out Keras-like behavior . None name Optional[str] Optional name for the instance, if not provided lower snake_case version of the name of the class is used instead. None Source code in treex/losses/loss.py def __init__ ( self , reduction : tp . Optional [ Reduction ] = None , weight : tp . Optional [ types . ScalarLike ] = None , on : tp . Optional [ types . IndexLike ] = None , name : tp . Optional [ str ] = None , ): \"\"\" Initializes `Loss` class. Arguments: reduction: (Optional) Type of `tx.losses.Reduction` to apply to loss. Default value is `SUM_OVER_BATCH_SIZE`. For almost all cases this defaults to `SUM_OVER_BATCH_SIZE`. weight: Optional weight contribution for the total loss. Defaults to `1`. on: A string or integer, or iterable of string or integers, that indicate how to index/filter the `target` and `preds` arguments before passing them to `call`. For example if `on = \"a\"` then `target = target[\"a\"]`. If `on` is an iterable the structures will be indexed iteratively, for example if `on = [\"a\", 0, \"b\"]` then `target = target[\"a\"][0][\"b\"]`, same for `preds`. For more information check out [Keras-like behavior](https://poets-ai.github.io/elegy/guides/modules-losses-metrics/#keras-like-behavior). name: Optional name for the instance, if not provided lower snake_case version of the name of the class is used instead. \"\"\" self . name = name if name is not None else utils . _get_name ( self ) self . weight = ( jnp . asarray ( weight , dtype = jnp . float32 ) if weight is not None else jnp . array ( 1.0 , dtype = jnp . float32 ) ) self . _reduction = ( reduction if reduction is not None else Reduction . SUM_OVER_BATCH_SIZE ) self . _labels_filter = ( on ,) if isinstance ( on , ( str , int )) else on self . _signature_f = self . call","title":"__init__()"},{"location":"api/LossAndLogs/","text":"treex.LossAndLogs first_run : bool inherited property readonly Returns: Type Description bool True if its currently the first run of a compact method. __class__ inherited __base__ inherited __base__ inherited Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()). __instancecheck__ ( cls , instance ) special Override for isinstance(instance, cls). Source code in treex/metrics/loss_and_logs.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance ) __new__ ( mcls , name , bases , namespace , ** kwargs ) special staticmethod Create and return a new object. See help(type) for accurate signature. Source code in treex/metrics/loss_and_logs.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls __subclasscheck__ ( cls , subclass ) special Override for issubclass(subclass, cls). Source code in treex/metrics/loss_and_logs.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass ) register ( cls , subclass ) Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/metrics/loss_and_logs.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) register ( cls , subclass ) inherited Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/metrics/loss_and_logs.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) register ( cls , subclass ) inherited Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/metrics/loss_and_logs.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) apply ( self , f , * rest , * , inplace = False ) inherited apply is a wrapper over treeo.apply that passes self as the second argument. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treex/metrics/loss_and_logs.py def apply ( self : A , f : tp . Callable [ ... , None ], * rest : A , inplace : bool = False ) -> A : \"\"\" `apply` is a wrapper over `treeo.apply` that passes `self` as the second argument. Arguments: f: The function to apply. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" return api . apply ( f , self , * rest , inplace = inplace ) check_metadata_updates ( self ) inherited Checks for new fields, if found, adds them to the metadata. Source code in treex/metrics/loss_and_logs.py def check_metadata_updates ( self ): \"\"\" Checks for new fields, if found, adds them to the metadata. \"\"\" with _CONTEXT . update ( flatten_mode = FlattenMode . all_fields ): jax . tree_flatten ( self ) copy ( self ) inherited copy is a wrapper over treeo.copy that passes self as the first argument. Source code in treex/metrics/loss_and_logs.py def copy ( self : A ) -> A : \"\"\" `copy` is a wrapper over `treeo.copy` that passes `self` as the first argument. \"\"\" return tree_m . copy ( self ) eval ( self , inplace = False ) inherited Creates a new module with the training mode set to False, equivalent to calling train(False) . Returns: Type Description ~T The new module with the training mode set to False. Source code in treex/metrics/loss_and_logs.py def eval ( self : T , inplace : bool = False ) -> T : \"\"\" Creates a new module with the training mode set to False, equivalent to calling `train(False)`. Returns: The new module with the training mode set to False. \"\"\" return self . train ( False , inplace = inplace ) filter ( self , * filters , * , inplace = False , flatten_mode = None ) inherited filter is a wrapper over treeo.filter that passes self as the first argument. Parameters: Name Type Description Default *filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treex/metrics/loss_and_logs.py def filter ( self : A , * filters : api . Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ) -> A : \"\"\" `filter` is a wrapper over `treeo.filter` that passes `self` as the first argument. Arguments: *filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" return api . filter ( self , * filters , inplace = inplace , flatten_mode = flatten_mode ) freeze ( self , mode = True , inplace = False ) inherited Creates a new module with the same structure, but with Module.frozen set to the given value. Parameters: Name Type Description Default mode bool The new frozen mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module in with the frozen mode is set to the given value, if inplace is True then self is returned. Source code in treex/metrics/loss_and_logs.py def freeze ( self : T , mode : bool = True , inplace : bool = False ) -> T : \"\"\" Creates a new module with the same structure, but with `Module.frozen` set to the given value. Arguments: mode: The new `frozen` mode. inplace: Whether to update the module inplace. Returns: The new module in with the `frozen` mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_frozen ( tree ): if isinstance ( tree , Treex ) and hasattr ( tree , \"_frozen\" ): tree . _frozen = mode return to . apply ( set_frozen , self , inplace = inplace ) get_field ( self , field_name , initializer ) inherited A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: The field must be declared in the class definition. The method can only be called inside a compact context. Parameters: Name Type Description Default field_name str The name of the field to get. required initializer Callable[[], ~A] The function to initialize the field if it does not exist. required Returns: Type Description ~A The field value. Source code in treex/metrics/loss_and_logs.py def get_field ( self , field_name : str , initializer : tp . Callable [[], A ], ) -> A : \"\"\" A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: * The field must be declared in the class definition. * The method can only be called inside a `compact` context. Arguments: field_name: The name of the field to get. initializer: The function to initialize the field if it does not exist. Returns: The field value. \"\"\" value : A if field_name not in self . _field_metadata : raise ValueError ( f \"Metadata for field ' { field_name } ' does not exist.\" ) if field_name in vars ( self ): value = getattr ( self , field_name ) else : if tree_m . _COMPACT_CONTEXT . in_compact and not self . first_run : raise RuntimeError ( f \"Trying to initialize field ' { field_name } ' after the first run of `compact`.\" ) value = initializer () setattr ( self , field_name , value ) return value map ( self , f , * filters , * , inplace = False , flatten_mode = None , is_leaf = None ) inherited map is a wrapper over treeo.map that passes self as the second argument. Parameters: Name Type Description Default f Callable The function to apply to the leaves. required *filters Filter The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treex/metrics/loss_and_logs.py def map ( self : A , f : tp . Callable , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , is_leaf : tp . Callable [[ tp . Any ], bool ] = None , ) -> A : \"\"\" `map` is a wrapper over `treeo.map` that passes `self` as the second argument. Arguments: f: The function to apply to the leaves. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" return api . map ( f , self , * filters , inplace = inplace , flatten_mode = flatten_mode , is_leaf = is_leaf , ) merge ( self , other , * rest , * , inplace = False , flatten_mode = None , ignore_static = False ) inherited merge is a wrapper over treeo.merge that passes self as the first argument. Parameters: Name Type Description Default other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the merged values. If inplace is True , obj is returned. Source code in treex/metrics/loss_and_logs.py def merge ( self : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" `merge` is a wrapper over `treeo.merge` that passes `self` as the first argument. Arguments: other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the merged values. If `inplace` is `True`, `obj` is returned. \"\"\" return api . merge ( self , other , * rest , inplace = inplace , flatten_mode = flatten_mode , ignore_static = ignore_static , ) to_dict ( self , * , private_fields = False , static_fields = True , type_info = False , field_info = False ) inherited to_dict is a wrapper over treeo.to_dict that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True type_info bool If True , type information is included. False field_info bool If True , field information is included. False Returns: Type Description Any A dict representation of the object. Source code in treex/metrics/loss_and_logs.py def to_dict ( self , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : \"\"\" `to_dict` is a wrapper over `treeo.to_dict` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. type_info: If `True`, type information is included. field_info: If `True`, field information is included. Returns: A dict representation of the object. \"\"\" return api . to_dict ( self , private_fields = private_fields , static_fields = static_fields , type_info = type_info , field_info = field_info , ) to_string ( self , * , private_fields = False , static_fields = True , color = False ) inherited to_string is a wrapper over treeo.to_string that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True color bool If True , color is included. False Returns: Type Description str A string representation of the object. Source code in treex/metrics/loss_and_logs.py def to_string ( self : A , * , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" `to_string` is a wrapper over `treeo.to_string` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. color: If `True`, color is included. Returns: A string representation of the object. \"\"\" return api . to_string ( self , private_fields = private_fields , static_fields = static_fields , color = color , ) train ( self , mode = True , inplace = False ) inherited Creates a new module with the same structure, but with Module.training set to the given value. Parameters: Name Type Description Default mode bool The new training mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module in with the training mode is set to the given value, if inplace is True then self is returned. Source code in treex/metrics/loss_and_logs.py def train ( self : T , mode : bool = True , inplace : bool = False ) -> T : \"\"\" Creates a new module with the same structure, but with `Module.training` set to the given value. Arguments: mode: The new training mode. inplace: Whether to update the module inplace. Returns: The new module in with the training mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_training ( tree ): if isinstance ( tree , Treex ) and hasattr ( tree , \"_training\" ): tree . _training = mode return to . apply ( set_training , self , inplace = inplace ) unfreeze ( self , inplace = False ) inherited Creates a new module with .frozen set to False, equivalent to calling freeze(False) . Parameters: Name Type Description Default inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module with .frozen set to False, if inplace is True then self is returned. Source code in treex/metrics/loss_and_logs.py def unfreeze ( self : T , inplace : bool = False ) -> T : \"\"\" Creates a new module with `.frozen` set to False, equivalent to calling `freeze(False)`. Arguments: inplace: Whether to update the module inplace. Returns: The new module with `.frozen` set to False, if `inplace` is `True` then `self` is returned. \"\"\" return self . freeze ( False , inplace = inplace )","title":"LossAndLogs"},{"location":"api/LossAndLogs/#treexlossandlogs","text":"","title":"treex.LossAndLogs"},{"location":"api/LossAndLogs/#treex.metrics.loss_and_logs.LossAndLogs.first_run","text":"Returns: Type Description bool True if its currently the first run of a compact method.","title":"first_run"},{"location":"api/LossAndLogs/#treex.metrics.loss_and_logs.LossAndLogs.__class__","text":"","title":"__class__"},{"location":"api/LossAndLogs/#treex.metrics.loss_and_logs.LossAndLogs.__class__.__base__","text":"","title":"__base__"},{"location":"api/LossAndLogs/#treex.metrics.loss_and_logs.LossAndLogs.__class__.__base__.__base__","text":"Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()).","title":"__base__"},{"location":"api/LossAndLogs/#treex.metrics.loss_and_logs.LossAndLogs.__class__.__base__.__base__.__instancecheck__","text":"Override for isinstance(instance, cls). Source code in treex/metrics/loss_and_logs.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance )","title":"__instancecheck__()"},{"location":"api/LossAndLogs/#treex.metrics.loss_and_logs.LossAndLogs.__class__.__base__.__base__.__new__","text":"Create and return a new object. See help(type) for accurate signature. Source code in treex/metrics/loss_and_logs.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls","title":"__new__()"},{"location":"api/LossAndLogs/#treex.metrics.loss_and_logs.LossAndLogs.__class__.__base__.__base__.__subclasscheck__","text":"Override for issubclass(subclass, cls). Source code in treex/metrics/loss_and_logs.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass )","title":"__subclasscheck__()"},{"location":"api/LossAndLogs/#treex.metrics.loss_and_logs.LossAndLogs.__class__.__base__.__base__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/metrics/loss_and_logs.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/LossAndLogs/#treex.metrics.loss_and_logs.LossAndLogs.__class__.__base__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/metrics/loss_and_logs.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/LossAndLogs/#treex.metrics.loss_and_logs.LossAndLogs.__class__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/metrics/loss_and_logs.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/LossAndLogs/#treex.metrics.loss_and_logs.LossAndLogs.apply","text":"apply is a wrapper over treeo.apply that passes self as the second argument. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treex/metrics/loss_and_logs.py def apply ( self : A , f : tp . Callable [ ... , None ], * rest : A , inplace : bool = False ) -> A : \"\"\" `apply` is a wrapper over `treeo.apply` that passes `self` as the second argument. Arguments: f: The function to apply. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" return api . apply ( f , self , * rest , inplace = inplace )","title":"apply()"},{"location":"api/LossAndLogs/#treex.metrics.loss_and_logs.LossAndLogs.check_metadata_updates","text":"Checks for new fields, if found, adds them to the metadata. Source code in treex/metrics/loss_and_logs.py def check_metadata_updates ( self ): \"\"\" Checks for new fields, if found, adds them to the metadata. \"\"\" with _CONTEXT . update ( flatten_mode = FlattenMode . all_fields ): jax . tree_flatten ( self )","title":"check_metadata_updates()"},{"location":"api/LossAndLogs/#treex.metrics.loss_and_logs.LossAndLogs.copy","text":"copy is a wrapper over treeo.copy that passes self as the first argument. Source code in treex/metrics/loss_and_logs.py def copy ( self : A ) -> A : \"\"\" `copy` is a wrapper over `treeo.copy` that passes `self` as the first argument. \"\"\" return tree_m . copy ( self )","title":"copy()"},{"location":"api/LossAndLogs/#treex.metrics.loss_and_logs.LossAndLogs.eval","text":"Creates a new module with the training mode set to False, equivalent to calling train(False) . Returns: Type Description ~T The new module with the training mode set to False. Source code in treex/metrics/loss_and_logs.py def eval ( self : T , inplace : bool = False ) -> T : \"\"\" Creates a new module with the training mode set to False, equivalent to calling `train(False)`. Returns: The new module with the training mode set to False. \"\"\" return self . train ( False , inplace = inplace )","title":"eval()"},{"location":"api/LossAndLogs/#treex.metrics.loss_and_logs.LossAndLogs.filter","text":"filter is a wrapper over treeo.filter that passes self as the first argument. Parameters: Name Type Description Default *filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treex/metrics/loss_and_logs.py def filter ( self : A , * filters : api . Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ) -> A : \"\"\" `filter` is a wrapper over `treeo.filter` that passes `self` as the first argument. Arguments: *filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" return api . filter ( self , * filters , inplace = inplace , flatten_mode = flatten_mode )","title":"filter()"},{"location":"api/LossAndLogs/#treex.metrics.loss_and_logs.LossAndLogs.freeze","text":"Creates a new module with the same structure, but with Module.frozen set to the given value. Parameters: Name Type Description Default mode bool The new frozen mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module in with the frozen mode is set to the given value, if inplace is True then self is returned. Source code in treex/metrics/loss_and_logs.py def freeze ( self : T , mode : bool = True , inplace : bool = False ) -> T : \"\"\" Creates a new module with the same structure, but with `Module.frozen` set to the given value. Arguments: mode: The new `frozen` mode. inplace: Whether to update the module inplace. Returns: The new module in with the `frozen` mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_frozen ( tree ): if isinstance ( tree , Treex ) and hasattr ( tree , \"_frozen\" ): tree . _frozen = mode return to . apply ( set_frozen , self , inplace = inplace )","title":"freeze()"},{"location":"api/LossAndLogs/#treex.metrics.loss_and_logs.LossAndLogs.get_field","text":"A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: The field must be declared in the class definition. The method can only be called inside a compact context. Parameters: Name Type Description Default field_name str The name of the field to get. required initializer Callable[[], ~A] The function to initialize the field if it does not exist. required Returns: Type Description ~A The field value. Source code in treex/metrics/loss_and_logs.py def get_field ( self , field_name : str , initializer : tp . Callable [[], A ], ) -> A : \"\"\" A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: * The field must be declared in the class definition. * The method can only be called inside a `compact` context. Arguments: field_name: The name of the field to get. initializer: The function to initialize the field if it does not exist. Returns: The field value. \"\"\" value : A if field_name not in self . _field_metadata : raise ValueError ( f \"Metadata for field ' { field_name } ' does not exist.\" ) if field_name in vars ( self ): value = getattr ( self , field_name ) else : if tree_m . _COMPACT_CONTEXT . in_compact and not self . first_run : raise RuntimeError ( f \"Trying to initialize field ' { field_name } ' after the first run of `compact`.\" ) value = initializer () setattr ( self , field_name , value ) return value","title":"get_field()"},{"location":"api/LossAndLogs/#treex.metrics.loss_and_logs.LossAndLogs.map","text":"map is a wrapper over treeo.map that passes self as the second argument. Parameters: Name Type Description Default f Callable The function to apply to the leaves. required *filters Filter The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treex/metrics/loss_and_logs.py def map ( self : A , f : tp . Callable , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , is_leaf : tp . Callable [[ tp . Any ], bool ] = None , ) -> A : \"\"\" `map` is a wrapper over `treeo.map` that passes `self` as the second argument. Arguments: f: The function to apply to the leaves. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" return api . map ( f , self , * filters , inplace = inplace , flatten_mode = flatten_mode , is_leaf = is_leaf , )","title":"map()"},{"location":"api/LossAndLogs/#treex.metrics.loss_and_logs.LossAndLogs.merge","text":"merge is a wrapper over treeo.merge that passes self as the first argument. Parameters: Name Type Description Default other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the merged values. If inplace is True , obj is returned. Source code in treex/metrics/loss_and_logs.py def merge ( self : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" `merge` is a wrapper over `treeo.merge` that passes `self` as the first argument. Arguments: other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the merged values. If `inplace` is `True`, `obj` is returned. \"\"\" return api . merge ( self , other , * rest , inplace = inplace , flatten_mode = flatten_mode , ignore_static = ignore_static , )","title":"merge()"},{"location":"api/LossAndLogs/#treex.metrics.loss_and_logs.LossAndLogs.to_dict","text":"to_dict is a wrapper over treeo.to_dict that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True type_info bool If True , type information is included. False field_info bool If True , field information is included. False Returns: Type Description Any A dict representation of the object. Source code in treex/metrics/loss_and_logs.py def to_dict ( self , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : \"\"\" `to_dict` is a wrapper over `treeo.to_dict` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. type_info: If `True`, type information is included. field_info: If `True`, field information is included. Returns: A dict representation of the object. \"\"\" return api . to_dict ( self , private_fields = private_fields , static_fields = static_fields , type_info = type_info , field_info = field_info , )","title":"to_dict()"},{"location":"api/LossAndLogs/#treex.metrics.loss_and_logs.LossAndLogs.to_string","text":"to_string is a wrapper over treeo.to_string that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True color bool If True , color is included. False Returns: Type Description str A string representation of the object. Source code in treex/metrics/loss_and_logs.py def to_string ( self : A , * , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" `to_string` is a wrapper over `treeo.to_string` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. color: If `True`, color is included. Returns: A string representation of the object. \"\"\" return api . to_string ( self , private_fields = private_fields , static_fields = static_fields , color = color , )","title":"to_string()"},{"location":"api/LossAndLogs/#treex.metrics.loss_and_logs.LossAndLogs.train","text":"Creates a new module with the same structure, but with Module.training set to the given value. Parameters: Name Type Description Default mode bool The new training mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module in with the training mode is set to the given value, if inplace is True then self is returned. Source code in treex/metrics/loss_and_logs.py def train ( self : T , mode : bool = True , inplace : bool = False ) -> T : \"\"\" Creates a new module with the same structure, but with `Module.training` set to the given value. Arguments: mode: The new training mode. inplace: Whether to update the module inplace. Returns: The new module in with the training mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_training ( tree ): if isinstance ( tree , Treex ) and hasattr ( tree , \"_training\" ): tree . _training = mode return to . apply ( set_training , self , inplace = inplace )","title":"train()"},{"location":"api/LossAndLogs/#treex.metrics.loss_and_logs.LossAndLogs.unfreeze","text":"Creates a new module with .frozen set to False, equivalent to calling freeze(False) . Parameters: Name Type Description Default inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module with .frozen set to False, if inplace is True then self is returned. Source code in treex/metrics/loss_and_logs.py def unfreeze ( self : T , inplace : bool = False ) -> T : \"\"\" Creates a new module with `.frozen` set to False, equivalent to calling `freeze(False)`. Arguments: inplace: Whether to update the module inplace. Returns: The new module with `.frozen` set to False, if `inplace` is `True` then `self` is returned. \"\"\" return self . freeze ( False , inplace = inplace )","title":"unfreeze()"},{"location":"api/LossLog/","text":"treex.LossLog","title":"LossLog"},{"location":"api/LossLog/#treexlosslog","text":"","title":"treex.LossLog"},{"location":"api/MLP/","text":"treex.MLP A Multi-Layer Perceptron (MLP) that applies a sequence of linear layers with a given activation (relu by default), the last layer is linear. first_run : bool inherited property readonly Returns: Type Description bool True if its currently the first run of a compact method. __class__ inherited __base__ inherited __base__ inherited Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()). __instancecheck__ ( cls , instance ) special Override for isinstance(instance, cls). Source code in treex/nn/mlp.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance ) __new__ ( mcls , name , bases , namespace , ** kwargs ) special staticmethod Create and return a new object. See help(type) for accurate signature. Source code in treex/nn/mlp.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls __subclasscheck__ ( cls , subclass ) special Override for issubclass(subclass, cls). Source code in treex/nn/mlp.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass ) register ( cls , subclass ) Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/mlp.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) register ( cls , subclass ) inherited Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/mlp.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) register ( cls , subclass ) inherited Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/mlp.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) __call__ ( self , x ) special Applies the MLP to the input. Parameters: Name Type Description Default x ndarray input array. required Returns: Type Description ndarray The output of the MLP. Source code in treex/nn/mlp.py @to . compact def __call__ ( self , x : jnp . ndarray ) -> jnp . ndarray : \"\"\" Applies the MLP to the input. Arguments: x: input array. Returns: The output of the MLP. \"\"\" last_layer_idx = len ( self . features ) - 1 for i , features_out in enumerate ( self . features ): x = Linear ( features_out = features_out , use_bias = self . use_bias , dtype = self . dtype , precision = self . precision , kernel_init = self . kernel_init , bias_init = self . bias_init , )( x ) if i < last_layer_idx : x = self . activation ( x ) return x __init__ ( self , features , activation =< jax . _src . custom_derivatives . custom_jvp object at 0x7f29d6fd1e80 > , use_bias = True , dtype =< class ' jax . _src . numpy . lax_numpy . float32 '>, precision=None, kernel_init=<function variance_scaling.<locals>.init at 0x7f29cde939d0>, bias_init=<function zeros at 0x7f29d70075e0>) special Parameters: Name Type Description Default features Sequence[int] a sequence of L+1 integers, where L is the number of layers, the first integer is the number of input features and all subsequent integers are the number of output features of the respective layer. required activation Callable[[jax._src.numpy.lax_numpy.ndarray], jax._src.numpy.lax_numpy.ndarray] the activation function to use. <jax._src.custom_derivatives.custom_jvp object at 0x7f29d6fd1e80> use_bias bool whether to add a bias to the output (default: True). True dtype Any the dtype of the computation (default: float32). <class 'jax._src.numpy.lax_numpy.float32'> precision Any numerical precision of the computation see jax.lax.Precision for details. None kernel_init Callable[[Any, Iterable[int], Any], Any] initializer function for the weight matrix. <function variance_scaling.<locals>.init at 0x7f29cde939d0> bias_init Callable[[Any, Iterable[int], Any], Any] initializer function for the bias. <function zeros at 0x7f29d70075e0> Source code in treex/nn/mlp.py def __init__ ( self , features : tp . Sequence [ int ], activation : tp . Callable [[ jnp . ndarray ], jnp . ndarray ] = jax . nn . relu , use_bias : bool = True , dtype : tp . Any = jnp . float32 , precision : tp . Any = None , kernel_init : tp . Callable [ [ flax_module . PRNGKey , flax_module . Shape , flax_module . Dtype ], flax_module . Array , ] = flax_module . default_kernel_init , bias_init : tp . Callable [ [ flax_module . PRNGKey , flax_module . Shape , flax_module . Dtype ], flax_module . Array , ] = flax_module . zeros , ): \"\"\" Arguments: features: a sequence of L+1 integers, where L is the number of layers, the first integer is the number of input features and all subsequent integers are the number of output features of the respective layer. activation: the activation function to use. use_bias: whether to add a bias to the output (default: True). dtype: the dtype of the computation (default: float32). precision: numerical precision of the computation see `jax.lax.Precision` for details. kernel_init: initializer function for the weight matrix. bias_init: initializer function for the bias. \"\"\" if len ( features ) == 0 : raise ValueError ( \"features must have at least 1 element\" ) self . features = features self . activation = activation self . use_bias = use_bias self . dtype = dtype self . precision = precision self . kernel_init = kernel_init self . bias_init = bias_init apply ( self , f , * rest , * , inplace = False ) inherited apply is a wrapper over treeo.apply that passes self as the second argument. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treex/nn/mlp.py def apply ( self : A , f : tp . Callable [ ... , None ], * rest : A , inplace : bool = False ) -> A : \"\"\" `apply` is a wrapper over `treeo.apply` that passes `self` as the second argument. Arguments: f: The function to apply. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" return api . apply ( f , self , * rest , inplace = inplace ) batch_stats ( self , * filters ) inherited Returns a copy of the Module with only tx.BatchStat TreeParts, alias for filter(tx.BatchStat) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/mlp.py def batch_stats ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.BatchStat TreeParts, alias for `filter(tx.BatchStat)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . BatchStat , * filters ) check_metadata_updates ( self ) inherited Checks for new fields, if found, adds them to the metadata. Source code in treex/nn/mlp.py def check_metadata_updates ( self ): \"\"\" Checks for new fields, if found, adds them to the metadata. \"\"\" with _CONTEXT . update ( flatten_mode = FlattenMode . all_fields ): jax . tree_flatten ( self ) copy ( self ) inherited copy is a wrapper over treeo.copy that passes self as the first argument. Source code in treex/nn/mlp.py def copy ( self : A ) -> A : \"\"\" `copy` is a wrapper over `treeo.copy` that passes `self` as the first argument. \"\"\" return tree_m . copy ( self ) eval ( self , inplace = False ) inherited Creates a new module with the training mode set to False, equivalent to calling train(False) . Returns: Type Description ~T The new module with the training mode set to False. Source code in treex/nn/mlp.py def eval ( self : T , inplace : bool = False ) -> T : \"\"\" Creates a new module with the training mode set to False, equivalent to calling `train(False)`. Returns: The new module with the training mode set to False. \"\"\" return self . train ( False , inplace = inplace ) filter ( self , * filters , * , inplace = False , flatten_mode = None ) inherited filter is a wrapper over treeo.filter that passes self as the first argument. Parameters: Name Type Description Default *filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treex/nn/mlp.py def filter ( self : A , * filters : api . Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ) -> A : \"\"\" `filter` is a wrapper over `treeo.filter` that passes `self` as the first argument. Arguments: *filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" return api . filter ( self , * filters , inplace = inplace , flatten_mode = flatten_mode ) freeze ( self , mode = True , inplace = False ) inherited Creates a new module with the same structure, but with Module.frozen set to the given value. Parameters: Name Type Description Default mode bool The new frozen mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module in with the frozen mode is set to the given value, if inplace is True then self is returned. Source code in treex/nn/mlp.py def freeze ( self : T , mode : bool = True , inplace : bool = False ) -> T : \"\"\" Creates a new module with the same structure, but with `Module.frozen` set to the given value. Arguments: mode: The new `frozen` mode. inplace: Whether to update the module inplace. Returns: The new module in with the `frozen` mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_frozen ( tree ): if isinstance ( tree , Treex ) and hasattr ( tree , \"_frozen\" ): tree . _frozen = mode return to . apply ( set_frozen , self , inplace = inplace ) get_field ( self , field_name , initializer ) inherited A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: The field must be declared in the class definition. The method can only be called inside a compact context. Parameters: Name Type Description Default field_name str The name of the field to get. required initializer Callable[[], ~A] The function to initialize the field if it does not exist. required Returns: Type Description ~A The field value. Source code in treex/nn/mlp.py def get_field ( self , field_name : str , initializer : tp . Callable [[], A ], ) -> A : \"\"\" A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: * The field must be declared in the class definition. * The method can only be called inside a `compact` context. Arguments: field_name: The name of the field to get. initializer: The function to initialize the field if it does not exist. Returns: The field value. \"\"\" value : A if field_name not in self . _field_metadata : raise ValueError ( f \"Metadata for field ' { field_name } ' does not exist.\" ) if field_name in vars ( self ): value = getattr ( self , field_name ) else : if tree_m . _COMPACT_CONTEXT . in_compact and not self . first_run : raise RuntimeError ( f \"Trying to initialize field ' { field_name } ' after the first run of `compact`.\" ) value = initializer () setattr ( self , field_name , value ) return value init ( self , key , inputs =< treeo . types . Missing object at 0x7f29ce5c9220 > , call_method = '__call__' , * , inplace = False , _set_initialize = True ) inherited Method version of tx.init , it applies self as first argument. init creates a new module with the same structure, but with its fields initialized given a seed key . The following procedure is used: The input key is split and iteratively updated before passing a derived value to any process that requires initialization. Initializer s are called and applied to the module first. Module.rng_init methods are called last. Parameters: Name Type Description Default key Union[int, jax._src.numpy.lax_numpy.ndarray] The seed to use for initialization. required Returns: Type Description ~M The new module with the fields initialized. Source code in treex/nn/mlp.py def init ( self : M , key : tp . Union [ int , jnp . ndarray ], inputs : types . InputLike = to . MISSING , call_method : str = \"__call__\" , * , inplace : bool = False , _set_initialize : bool = True , ) -> M : \"\"\" Method version of `tx.init`, it applies `self` as first argument. `init` creates a new module with the same structure, but with its fields initialized given a seed `key`. The following procedure is used: 1. The input `key` is split and iteratively updated before passing a derived value to any process that requires initialization. 2. `Initializer`s are called and applied to the module first. 3. `Module.rng_init` methods are called last. Arguments: key: The seed to use for initialization. Returns: The new module with the fields initialized. \"\"\" module = self . copy () if not inplace else self key = utils . Key ( key ) with _INIT_CONTEXT . update ( key = key , initializing = True ): module : M = module . map ( lambda initializer : ( initializer ( next_key ()) if isinstance ( initializer , types . Initializer ) else initializer ), is_leaf = lambda x : isinstance ( x , types . Initializer ), inplace = True , ) def call_rng_init ( module : Module ): if isinstance ( module , Module ) and not module . _initialized : module . rng_init () module = to . apply ( call_rng_init , module , inplace = True ) if inputs is not to . MISSING : inputs = types . Inputs . from_value ( inputs ) method = getattr ( module , call_method ) method ( * inputs . args , ** inputs . kwargs ) if _set_initialize : def set_initialized ( module : Module ): if isinstance ( module , Module ) and not module . _initialized : module . _initialized = True module = to . apply ( set_initialized , module , inplace = True ) return module logs ( self , * filters ) inherited Returns a copy of the Module with only tx.Log TreeParts, alias for filter(tx.Log) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/mlp.py def logs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Log TreeParts, alias for `filter(tx.Log)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . Log , * filters ) loss_logs ( self , * filters ) inherited Returns a copy of the Module with only tx.Loss TreeParts, alias for filter(tx.Loss) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/mlp.py def loss_logs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Loss TreeParts, alias for `filter(tx.Loss)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . LossLog , * filters ) map ( self , f , * filters , * , inplace = False , flatten_mode = None , is_leaf = None ) inherited map is a wrapper over treeo.map that passes self as the second argument. Parameters: Name Type Description Default f Callable The function to apply to the leaves. required *filters Filter The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treex/nn/mlp.py def map ( self : A , f : tp . Callable , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , is_leaf : tp . Callable [[ tp . Any ], bool ] = None , ) -> A : \"\"\" `map` is a wrapper over `treeo.map` that passes `self` as the second argument. Arguments: f: The function to apply to the leaves. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" return api . map ( f , self , * filters , inplace = inplace , flatten_mode = flatten_mode , is_leaf = is_leaf , ) merge ( self , other , * rest , * , inplace = False , flatten_mode = None , ignore_static = False ) inherited merge is a wrapper over treeo.merge that passes self as the first argument. Parameters: Name Type Description Default other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the merged values. If inplace is True , obj is returned. Source code in treex/nn/mlp.py def merge ( self : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" `merge` is a wrapper over `treeo.merge` that passes `self` as the first argument. Arguments: other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the merged values. If `inplace` is `True`, `obj` is returned. \"\"\" return api . merge ( self , other , * rest , inplace = inplace , flatten_mode = flatten_mode , ignore_static = ignore_static , ) metric_logs ( self , * filters ) inherited Returns a copy of the Module with only tx.Metric TreeParts, alias for filter(tx.Metric) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/mlp.py def metric_logs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Metric TreeParts, alias for `filter(tx.Metric)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . MetricLog , * filters ) model_states ( self , * filters ) inherited Returns a copy of the Module with only tx.ModelState TreeParts, alias for filter(tx.ModelState) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/mlp.py def model_states ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.ModelState TreeParts, alias for `filter(tx.ModelState)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . ModelState , * filters ) parameters ( self , * filters ) inherited Returns a copy of the Module with only tx.Parameter TreeParts, alias for filter(tx.Parameter) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/mlp.py def parameters ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Parameter TreeParts, alias for `filter(tx.Parameter)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . Parameter , * filters ) rngs ( self , * filters ) inherited Returns a copy of the Module with only tx.Rng TreeParts, alias for filter(tx.Rng) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/mlp.py def rngs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Rng TreeParts, alias for `filter(tx.Rng)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . Rng , * filters ) states ( self , * filters ) inherited Returns a copy of the Module with only tx.State TreeParts, alias for filter(tx.State) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/mlp.py def states ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.State TreeParts, alias for `filter(tx.State)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . State , * filters ) tabulate ( self , inputs =< treeo . types . Missing object at 0x7f29ce5c9220 > , depth =- 1 , signature = False , param_types = True ) inherited Returns a tabular representation of the module. Parameters: Name Type Description Default depth int The maximum depth of the representation in terms of nested Modules, -1 means no limit. -1 signature bool Whether to show the signature of the Module. False param_types bool Whether to show the types of the parameters. True Returns: Type Description str A string containing the tabular representation. Source code in treex/nn/mlp.py def tabulate ( self , inputs : tp . Union [ types . InputLike , to . Missing ] = to . MISSING , depth : int = - 1 , signature : bool = False , param_types : bool = True , ) -> str : \"\"\" Returns a tabular representation of the module. Arguments: depth: The maximum depth of the representation in terms of nested Modules, -1 means no limit. signature: Whether to show the signature of the Module. param_types: Whether to show the types of the parameters. Returns: A string containing the tabular representation. \"\"\" self = to . copy ( self ) if inputs is not to . MISSING : inputs = types . Inputs . from_value ( inputs ) if not isinstance ( self , tp . Callable ): raise TypeError ( \"`inputs` can only be specified if the module is a callable.\" ) with contexts . _Context ( call_info = {}): # call using self to preserve references def eval_call ( args , kwargs ): assert isinstance ( self , tp . Callable ) return self ( * args , ** kwargs ) jax . eval_shape ( eval_call , inputs . args , inputs . kwargs , ) call_info = contexts . _CONTEXT . call_info else : call_info = None with to . add_field_info (): flat : tp . List [ to . FieldInfo ] flat , _ = jax . tree_flatten ( self ) tree_part_types : tp . Tuple [ tp . Type [ types . TreePart ], ... ] = tuple ( { field_info . kind for field_info in flat if utils . _generic_issubclass ( field_info . kind , types . TreePart ) } ) path = () rows = list ( utils . _get_tabulate_rows ( path , self , depth , tree_part_types , signature , param_types ) ) modules = [ row [ 0 ] for row in rows ] rows = [ row [ 1 :] for row in rows ] if call_info is not None : for module , row in zip ( modules , rows ): if module in call_info : inputs , outputs = call_info [ module ] simplified_inputs = ( inputs . args [ 0 ] if len ( inputs . kwargs ) == 0 and len ( inputs . args ) == 1 else inputs . kwargs if len ( inputs . kwargs ) == 0 else inputs . kwargs if len ( inputs . args ) == 0 else ( inputs . args , inputs . kwargs ) ) inputs_repr = utils . _format_param_tree ( simplified_inputs ) outputs_repr = utils . _format_param_tree ( outputs ) else : inputs_repr = \"\" outputs_repr = \"\" row . insert ( 3 , outputs_repr ) row . insert ( 3 , inputs_repr ) n_non_treepart_cols = 2 if call_info is None else 4 rows [ 0 ][ 0 ] = \"*\" rows . append ( [ \"\" ] * n_non_treepart_cols + [ \"Total:\" ] + [ utils . _format_obj_size ( self . filter ( kind ), add_padding = True ) for kind in tree_part_types ] ) utils . _add_padding ( rows ) table = Table ( show_header = True , show_lines = True , show_footer = True , # box=rich.box.HORIZONTALS, ) table . add_column ( \"path\" ) table . add_column ( \"module\" ) table . add_column ( \"params\" ) if call_info is not None : table . add_column ( \"inputs\" ) table . add_column ( \"outputs\" ) for tree_part_type in tree_part_types : type_name = tree_part_type . __name__ if type_name . startswith ( \"_\" ): type_name = type_name [ 1 :] table . add_column ( type_name ) for row in rows [: - 1 ]: table . add_row ( * row ) table . columns [ n_non_treepart_cols ] . footer = Text . from_markup ( rows [ - 1 ][ n_non_treepart_cols ], justify = \"right\" ) for i in range ( len ( tree_part_types )): table . columns [ n_non_treepart_cols + 1 + i ] . footer = rows [ - 1 ][ n_non_treepart_cols + 1 + i ] table . caption_style = \"bold\" table . caption = \" \\n Total Parameters: \" + utils . _format_obj_size ( self , add_padding = False ) return utils . _get_rich_repr ( table ) to_dict ( self , * , private_fields = False , static_fields = True , type_info = False , field_info = False ) inherited to_dict is a wrapper over treeo.to_dict that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True type_info bool If True , type information is included. False field_info bool If True , field information is included. False Returns: Type Description Any A dict representation of the object. Source code in treex/nn/mlp.py def to_dict ( self , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : \"\"\" `to_dict` is a wrapper over `treeo.to_dict` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. type_info: If `True`, type information is included. field_info: If `True`, field information is included. Returns: A dict representation of the object. \"\"\" return api . to_dict ( self , private_fields = private_fields , static_fields = static_fields , type_info = type_info , field_info = field_info , ) to_string ( self , * , private_fields = False , static_fields = True , color = False ) inherited to_string is a wrapper over treeo.to_string that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True color bool If True , color is included. False Returns: Type Description str A string representation of the object. Source code in treex/nn/mlp.py def to_string ( self : A , * , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" `to_string` is a wrapper over `treeo.to_string` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. color: If `True`, color is included. Returns: A string representation of the object. \"\"\" return api . to_string ( self , private_fields = private_fields , static_fields = static_fields , color = color , ) train ( self , mode = True , inplace = False ) inherited Creates a new module with the same structure, but with Module.training set to the given value. Parameters: Name Type Description Default mode bool The new training mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module in with the training mode is set to the given value, if inplace is True then self is returned. Source code in treex/nn/mlp.py def train ( self : T , mode : bool = True , inplace : bool = False ) -> T : \"\"\" Creates a new module with the same structure, but with `Module.training` set to the given value. Arguments: mode: The new training mode. inplace: Whether to update the module inplace. Returns: The new module in with the training mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_training ( tree ): if isinstance ( tree , Treex ) and hasattr ( tree , \"_training\" ): tree . _training = mode return to . apply ( set_training , self , inplace = inplace ) unfreeze ( self , inplace = False ) inherited Creates a new module with .frozen set to False, equivalent to calling freeze(False) . Parameters: Name Type Description Default inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module with .frozen set to False, if inplace is True then self is returned. Source code in treex/nn/mlp.py def unfreeze ( self : T , inplace : bool = False ) -> T : \"\"\" Creates a new module with `.frozen` set to False, equivalent to calling `freeze(False)`. Arguments: inplace: Whether to update the module inplace. Returns: The new module with `.frozen` set to False, if `inplace` is `True` then `self` is returned. \"\"\" return self . freeze ( False , inplace = inplace )","title":"MLP"},{"location":"api/MLP/#treexmlp","text":"A Multi-Layer Perceptron (MLP) that applies a sequence of linear layers with a given activation (relu by default), the last layer is linear.","title":"treex.MLP"},{"location":"api/MLP/#treex.nn.mlp.MLP.first_run","text":"Returns: Type Description bool True if its currently the first run of a compact method.","title":"first_run"},{"location":"api/MLP/#treex.nn.mlp.MLP.__class__","text":"","title":"__class__"},{"location":"api/MLP/#treex.nn.mlp.MLP.__class__.__base__","text":"","title":"__base__"},{"location":"api/MLP/#treex.nn.mlp.MLP.__class__.__base__.__base__","text":"Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()).","title":"__base__"},{"location":"api/MLP/#treex.nn.mlp.MLP.__class__.__base__.__base__.__instancecheck__","text":"Override for isinstance(instance, cls). Source code in treex/nn/mlp.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance )","title":"__instancecheck__()"},{"location":"api/MLP/#treex.nn.mlp.MLP.__class__.__base__.__base__.__new__","text":"Create and return a new object. See help(type) for accurate signature. Source code in treex/nn/mlp.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls","title":"__new__()"},{"location":"api/MLP/#treex.nn.mlp.MLP.__class__.__base__.__base__.__subclasscheck__","text":"Override for issubclass(subclass, cls). Source code in treex/nn/mlp.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass )","title":"__subclasscheck__()"},{"location":"api/MLP/#treex.nn.mlp.MLP.__class__.__base__.__base__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/mlp.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/MLP/#treex.nn.mlp.MLP.__class__.__base__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/mlp.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/MLP/#treex.nn.mlp.MLP.__class__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/mlp.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/MLP/#treex.nn.mlp.MLP.__call__","text":"Applies the MLP to the input. Parameters: Name Type Description Default x ndarray input array. required Returns: Type Description ndarray The output of the MLP. Source code in treex/nn/mlp.py @to . compact def __call__ ( self , x : jnp . ndarray ) -> jnp . ndarray : \"\"\" Applies the MLP to the input. Arguments: x: input array. Returns: The output of the MLP. \"\"\" last_layer_idx = len ( self . features ) - 1 for i , features_out in enumerate ( self . features ): x = Linear ( features_out = features_out , use_bias = self . use_bias , dtype = self . dtype , precision = self . precision , kernel_init = self . kernel_init , bias_init = self . bias_init , )( x ) if i < last_layer_idx : x = self . activation ( x ) return x","title":"__call__()"},{"location":"api/MLP/#treex.nn.mlp.MLP.__init__","text":"Parameters: Name Type Description Default features Sequence[int] a sequence of L+1 integers, where L is the number of layers, the first integer is the number of input features and all subsequent integers are the number of output features of the respective layer. required activation Callable[[jax._src.numpy.lax_numpy.ndarray], jax._src.numpy.lax_numpy.ndarray] the activation function to use. <jax._src.custom_derivatives.custom_jvp object at 0x7f29d6fd1e80> use_bias bool whether to add a bias to the output (default: True). True dtype Any the dtype of the computation (default: float32). <class 'jax._src.numpy.lax_numpy.float32'> precision Any numerical precision of the computation see jax.lax.Precision for details. None kernel_init Callable[[Any, Iterable[int], Any], Any] initializer function for the weight matrix. <function variance_scaling.<locals>.init at 0x7f29cde939d0> bias_init Callable[[Any, Iterable[int], Any], Any] initializer function for the bias. <function zeros at 0x7f29d70075e0> Source code in treex/nn/mlp.py def __init__ ( self , features : tp . Sequence [ int ], activation : tp . Callable [[ jnp . ndarray ], jnp . ndarray ] = jax . nn . relu , use_bias : bool = True , dtype : tp . Any = jnp . float32 , precision : tp . Any = None , kernel_init : tp . Callable [ [ flax_module . PRNGKey , flax_module . Shape , flax_module . Dtype ], flax_module . Array , ] = flax_module . default_kernel_init , bias_init : tp . Callable [ [ flax_module . PRNGKey , flax_module . Shape , flax_module . Dtype ], flax_module . Array , ] = flax_module . zeros , ): \"\"\" Arguments: features: a sequence of L+1 integers, where L is the number of layers, the first integer is the number of input features and all subsequent integers are the number of output features of the respective layer. activation: the activation function to use. use_bias: whether to add a bias to the output (default: True). dtype: the dtype of the computation (default: float32). precision: numerical precision of the computation see `jax.lax.Precision` for details. kernel_init: initializer function for the weight matrix. bias_init: initializer function for the bias. \"\"\" if len ( features ) == 0 : raise ValueError ( \"features must have at least 1 element\" ) self . features = features self . activation = activation self . use_bias = use_bias self . dtype = dtype self . precision = precision self . kernel_init = kernel_init self . bias_init = bias_init","title":"__init__()"},{"location":"api/MLP/#treex.nn.mlp.MLP.apply","text":"apply is a wrapper over treeo.apply that passes self as the second argument. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treex/nn/mlp.py def apply ( self : A , f : tp . Callable [ ... , None ], * rest : A , inplace : bool = False ) -> A : \"\"\" `apply` is a wrapper over `treeo.apply` that passes `self` as the second argument. Arguments: f: The function to apply. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" return api . apply ( f , self , * rest , inplace = inplace )","title":"apply()"},{"location":"api/MLP/#treex.nn.mlp.MLP.batch_stats","text":"Returns a copy of the Module with only tx.BatchStat TreeParts, alias for filter(tx.BatchStat) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/mlp.py def batch_stats ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.BatchStat TreeParts, alias for `filter(tx.BatchStat)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . BatchStat , * filters )","title":"batch_stats()"},{"location":"api/MLP/#treex.nn.mlp.MLP.check_metadata_updates","text":"Checks for new fields, if found, adds them to the metadata. Source code in treex/nn/mlp.py def check_metadata_updates ( self ): \"\"\" Checks for new fields, if found, adds them to the metadata. \"\"\" with _CONTEXT . update ( flatten_mode = FlattenMode . all_fields ): jax . tree_flatten ( self )","title":"check_metadata_updates()"},{"location":"api/MLP/#treex.nn.mlp.MLP.copy","text":"copy is a wrapper over treeo.copy that passes self as the first argument. Source code in treex/nn/mlp.py def copy ( self : A ) -> A : \"\"\" `copy` is a wrapper over `treeo.copy` that passes `self` as the first argument. \"\"\" return tree_m . copy ( self )","title":"copy()"},{"location":"api/MLP/#treex.nn.mlp.MLP.eval","text":"Creates a new module with the training mode set to False, equivalent to calling train(False) . Returns: Type Description ~T The new module with the training mode set to False. Source code in treex/nn/mlp.py def eval ( self : T , inplace : bool = False ) -> T : \"\"\" Creates a new module with the training mode set to False, equivalent to calling `train(False)`. Returns: The new module with the training mode set to False. \"\"\" return self . train ( False , inplace = inplace )","title":"eval()"},{"location":"api/MLP/#treex.nn.mlp.MLP.filter","text":"filter is a wrapper over treeo.filter that passes self as the first argument. Parameters: Name Type Description Default *filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treex/nn/mlp.py def filter ( self : A , * filters : api . Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ) -> A : \"\"\" `filter` is a wrapper over `treeo.filter` that passes `self` as the first argument. Arguments: *filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" return api . filter ( self , * filters , inplace = inplace , flatten_mode = flatten_mode )","title":"filter()"},{"location":"api/MLP/#treex.nn.mlp.MLP.freeze","text":"Creates a new module with the same structure, but with Module.frozen set to the given value. Parameters: Name Type Description Default mode bool The new frozen mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module in with the frozen mode is set to the given value, if inplace is True then self is returned. Source code in treex/nn/mlp.py def freeze ( self : T , mode : bool = True , inplace : bool = False ) -> T : \"\"\" Creates a new module with the same structure, but with `Module.frozen` set to the given value. Arguments: mode: The new `frozen` mode. inplace: Whether to update the module inplace. Returns: The new module in with the `frozen` mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_frozen ( tree ): if isinstance ( tree , Treex ) and hasattr ( tree , \"_frozen\" ): tree . _frozen = mode return to . apply ( set_frozen , self , inplace = inplace )","title":"freeze()"},{"location":"api/MLP/#treex.nn.mlp.MLP.get_field","text":"A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: The field must be declared in the class definition. The method can only be called inside a compact context. Parameters: Name Type Description Default field_name str The name of the field to get. required initializer Callable[[], ~A] The function to initialize the field if it does not exist. required Returns: Type Description ~A The field value. Source code in treex/nn/mlp.py def get_field ( self , field_name : str , initializer : tp . Callable [[], A ], ) -> A : \"\"\" A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: * The field must be declared in the class definition. * The method can only be called inside a `compact` context. Arguments: field_name: The name of the field to get. initializer: The function to initialize the field if it does not exist. Returns: The field value. \"\"\" value : A if field_name not in self . _field_metadata : raise ValueError ( f \"Metadata for field ' { field_name } ' does not exist.\" ) if field_name in vars ( self ): value = getattr ( self , field_name ) else : if tree_m . _COMPACT_CONTEXT . in_compact and not self . first_run : raise RuntimeError ( f \"Trying to initialize field ' { field_name } ' after the first run of `compact`.\" ) value = initializer () setattr ( self , field_name , value ) return value","title":"get_field()"},{"location":"api/MLP/#treex.nn.mlp.MLP.init","text":"Method version of tx.init , it applies self as first argument. init creates a new module with the same structure, but with its fields initialized given a seed key . The following procedure is used: The input key is split and iteratively updated before passing a derived value to any process that requires initialization. Initializer s are called and applied to the module first. Module.rng_init methods are called last. Parameters: Name Type Description Default key Union[int, jax._src.numpy.lax_numpy.ndarray] The seed to use for initialization. required Returns: Type Description ~M The new module with the fields initialized. Source code in treex/nn/mlp.py def init ( self : M , key : tp . Union [ int , jnp . ndarray ], inputs : types . InputLike = to . MISSING , call_method : str = \"__call__\" , * , inplace : bool = False , _set_initialize : bool = True , ) -> M : \"\"\" Method version of `tx.init`, it applies `self` as first argument. `init` creates a new module with the same structure, but with its fields initialized given a seed `key`. The following procedure is used: 1. The input `key` is split and iteratively updated before passing a derived value to any process that requires initialization. 2. `Initializer`s are called and applied to the module first. 3. `Module.rng_init` methods are called last. Arguments: key: The seed to use for initialization. Returns: The new module with the fields initialized. \"\"\" module = self . copy () if not inplace else self key = utils . Key ( key ) with _INIT_CONTEXT . update ( key = key , initializing = True ): module : M = module . map ( lambda initializer : ( initializer ( next_key ()) if isinstance ( initializer , types . Initializer ) else initializer ), is_leaf = lambda x : isinstance ( x , types . Initializer ), inplace = True , ) def call_rng_init ( module : Module ): if isinstance ( module , Module ) and not module . _initialized : module . rng_init () module = to . apply ( call_rng_init , module , inplace = True ) if inputs is not to . MISSING : inputs = types . Inputs . from_value ( inputs ) method = getattr ( module , call_method ) method ( * inputs . args , ** inputs . kwargs ) if _set_initialize : def set_initialized ( module : Module ): if isinstance ( module , Module ) and not module . _initialized : module . _initialized = True module = to . apply ( set_initialized , module , inplace = True ) return module","title":"init()"},{"location":"api/MLP/#treex.nn.mlp.MLP.logs","text":"Returns a copy of the Module with only tx.Log TreeParts, alias for filter(tx.Log) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/mlp.py def logs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Log TreeParts, alias for `filter(tx.Log)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . Log , * filters )","title":"logs()"},{"location":"api/MLP/#treex.nn.mlp.MLP.loss_logs","text":"Returns a copy of the Module with only tx.Loss TreeParts, alias for filter(tx.Loss) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/mlp.py def loss_logs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Loss TreeParts, alias for `filter(tx.Loss)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . LossLog , * filters )","title":"loss_logs()"},{"location":"api/MLP/#treex.nn.mlp.MLP.map","text":"map is a wrapper over treeo.map that passes self as the second argument. Parameters: Name Type Description Default f Callable The function to apply to the leaves. required *filters Filter The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treex/nn/mlp.py def map ( self : A , f : tp . Callable , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , is_leaf : tp . Callable [[ tp . Any ], bool ] = None , ) -> A : \"\"\" `map` is a wrapper over `treeo.map` that passes `self` as the second argument. Arguments: f: The function to apply to the leaves. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" return api . map ( f , self , * filters , inplace = inplace , flatten_mode = flatten_mode , is_leaf = is_leaf , )","title":"map()"},{"location":"api/MLP/#treex.nn.mlp.MLP.merge","text":"merge is a wrapper over treeo.merge that passes self as the first argument. Parameters: Name Type Description Default other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the merged values. If inplace is True , obj is returned. Source code in treex/nn/mlp.py def merge ( self : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" `merge` is a wrapper over `treeo.merge` that passes `self` as the first argument. Arguments: other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the merged values. If `inplace` is `True`, `obj` is returned. \"\"\" return api . merge ( self , other , * rest , inplace = inplace , flatten_mode = flatten_mode , ignore_static = ignore_static , )","title":"merge()"},{"location":"api/MLP/#treex.nn.mlp.MLP.metric_logs","text":"Returns a copy of the Module with only tx.Metric TreeParts, alias for filter(tx.Metric) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/mlp.py def metric_logs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Metric TreeParts, alias for `filter(tx.Metric)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . MetricLog , * filters )","title":"metric_logs()"},{"location":"api/MLP/#treex.nn.mlp.MLP.model_states","text":"Returns a copy of the Module with only tx.ModelState TreeParts, alias for filter(tx.ModelState) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/mlp.py def model_states ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.ModelState TreeParts, alias for `filter(tx.ModelState)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . ModelState , * filters )","title":"model_states()"},{"location":"api/MLP/#treex.nn.mlp.MLP.parameters","text":"Returns a copy of the Module with only tx.Parameter TreeParts, alias for filter(tx.Parameter) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/mlp.py def parameters ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Parameter TreeParts, alias for `filter(tx.Parameter)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . Parameter , * filters )","title":"parameters()"},{"location":"api/MLP/#treex.nn.mlp.MLP.rngs","text":"Returns a copy of the Module with only tx.Rng TreeParts, alias for filter(tx.Rng) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/mlp.py def rngs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Rng TreeParts, alias for `filter(tx.Rng)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . Rng , * filters )","title":"rngs()"},{"location":"api/MLP/#treex.nn.mlp.MLP.states","text":"Returns a copy of the Module with only tx.State TreeParts, alias for filter(tx.State) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/mlp.py def states ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.State TreeParts, alias for `filter(tx.State)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . State , * filters )","title":"states()"},{"location":"api/MLP/#treex.nn.mlp.MLP.tabulate","text":"Returns a tabular representation of the module. Parameters: Name Type Description Default depth int The maximum depth of the representation in terms of nested Modules, -1 means no limit. -1 signature bool Whether to show the signature of the Module. False param_types bool Whether to show the types of the parameters. True Returns: Type Description str A string containing the tabular representation. Source code in treex/nn/mlp.py def tabulate ( self , inputs : tp . Union [ types . InputLike , to . Missing ] = to . MISSING , depth : int = - 1 , signature : bool = False , param_types : bool = True , ) -> str : \"\"\" Returns a tabular representation of the module. Arguments: depth: The maximum depth of the representation in terms of nested Modules, -1 means no limit. signature: Whether to show the signature of the Module. param_types: Whether to show the types of the parameters. Returns: A string containing the tabular representation. \"\"\" self = to . copy ( self ) if inputs is not to . MISSING : inputs = types . Inputs . from_value ( inputs ) if not isinstance ( self , tp . Callable ): raise TypeError ( \"`inputs` can only be specified if the module is a callable.\" ) with contexts . _Context ( call_info = {}): # call using self to preserve references def eval_call ( args , kwargs ): assert isinstance ( self , tp . Callable ) return self ( * args , ** kwargs ) jax . eval_shape ( eval_call , inputs . args , inputs . kwargs , ) call_info = contexts . _CONTEXT . call_info else : call_info = None with to . add_field_info (): flat : tp . List [ to . FieldInfo ] flat , _ = jax . tree_flatten ( self ) tree_part_types : tp . Tuple [ tp . Type [ types . TreePart ], ... ] = tuple ( { field_info . kind for field_info in flat if utils . _generic_issubclass ( field_info . kind , types . TreePart ) } ) path = () rows = list ( utils . _get_tabulate_rows ( path , self , depth , tree_part_types , signature , param_types ) ) modules = [ row [ 0 ] for row in rows ] rows = [ row [ 1 :] for row in rows ] if call_info is not None : for module , row in zip ( modules , rows ): if module in call_info : inputs , outputs = call_info [ module ] simplified_inputs = ( inputs . args [ 0 ] if len ( inputs . kwargs ) == 0 and len ( inputs . args ) == 1 else inputs . kwargs if len ( inputs . kwargs ) == 0 else inputs . kwargs if len ( inputs . args ) == 0 else ( inputs . args , inputs . kwargs ) ) inputs_repr = utils . _format_param_tree ( simplified_inputs ) outputs_repr = utils . _format_param_tree ( outputs ) else : inputs_repr = \"\" outputs_repr = \"\" row . insert ( 3 , outputs_repr ) row . insert ( 3 , inputs_repr ) n_non_treepart_cols = 2 if call_info is None else 4 rows [ 0 ][ 0 ] = \"*\" rows . append ( [ \"\" ] * n_non_treepart_cols + [ \"Total:\" ] + [ utils . _format_obj_size ( self . filter ( kind ), add_padding = True ) for kind in tree_part_types ] ) utils . _add_padding ( rows ) table = Table ( show_header = True , show_lines = True , show_footer = True , # box=rich.box.HORIZONTALS, ) table . add_column ( \"path\" ) table . add_column ( \"module\" ) table . add_column ( \"params\" ) if call_info is not None : table . add_column ( \"inputs\" ) table . add_column ( \"outputs\" ) for tree_part_type in tree_part_types : type_name = tree_part_type . __name__ if type_name . startswith ( \"_\" ): type_name = type_name [ 1 :] table . add_column ( type_name ) for row in rows [: - 1 ]: table . add_row ( * row ) table . columns [ n_non_treepart_cols ] . footer = Text . from_markup ( rows [ - 1 ][ n_non_treepart_cols ], justify = \"right\" ) for i in range ( len ( tree_part_types )): table . columns [ n_non_treepart_cols + 1 + i ] . footer = rows [ - 1 ][ n_non_treepart_cols + 1 + i ] table . caption_style = \"bold\" table . caption = \" \\n Total Parameters: \" + utils . _format_obj_size ( self , add_padding = False ) return utils . _get_rich_repr ( table )","title":"tabulate()"},{"location":"api/MLP/#treex.nn.mlp.MLP.to_dict","text":"to_dict is a wrapper over treeo.to_dict that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True type_info bool If True , type information is included. False field_info bool If True , field information is included. False Returns: Type Description Any A dict representation of the object. Source code in treex/nn/mlp.py def to_dict ( self , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : \"\"\" `to_dict` is a wrapper over `treeo.to_dict` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. type_info: If `True`, type information is included. field_info: If `True`, field information is included. Returns: A dict representation of the object. \"\"\" return api . to_dict ( self , private_fields = private_fields , static_fields = static_fields , type_info = type_info , field_info = field_info , )","title":"to_dict()"},{"location":"api/MLP/#treex.nn.mlp.MLP.to_string","text":"to_string is a wrapper over treeo.to_string that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True color bool If True , color is included. False Returns: Type Description str A string representation of the object. Source code in treex/nn/mlp.py def to_string ( self : A , * , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" `to_string` is a wrapper over `treeo.to_string` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. color: If `True`, color is included. Returns: A string representation of the object. \"\"\" return api . to_string ( self , private_fields = private_fields , static_fields = static_fields , color = color , )","title":"to_string()"},{"location":"api/MLP/#treex.nn.mlp.MLP.train","text":"Creates a new module with the same structure, but with Module.training set to the given value. Parameters: Name Type Description Default mode bool The new training mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module in with the training mode is set to the given value, if inplace is True then self is returned. Source code in treex/nn/mlp.py def train ( self : T , mode : bool = True , inplace : bool = False ) -> T : \"\"\" Creates a new module with the same structure, but with `Module.training` set to the given value. Arguments: mode: The new training mode. inplace: Whether to update the module inplace. Returns: The new module in with the training mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_training ( tree ): if isinstance ( tree , Treex ) and hasattr ( tree , \"_training\" ): tree . _training = mode return to . apply ( set_training , self , inplace = inplace )","title":"train()"},{"location":"api/MLP/#treex.nn.mlp.MLP.unfreeze","text":"Creates a new module with .frozen set to False, equivalent to calling freeze(False) . Parameters: Name Type Description Default inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module with .frozen set to False, if inplace is True then self is returned. Source code in treex/nn/mlp.py def unfreeze ( self : T , inplace : bool = False ) -> T : \"\"\" Creates a new module with `.frozen` set to False, equivalent to calling `freeze(False)`. Arguments: inplace: Whether to update the module inplace. Returns: The new module with `.frozen` set to False, if `inplace` is `True` then `self` is returned. \"\"\" return self . freeze ( False , inplace = inplace )","title":"unfreeze()"},{"location":"api/Map/","text":"treex.Map Mixin that adds a .map() method to the class. map ( self , f , * filters , * , inplace = False , flatten_mode = None , is_leaf = None ) map is a wrapper over treeo.map that passes self as the second argument. Parameters: Name Type Description Default f Callable The function to apply to the leaves. required *filters Filter The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treeo/mixins.py def map ( self : A , f : tp . Callable , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , is_leaf : tp . Callable [[ tp . Any ], bool ] = None , ) -> A : \"\"\" `map` is a wrapper over `treeo.map` that passes `self` as the second argument. Arguments: f: The function to apply to the leaves. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" return api . map ( f , self , * filters , inplace = inplace , flatten_mode = flatten_mode , is_leaf = is_leaf , )","title":"Map"},{"location":"api/Map/#treexmap","text":"Mixin that adds a .map() method to the class.","title":"treex.Map"},{"location":"api/Map/#treeo.mixins.Map.map","text":"map is a wrapper over treeo.map that passes self as the second argument. Parameters: Name Type Description Default f Callable The function to apply to the leaves. required *filters Filter The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treeo/mixins.py def map ( self : A , f : tp . Callable , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , is_leaf : tp . Callable [[ tp . Any ], bool ] = None , ) -> A : \"\"\" `map` is a wrapper over `treeo.map` that passes `self` as the second argument. Arguments: f: The function to apply to the leaves. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" return api . map ( f , self , * filters , inplace = inplace , flatten_mode = flatten_mode , is_leaf = is_leaf , )","title":"map()"},{"location":"api/Merge/","text":"treex.Merge Mixin that adds a .merge() method to the class. merge ( self , other , * rest , * , inplace = False , flatten_mode = None , ignore_static = False ) merge is a wrapper over treeo.merge that passes self as the first argument. Parameters: Name Type Description Default other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the merged values. If inplace is True , obj is returned. Source code in treeo/mixins.py def merge ( self : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" `merge` is a wrapper over `treeo.merge` that passes `self` as the first argument. Arguments: other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the merged values. If `inplace` is `True`, `obj` is returned. \"\"\" return api . merge ( self , other , * rest , inplace = inplace , flatten_mode = flatten_mode , ignore_static = ignore_static , )","title":"Merge"},{"location":"api/Merge/#treexmerge","text":"Mixin that adds a .merge() method to the class.","title":"treex.Merge"},{"location":"api/Merge/#treeo.mixins.Merge.merge","text":"merge is a wrapper over treeo.merge that passes self as the first argument. Parameters: Name Type Description Default other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the merged values. If inplace is True , obj is returned. Source code in treeo/mixins.py def merge ( self : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" `merge` is a wrapper over `treeo.merge` that passes `self` as the first argument. Arguments: other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the merged values. If `inplace` is `True`, `obj` is returned. \"\"\" return api . merge ( self , other , * rest , inplace = inplace , flatten_mode = flatten_mode , ignore_static = ignore_static , )","title":"merge()"},{"location":"api/Metric/","text":"treex.Metric Encapsulates metric logic and state. Metrics accumulate state between calls such that their output value reflect the metric as if calculated on the whole data given up to that point. first_run : bool inherited property readonly Returns: Type Description bool True if its currently the first run of a compact method. __class__ inherited __base__ inherited __base__ inherited Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()). __instancecheck__ ( cls , instance ) special Override for isinstance(instance, cls). Source code in treex/metrics/metric.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance ) __new__ ( mcls , name , bases , namespace , ** kwargs ) special staticmethod Create and return a new object. See help(type) for accurate signature. Source code in treex/metrics/metric.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls __subclasscheck__ ( cls , subclass ) special Override for issubclass(subclass, cls). Source code in treex/metrics/metric.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass ) register ( cls , subclass ) Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/metrics/metric.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) register ( cls , subclass ) inherited Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/metrics/metric.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) register ( cls , subclass ) inherited Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/metrics/metric.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) __init__ ( self , on = None , name = None , dtype = None ) special Parameters: Name Type Description Default on Union[str, int, Sequence[Union[str, int]]] A string or integer, or iterable of string or integers, that indicate how to index/filter the target and preds arguments before passing them to call . For example if on = \"a\" then target = target[\"a\"] . If on is an iterable the structures will be indexed iteratively, for example if on = [\"a\", 0, \"b\"] then target = target[\"a\"][0][\"b\"] , same for preds . For more information check out Keras-like behavior . None Source code in treex/metrics/metric.py def __init__ ( self , on : tp . Optional [ types . IndexLike ] = None , name : tp . Optional [ str ] = None , dtype : tp . Optional [ jnp . dtype ] = None , ): \"\"\" Arguments: on: A string or integer, or iterable of string or integers, that indicate how to index/filter the `target` and `preds` arguments before passing them to `call`. For example if `on = \"a\"` then `target = target[\"a\"]`. If `on` is an iterable the structures will be indexed iteratively, for example if `on = [\"a\", 0, \"b\"]` then `target = target[\"a\"][0][\"b\"]`, same for `preds`. For more information check out [Keras-like behavior](https://poets-ai.github.io/elegy/guides/modules-losses-metrics/#keras-like-behavior). \"\"\" self . _labels_filter = ( on ,) if isinstance ( on , ( str , int )) else on self . name = name if name is not None else utils . _get_name ( self ) self . dtype = dtype if dtype is not None else jnp . float32 __init_subclass__ () classmethod special This method is called when a class is subclassed. The default implementation does nothing. It may be overridden to extend subclasses. Source code in treex/metrics/metric.py def __init_subclass__ ( cls ): super () . __init_subclass__ () # add call signature old_call = cls . __call__ @functools . wraps ( cls . update ) def new_call ( self : M , * args , ** kwargs ) -> M : if len ( args ) > 0 : raise TypeError ( f \"All arguments to { cls . __name__ } .__call__ should be passed as keyword arguments.\" ) return old_call ( self , * args , ** kwargs ) cls . __call__ = new_call apply ( self , f , * rest , * , inplace = False ) inherited apply is a wrapper over treeo.apply that passes self as the second argument. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treex/metrics/metric.py def apply ( self : A , f : tp . Callable [ ... , None ], * rest : A , inplace : bool = False ) -> A : \"\"\" `apply` is a wrapper over `treeo.apply` that passes `self` as the second argument. Arguments: f: The function to apply. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" return api . apply ( f , self , * rest , inplace = inplace ) check_metadata_updates ( self ) inherited Checks for new fields, if found, adds them to the metadata. Source code in treex/metrics/metric.py def check_metadata_updates ( self ): \"\"\" Checks for new fields, if found, adds them to the metadata. \"\"\" with _CONTEXT . update ( flatten_mode = FlattenMode . all_fields ): jax . tree_flatten ( self ) copy ( self ) inherited copy is a wrapper over treeo.copy that passes self as the first argument. Source code in treex/metrics/metric.py def copy ( self : A ) -> A : \"\"\" `copy` is a wrapper over `treeo.copy` that passes `self` as the first argument. \"\"\" return tree_m . copy ( self ) eval ( self , inplace = False ) inherited Creates a new module with the training mode set to False, equivalent to calling train(False) . Returns: Type Description ~T The new module with the training mode set to False. Source code in treex/metrics/metric.py def eval ( self : T , inplace : bool = False ) -> T : \"\"\" Creates a new module with the training mode set to False, equivalent to calling `train(False)`. Returns: The new module with the training mode set to False. \"\"\" return self . train ( False , inplace = inplace ) filter ( self , * filters , * , inplace = False , flatten_mode = None ) inherited filter is a wrapper over treeo.filter that passes self as the first argument. Parameters: Name Type Description Default *filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treex/metrics/metric.py def filter ( self : A , * filters : api . Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ) -> A : \"\"\" `filter` is a wrapper over `treeo.filter` that passes `self` as the first argument. Arguments: *filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" return api . filter ( self , * filters , inplace = inplace , flatten_mode = flatten_mode ) freeze ( self , mode = True , inplace = False ) inherited Creates a new module with the same structure, but with Module.frozen set to the given value. Parameters: Name Type Description Default mode bool The new frozen mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module in with the frozen mode is set to the given value, if inplace is True then self is returned. Source code in treex/metrics/metric.py def freeze ( self : T , mode : bool = True , inplace : bool = False ) -> T : \"\"\" Creates a new module with the same structure, but with `Module.frozen` set to the given value. Arguments: mode: The new `frozen` mode. inplace: Whether to update the module inplace. Returns: The new module in with the `frozen` mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_frozen ( tree ): if isinstance ( tree , Treex ) and hasattr ( tree , \"_frozen\" ): tree . _frozen = mode return to . apply ( set_frozen , self , inplace = inplace ) get_field ( self , field_name , initializer ) inherited A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: The field must be declared in the class definition. The method can only be called inside a compact context. Parameters: Name Type Description Default field_name str The name of the field to get. required initializer Callable[[], ~A] The function to initialize the field if it does not exist. required Returns: Type Description ~A The field value. Source code in treex/metrics/metric.py def get_field ( self , field_name : str , initializer : tp . Callable [[], A ], ) -> A : \"\"\" A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: * The field must be declared in the class definition. * The method can only be called inside a `compact` context. Arguments: field_name: The name of the field to get. initializer: The function to initialize the field if it does not exist. Returns: The field value. \"\"\" value : A if field_name not in self . _field_metadata : raise ValueError ( f \"Metadata for field ' { field_name } ' does not exist.\" ) if field_name in vars ( self ): value = getattr ( self , field_name ) else : if tree_m . _COMPACT_CONTEXT . in_compact and not self . first_run : raise RuntimeError ( f \"Trying to initialize field ' { field_name } ' after the first run of `compact`.\" ) value = initializer () setattr ( self , field_name , value ) return value map ( self , f , * filters , * , inplace = False , flatten_mode = None , is_leaf = None ) inherited map is a wrapper over treeo.map that passes self as the second argument. Parameters: Name Type Description Default f Callable The function to apply to the leaves. required *filters Filter The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treex/metrics/metric.py def map ( self : A , f : tp . Callable , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , is_leaf : tp . Callable [[ tp . Any ], bool ] = None , ) -> A : \"\"\" `map` is a wrapper over `treeo.map` that passes `self` as the second argument. Arguments: f: The function to apply to the leaves. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" return api . map ( f , self , * filters , inplace = inplace , flatten_mode = flatten_mode , is_leaf = is_leaf , ) merge ( self , other , * rest , * , inplace = False , flatten_mode = None , ignore_static = False ) inherited merge is a wrapper over treeo.merge that passes self as the first argument. Parameters: Name Type Description Default other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the merged values. If inplace is True , obj is returned. Source code in treex/metrics/metric.py def merge ( self : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" `merge` is a wrapper over `treeo.merge` that passes `self` as the first argument. Arguments: other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the merged values. If `inplace` is `True`, `obj` is returned. \"\"\" return api . merge ( self , other , * rest , inplace = inplace , flatten_mode = flatten_mode , ignore_static = ignore_static , ) to_dict ( self , * , private_fields = False , static_fields = True , type_info = False , field_info = False ) inherited to_dict is a wrapper over treeo.to_dict that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True type_info bool If True , type information is included. False field_info bool If True , field information is included. False Returns: Type Description Any A dict representation of the object. Source code in treex/metrics/metric.py def to_dict ( self , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : \"\"\" `to_dict` is a wrapper over `treeo.to_dict` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. type_info: If `True`, type information is included. field_info: If `True`, field information is included. Returns: A dict representation of the object. \"\"\" return api . to_dict ( self , private_fields = private_fields , static_fields = static_fields , type_info = type_info , field_info = field_info , ) to_string ( self , * , private_fields = False , static_fields = True , color = False ) inherited to_string is a wrapper over treeo.to_string that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True color bool If True , color is included. False Returns: Type Description str A string representation of the object. Source code in treex/metrics/metric.py def to_string ( self : A , * , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" `to_string` is a wrapper over `treeo.to_string` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. color: If `True`, color is included. Returns: A string representation of the object. \"\"\" return api . to_string ( self , private_fields = private_fields , static_fields = static_fields , color = color , ) train ( self , mode = True , inplace = False ) inherited Creates a new module with the same structure, but with Module.training set to the given value. Parameters: Name Type Description Default mode bool The new training mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module in with the training mode is set to the given value, if inplace is True then self is returned. Source code in treex/metrics/metric.py def train ( self : T , mode : bool = True , inplace : bool = False ) -> T : \"\"\" Creates a new module with the same structure, but with `Module.training` set to the given value. Arguments: mode: The new training mode. inplace: Whether to update the module inplace. Returns: The new module in with the training mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_training ( tree ): if isinstance ( tree , Treex ) and hasattr ( tree , \"_training\" ): tree . _training = mode return to . apply ( set_training , self , inplace = inplace ) unfreeze ( self , inplace = False ) inherited Creates a new module with .frozen set to False, equivalent to calling freeze(False) . Parameters: Name Type Description Default inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module with .frozen set to False, if inplace is True then self is returned. Source code in treex/metrics/metric.py def unfreeze ( self : T , inplace : bool = False ) -> T : \"\"\" Creates a new module with `.frozen` set to False, equivalent to calling `freeze(False)`. Arguments: inplace: Whether to update the module inplace. Returns: The new module with `.frozen` set to False, if `inplace` is `True` then `self` is returned. \"\"\" return self . freeze ( False , inplace = inplace )","title":"Metric"},{"location":"api/Metric/#treexmetric","text":"Encapsulates metric logic and state. Metrics accumulate state between calls such that their output value reflect the metric as if calculated on the whole data given up to that point.","title":"treex.Metric"},{"location":"api/Metric/#treex.metrics.metric.Metric.first_run","text":"Returns: Type Description bool True if its currently the first run of a compact method.","title":"first_run"},{"location":"api/Metric/#treex.metrics.metric.Metric.__class__","text":"","title":"__class__"},{"location":"api/Metric/#treex.metrics.metric.Metric.__class__.__base__","text":"","title":"__base__"},{"location":"api/Metric/#treex.metrics.metric.Metric.__class__.__base__.__base__","text":"Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()).","title":"__base__"},{"location":"api/Metric/#treex.metrics.metric.Metric.__class__.__base__.__base__.__instancecheck__","text":"Override for isinstance(instance, cls). Source code in treex/metrics/metric.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance )","title":"__instancecheck__()"},{"location":"api/Metric/#treex.metrics.metric.Metric.__class__.__base__.__base__.__new__","text":"Create and return a new object. See help(type) for accurate signature. Source code in treex/metrics/metric.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls","title":"__new__()"},{"location":"api/Metric/#treex.metrics.metric.Metric.__class__.__base__.__base__.__subclasscheck__","text":"Override for issubclass(subclass, cls). Source code in treex/metrics/metric.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass )","title":"__subclasscheck__()"},{"location":"api/Metric/#treex.metrics.metric.Metric.__class__.__base__.__base__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/metrics/metric.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/Metric/#treex.metrics.metric.Metric.__class__.__base__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/metrics/metric.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/Metric/#treex.metrics.metric.Metric.__class__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/metrics/metric.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/Metric/#treex.metrics.metric.Metric.__init__","text":"Parameters: Name Type Description Default on Union[str, int, Sequence[Union[str, int]]] A string or integer, or iterable of string or integers, that indicate how to index/filter the target and preds arguments before passing them to call . For example if on = \"a\" then target = target[\"a\"] . If on is an iterable the structures will be indexed iteratively, for example if on = [\"a\", 0, \"b\"] then target = target[\"a\"][0][\"b\"] , same for preds . For more information check out Keras-like behavior . None Source code in treex/metrics/metric.py def __init__ ( self , on : tp . Optional [ types . IndexLike ] = None , name : tp . Optional [ str ] = None , dtype : tp . Optional [ jnp . dtype ] = None , ): \"\"\" Arguments: on: A string or integer, or iterable of string or integers, that indicate how to index/filter the `target` and `preds` arguments before passing them to `call`. For example if `on = \"a\"` then `target = target[\"a\"]`. If `on` is an iterable the structures will be indexed iteratively, for example if `on = [\"a\", 0, \"b\"]` then `target = target[\"a\"][0][\"b\"]`, same for `preds`. For more information check out [Keras-like behavior](https://poets-ai.github.io/elegy/guides/modules-losses-metrics/#keras-like-behavior). \"\"\" self . _labels_filter = ( on ,) if isinstance ( on , ( str , int )) else on self . name = name if name is not None else utils . _get_name ( self ) self . dtype = dtype if dtype is not None else jnp . float32","title":"__init__()"},{"location":"api/Metric/#treex.metrics.metric.Metric.__init_subclass__","text":"This method is called when a class is subclassed. The default implementation does nothing. It may be overridden to extend subclasses. Source code in treex/metrics/metric.py def __init_subclass__ ( cls ): super () . __init_subclass__ () # add call signature old_call = cls . __call__ @functools . wraps ( cls . update ) def new_call ( self : M , * args , ** kwargs ) -> M : if len ( args ) > 0 : raise TypeError ( f \"All arguments to { cls . __name__ } .__call__ should be passed as keyword arguments.\" ) return old_call ( self , * args , ** kwargs ) cls . __call__ = new_call","title":"__init_subclass__()"},{"location":"api/Metric/#treex.metrics.metric.Metric.apply","text":"apply is a wrapper over treeo.apply that passes self as the second argument. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treex/metrics/metric.py def apply ( self : A , f : tp . Callable [ ... , None ], * rest : A , inplace : bool = False ) -> A : \"\"\" `apply` is a wrapper over `treeo.apply` that passes `self` as the second argument. Arguments: f: The function to apply. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" return api . apply ( f , self , * rest , inplace = inplace )","title":"apply()"},{"location":"api/Metric/#treex.metrics.metric.Metric.check_metadata_updates","text":"Checks for new fields, if found, adds them to the metadata. Source code in treex/metrics/metric.py def check_metadata_updates ( self ): \"\"\" Checks for new fields, if found, adds them to the metadata. \"\"\" with _CONTEXT . update ( flatten_mode = FlattenMode . all_fields ): jax . tree_flatten ( self )","title":"check_metadata_updates()"},{"location":"api/Metric/#treex.metrics.metric.Metric.copy","text":"copy is a wrapper over treeo.copy that passes self as the first argument. Source code in treex/metrics/metric.py def copy ( self : A ) -> A : \"\"\" `copy` is a wrapper over `treeo.copy` that passes `self` as the first argument. \"\"\" return tree_m . copy ( self )","title":"copy()"},{"location":"api/Metric/#treex.metrics.metric.Metric.eval","text":"Creates a new module with the training mode set to False, equivalent to calling train(False) . Returns: Type Description ~T The new module with the training mode set to False. Source code in treex/metrics/metric.py def eval ( self : T , inplace : bool = False ) -> T : \"\"\" Creates a new module with the training mode set to False, equivalent to calling `train(False)`. Returns: The new module with the training mode set to False. \"\"\" return self . train ( False , inplace = inplace )","title":"eval()"},{"location":"api/Metric/#treex.metrics.metric.Metric.filter","text":"filter is a wrapper over treeo.filter that passes self as the first argument. Parameters: Name Type Description Default *filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treex/metrics/metric.py def filter ( self : A , * filters : api . Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ) -> A : \"\"\" `filter` is a wrapper over `treeo.filter` that passes `self` as the first argument. Arguments: *filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" return api . filter ( self , * filters , inplace = inplace , flatten_mode = flatten_mode )","title":"filter()"},{"location":"api/Metric/#treex.metrics.metric.Metric.freeze","text":"Creates a new module with the same structure, but with Module.frozen set to the given value. Parameters: Name Type Description Default mode bool The new frozen mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module in with the frozen mode is set to the given value, if inplace is True then self is returned. Source code in treex/metrics/metric.py def freeze ( self : T , mode : bool = True , inplace : bool = False ) -> T : \"\"\" Creates a new module with the same structure, but with `Module.frozen` set to the given value. Arguments: mode: The new `frozen` mode. inplace: Whether to update the module inplace. Returns: The new module in with the `frozen` mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_frozen ( tree ): if isinstance ( tree , Treex ) and hasattr ( tree , \"_frozen\" ): tree . _frozen = mode return to . apply ( set_frozen , self , inplace = inplace )","title":"freeze()"},{"location":"api/Metric/#treex.metrics.metric.Metric.get_field","text":"A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: The field must be declared in the class definition. The method can only be called inside a compact context. Parameters: Name Type Description Default field_name str The name of the field to get. required initializer Callable[[], ~A] The function to initialize the field if it does not exist. required Returns: Type Description ~A The field value. Source code in treex/metrics/metric.py def get_field ( self , field_name : str , initializer : tp . Callable [[], A ], ) -> A : \"\"\" A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: * The field must be declared in the class definition. * The method can only be called inside a `compact` context. Arguments: field_name: The name of the field to get. initializer: The function to initialize the field if it does not exist. Returns: The field value. \"\"\" value : A if field_name not in self . _field_metadata : raise ValueError ( f \"Metadata for field ' { field_name } ' does not exist.\" ) if field_name in vars ( self ): value = getattr ( self , field_name ) else : if tree_m . _COMPACT_CONTEXT . in_compact and not self . first_run : raise RuntimeError ( f \"Trying to initialize field ' { field_name } ' after the first run of `compact`.\" ) value = initializer () setattr ( self , field_name , value ) return value","title":"get_field()"},{"location":"api/Metric/#treex.metrics.metric.Metric.map","text":"map is a wrapper over treeo.map that passes self as the second argument. Parameters: Name Type Description Default f Callable The function to apply to the leaves. required *filters Filter The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treex/metrics/metric.py def map ( self : A , f : tp . Callable , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , is_leaf : tp . Callable [[ tp . Any ], bool ] = None , ) -> A : \"\"\" `map` is a wrapper over `treeo.map` that passes `self` as the second argument. Arguments: f: The function to apply to the leaves. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" return api . map ( f , self , * filters , inplace = inplace , flatten_mode = flatten_mode , is_leaf = is_leaf , )","title":"map()"},{"location":"api/Metric/#treex.metrics.metric.Metric.merge","text":"merge is a wrapper over treeo.merge that passes self as the first argument. Parameters: Name Type Description Default other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the merged values. If inplace is True , obj is returned. Source code in treex/metrics/metric.py def merge ( self : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" `merge` is a wrapper over `treeo.merge` that passes `self` as the first argument. Arguments: other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the merged values. If `inplace` is `True`, `obj` is returned. \"\"\" return api . merge ( self , other , * rest , inplace = inplace , flatten_mode = flatten_mode , ignore_static = ignore_static , )","title":"merge()"},{"location":"api/Metric/#treex.metrics.metric.Metric.to_dict","text":"to_dict is a wrapper over treeo.to_dict that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True type_info bool If True , type information is included. False field_info bool If True , field information is included. False Returns: Type Description Any A dict representation of the object. Source code in treex/metrics/metric.py def to_dict ( self , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : \"\"\" `to_dict` is a wrapper over `treeo.to_dict` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. type_info: If `True`, type information is included. field_info: If `True`, field information is included. Returns: A dict representation of the object. \"\"\" return api . to_dict ( self , private_fields = private_fields , static_fields = static_fields , type_info = type_info , field_info = field_info , )","title":"to_dict()"},{"location":"api/Metric/#treex.metrics.metric.Metric.to_string","text":"to_string is a wrapper over treeo.to_string that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True color bool If True , color is included. False Returns: Type Description str A string representation of the object. Source code in treex/metrics/metric.py def to_string ( self : A , * , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" `to_string` is a wrapper over `treeo.to_string` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. color: If `True`, color is included. Returns: A string representation of the object. \"\"\" return api . to_string ( self , private_fields = private_fields , static_fields = static_fields , color = color , )","title":"to_string()"},{"location":"api/Metric/#treex.metrics.metric.Metric.train","text":"Creates a new module with the same structure, but with Module.training set to the given value. Parameters: Name Type Description Default mode bool The new training mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module in with the training mode is set to the given value, if inplace is True then self is returned. Source code in treex/metrics/metric.py def train ( self : T , mode : bool = True , inplace : bool = False ) -> T : \"\"\" Creates a new module with the same structure, but with `Module.training` set to the given value. Arguments: mode: The new training mode. inplace: Whether to update the module inplace. Returns: The new module in with the training mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_training ( tree ): if isinstance ( tree , Treex ) and hasattr ( tree , \"_training\" ): tree . _training = mode return to . apply ( set_training , self , inplace = inplace )","title":"train()"},{"location":"api/Metric/#treex.metrics.metric.Metric.unfreeze","text":"Creates a new module with .frozen set to False, equivalent to calling freeze(False) . Parameters: Name Type Description Default inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module with .frozen set to False, if inplace is True then self is returned. Source code in treex/metrics/metric.py def unfreeze ( self : T , inplace : bool = False ) -> T : \"\"\" Creates a new module with `.frozen` set to False, equivalent to calling `freeze(False)`. Arguments: inplace: Whether to update the module inplace. Returns: The new module with `.frozen` set to False, if `inplace` is `True` then `self` is returned. \"\"\" return self . freeze ( False , inplace = inplace )","title":"unfreeze()"},{"location":"api/MetricLog/","text":"treex.MetricLog","title":"MetricLog"},{"location":"api/MetricLog/#treexmetriclog","text":"","title":"treex.MetricLog"},{"location":"api/MetricState/","text":"treex.MetricState","title":"MetricState"},{"location":"api/MetricState/#treexmetricstate","text":"","title":"treex.MetricState"},{"location":"api/Missing/","text":"treex.Missing","title":"Missing"},{"location":"api/Missing/#treexmissing","text":"","title":"treex.Missing"},{"location":"api/ModelState/","text":"treex.ModelState","title":"ModelState"},{"location":"api/ModelState/#treexmodelstate","text":"","title":"treex.ModelState"},{"location":"api/Module/","text":"treex.Module first_run : bool inherited property readonly Returns: Type Description bool True if its currently the first run of a compact method. __class__ inherited __base__ inherited __base__ inherited Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()). __instancecheck__ ( cls , instance ) special Override for isinstance(instance, cls). Source code in treex/module.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance ) __new__ ( mcls , name , bases , namespace , ** kwargs ) special staticmethod Create and return a new object. See help(type) for accurate signature. Source code in treex/module.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls __subclasscheck__ ( cls , subclass ) special Override for issubclass(subclass, cls). Source code in treex/module.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass ) register ( cls , subclass ) Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/module.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) register ( cls , subclass ) inherited Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/module.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) register ( cls , subclass ) inherited Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/module.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) __init_subclass__ () classmethod special This method is called when a class is subclassed. The default implementation does nothing. It may be overridden to extend subclasses. Source code in treex/module.py def __init_subclass__ ( cls ): if issubclass ( cls , tp . Callable ): orig_call = cls . __call__ @functools . wraps ( cls . __call__ ) def new_call ( self : Module , * args , ** kwargs ): outputs = orig_call ( self , * args , ** kwargs ) if ( contexts . _CONTEXT . call_info is not None and self not in contexts . _CONTEXT . call_info ): inputs = types . Inputs ( * args , ** kwargs ) contexts . _CONTEXT . call_info [ self ] = ( inputs , outputs ) return outputs cls . __call__ = new_call return super () . __init_subclass__ () apply ( self , f , * rest , * , inplace = False ) inherited apply is a wrapper over treeo.apply that passes self as the second argument. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treex/module.py def apply ( self : A , f : tp . Callable [ ... , None ], * rest : A , inplace : bool = False ) -> A : \"\"\" `apply` is a wrapper over `treeo.apply` that passes `self` as the second argument. Arguments: f: The function to apply. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" return api . apply ( f , self , * rest , inplace = inplace ) batch_stats ( self , * filters ) inherited Returns a copy of the Module with only tx.BatchStat TreeParts, alias for filter(tx.BatchStat) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/module.py def batch_stats ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.BatchStat TreeParts, alias for `filter(tx.BatchStat)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . BatchStat , * filters ) check_metadata_updates ( self ) inherited Checks for new fields, if found, adds them to the metadata. Source code in treex/module.py def check_metadata_updates ( self ): \"\"\" Checks for new fields, if found, adds them to the metadata. \"\"\" with _CONTEXT . update ( flatten_mode = FlattenMode . all_fields ): jax . tree_flatten ( self ) copy ( self ) inherited copy is a wrapper over treeo.copy that passes self as the first argument. Source code in treex/module.py def copy ( self : A ) -> A : \"\"\" `copy` is a wrapper over `treeo.copy` that passes `self` as the first argument. \"\"\" return tree_m . copy ( self ) eval ( self , inplace = False ) inherited Creates a new module with the training mode set to False, equivalent to calling train(False) . Returns: Type Description ~T The new module with the training mode set to False. Source code in treex/module.py def eval ( self : T , inplace : bool = False ) -> T : \"\"\" Creates a new module with the training mode set to False, equivalent to calling `train(False)`. Returns: The new module with the training mode set to False. \"\"\" return self . train ( False , inplace = inplace ) filter ( self , * filters , * , inplace = False , flatten_mode = None ) inherited filter is a wrapper over treeo.filter that passes self as the first argument. Parameters: Name Type Description Default *filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treex/module.py def filter ( self : A , * filters : api . Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ) -> A : \"\"\" `filter` is a wrapper over `treeo.filter` that passes `self` as the first argument. Arguments: *filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" return api . filter ( self , * filters , inplace = inplace , flatten_mode = flatten_mode ) freeze ( self , mode = True , inplace = False ) inherited Creates a new module with the same structure, but with Module.frozen set to the given value. Parameters: Name Type Description Default mode bool The new frozen mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module in with the frozen mode is set to the given value, if inplace is True then self is returned. Source code in treex/module.py def freeze ( self : T , mode : bool = True , inplace : bool = False ) -> T : \"\"\" Creates a new module with the same structure, but with `Module.frozen` set to the given value. Arguments: mode: The new `frozen` mode. inplace: Whether to update the module inplace. Returns: The new module in with the `frozen` mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_frozen ( tree ): if isinstance ( tree , Treex ) and hasattr ( tree , \"_frozen\" ): tree . _frozen = mode return to . apply ( set_frozen , self , inplace = inplace ) get_field ( self , field_name , initializer ) inherited A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: The field must be declared in the class definition. The method can only be called inside a compact context. Parameters: Name Type Description Default field_name str The name of the field to get. required initializer Callable[[], ~A] The function to initialize the field if it does not exist. required Returns: Type Description ~A The field value. Source code in treex/module.py def get_field ( self , field_name : str , initializer : tp . Callable [[], A ], ) -> A : \"\"\" A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: * The field must be declared in the class definition. * The method can only be called inside a `compact` context. Arguments: field_name: The name of the field to get. initializer: The function to initialize the field if it does not exist. Returns: The field value. \"\"\" value : A if field_name not in self . _field_metadata : raise ValueError ( f \"Metadata for field ' { field_name } ' does not exist.\" ) if field_name in vars ( self ): value = getattr ( self , field_name ) else : if tree_m . _COMPACT_CONTEXT . in_compact and not self . first_run : raise RuntimeError ( f \"Trying to initialize field ' { field_name } ' after the first run of `compact`.\" ) value = initializer () setattr ( self , field_name , value ) return value init ( self , key , inputs =< treeo . types . Missing object at 0x7f29ce5c9220 > , call_method = '__call__' , * , inplace = False , _set_initialize = True ) Method version of tx.init , it applies self as first argument. init creates a new module with the same structure, but with its fields initialized given a seed key . The following procedure is used: The input key is split and iteratively updated before passing a derived value to any process that requires initialization. Initializer s are called and applied to the module first. Module.rng_init methods are called last. Parameters: Name Type Description Default key Union[int, jax._src.numpy.lax_numpy.ndarray] The seed to use for initialization. required Returns: Type Description ~M The new module with the fields initialized. Source code in treex/module.py def init ( self : M , key : tp . Union [ int , jnp . ndarray ], inputs : types . InputLike = to . MISSING , call_method : str = \"__call__\" , * , inplace : bool = False , _set_initialize : bool = True , ) -> M : \"\"\" Method version of `tx.init`, it applies `self` as first argument. `init` creates a new module with the same structure, but with its fields initialized given a seed `key`. The following procedure is used: 1. The input `key` is split and iteratively updated before passing a derived value to any process that requires initialization. 2. `Initializer`s are called and applied to the module first. 3. `Module.rng_init` methods are called last. Arguments: key: The seed to use for initialization. Returns: The new module with the fields initialized. \"\"\" module = self . copy () if not inplace else self key = utils . Key ( key ) with _INIT_CONTEXT . update ( key = key , initializing = True ): module : M = module . map ( lambda initializer : ( initializer ( next_key ()) if isinstance ( initializer , types . Initializer ) else initializer ), is_leaf = lambda x : isinstance ( x , types . Initializer ), inplace = True , ) def call_rng_init ( module : Module ): if isinstance ( module , Module ) and not module . _initialized : module . rng_init () module = to . apply ( call_rng_init , module , inplace = True ) if inputs is not to . MISSING : inputs = types . Inputs . from_value ( inputs ) method = getattr ( module , call_method ) method ( * inputs . args , ** inputs . kwargs ) if _set_initialize : def set_initialized ( module : Module ): if isinstance ( module , Module ) and not module . _initialized : module . _initialized = True module = to . apply ( set_initialized , module , inplace = True ) return module logs ( self , * filters ) inherited Returns a copy of the Module with only tx.Log TreeParts, alias for filter(tx.Log) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/module.py def logs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Log TreeParts, alias for `filter(tx.Log)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . Log , * filters ) loss_logs ( self , * filters ) inherited Returns a copy of the Module with only tx.Loss TreeParts, alias for filter(tx.Loss) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/module.py def loss_logs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Loss TreeParts, alias for `filter(tx.Loss)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . LossLog , * filters ) map ( self , f , * filters , * , inplace = False , flatten_mode = None , is_leaf = None ) inherited map is a wrapper over treeo.map that passes self as the second argument. Parameters: Name Type Description Default f Callable The function to apply to the leaves. required *filters Filter The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treex/module.py def map ( self : A , f : tp . Callable , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , is_leaf : tp . Callable [[ tp . Any ], bool ] = None , ) -> A : \"\"\" `map` is a wrapper over `treeo.map` that passes `self` as the second argument. Arguments: f: The function to apply to the leaves. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" return api . map ( f , self , * filters , inplace = inplace , flatten_mode = flatten_mode , is_leaf = is_leaf , ) merge ( self , other , * rest , * , inplace = False , flatten_mode = None , ignore_static = False ) inherited merge is a wrapper over treeo.merge that passes self as the first argument. Parameters: Name Type Description Default other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the merged values. If inplace is True , obj is returned. Source code in treex/module.py def merge ( self : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" `merge` is a wrapper over `treeo.merge` that passes `self` as the first argument. Arguments: other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the merged values. If `inplace` is `True`, `obj` is returned. \"\"\" return api . merge ( self , other , * rest , inplace = inplace , flatten_mode = flatten_mode , ignore_static = ignore_static , ) metric_logs ( self , * filters ) inherited Returns a copy of the Module with only tx.Metric TreeParts, alias for filter(tx.Metric) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/module.py def metric_logs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Metric TreeParts, alias for `filter(tx.Metric)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . MetricLog , * filters ) model_states ( self , * filters ) inherited Returns a copy of the Module with only tx.ModelState TreeParts, alias for filter(tx.ModelState) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/module.py def model_states ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.ModelState TreeParts, alias for `filter(tx.ModelState)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . ModelState , * filters ) parameters ( self , * filters ) inherited Returns a copy of the Module with only tx.Parameter TreeParts, alias for filter(tx.Parameter) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/module.py def parameters ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Parameter TreeParts, alias for `filter(tx.Parameter)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . Parameter , * filters ) rngs ( self , * filters ) inherited Returns a copy of the Module with only tx.Rng TreeParts, alias for filter(tx.Rng) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/module.py def rngs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Rng TreeParts, alias for `filter(tx.Rng)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . Rng , * filters ) states ( self , * filters ) inherited Returns a copy of the Module with only tx.State TreeParts, alias for filter(tx.State) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/module.py def states ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.State TreeParts, alias for `filter(tx.State)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . State , * filters ) tabulate ( self , inputs =< treeo . types . Missing object at 0x7f29ce5c9220 > , depth =- 1 , signature = False , param_types = True ) Returns a tabular representation of the module. Parameters: Name Type Description Default depth int The maximum depth of the representation in terms of nested Modules, -1 means no limit. -1 signature bool Whether to show the signature of the Module. False param_types bool Whether to show the types of the parameters. True Returns: Type Description str A string containing the tabular representation. Source code in treex/module.py def tabulate ( self , inputs : tp . Union [ types . InputLike , to . Missing ] = to . MISSING , depth : int = - 1 , signature : bool = False , param_types : bool = True , ) -> str : \"\"\" Returns a tabular representation of the module. Arguments: depth: The maximum depth of the representation in terms of nested Modules, -1 means no limit. signature: Whether to show the signature of the Module. param_types: Whether to show the types of the parameters. Returns: A string containing the tabular representation. \"\"\" self = to . copy ( self ) if inputs is not to . MISSING : inputs = types . Inputs . from_value ( inputs ) if not isinstance ( self , tp . Callable ): raise TypeError ( \"`inputs` can only be specified if the module is a callable.\" ) with contexts . _Context ( call_info = {}): # call using self to preserve references def eval_call ( args , kwargs ): assert isinstance ( self , tp . Callable ) return self ( * args , ** kwargs ) jax . eval_shape ( eval_call , inputs . args , inputs . kwargs , ) call_info = contexts . _CONTEXT . call_info else : call_info = None with to . add_field_info (): flat : tp . List [ to . FieldInfo ] flat , _ = jax . tree_flatten ( self ) tree_part_types : tp . Tuple [ tp . Type [ types . TreePart ], ... ] = tuple ( { field_info . kind for field_info in flat if utils . _generic_issubclass ( field_info . kind , types . TreePart ) } ) path = () rows = list ( utils . _get_tabulate_rows ( path , self , depth , tree_part_types , signature , param_types ) ) modules = [ row [ 0 ] for row in rows ] rows = [ row [ 1 :] for row in rows ] if call_info is not None : for module , row in zip ( modules , rows ): if module in call_info : inputs , outputs = call_info [ module ] simplified_inputs = ( inputs . args [ 0 ] if len ( inputs . kwargs ) == 0 and len ( inputs . args ) == 1 else inputs . kwargs if len ( inputs . kwargs ) == 0 else inputs . kwargs if len ( inputs . args ) == 0 else ( inputs . args , inputs . kwargs ) ) inputs_repr = utils . _format_param_tree ( simplified_inputs ) outputs_repr = utils . _format_param_tree ( outputs ) else : inputs_repr = \"\" outputs_repr = \"\" row . insert ( 3 , outputs_repr ) row . insert ( 3 , inputs_repr ) n_non_treepart_cols = 2 if call_info is None else 4 rows [ 0 ][ 0 ] = \"*\" rows . append ( [ \"\" ] * n_non_treepart_cols + [ \"Total:\" ] + [ utils . _format_obj_size ( self . filter ( kind ), add_padding = True ) for kind in tree_part_types ] ) utils . _add_padding ( rows ) table = Table ( show_header = True , show_lines = True , show_footer = True , # box=rich.box.HORIZONTALS, ) table . add_column ( \"path\" ) table . add_column ( \"module\" ) table . add_column ( \"params\" ) if call_info is not None : table . add_column ( \"inputs\" ) table . add_column ( \"outputs\" ) for tree_part_type in tree_part_types : type_name = tree_part_type . __name__ if type_name . startswith ( \"_\" ): type_name = type_name [ 1 :] table . add_column ( type_name ) for row in rows [: - 1 ]: table . add_row ( * row ) table . columns [ n_non_treepart_cols ] . footer = Text . from_markup ( rows [ - 1 ][ n_non_treepart_cols ], justify = \"right\" ) for i in range ( len ( tree_part_types )): table . columns [ n_non_treepart_cols + 1 + i ] . footer = rows [ - 1 ][ n_non_treepart_cols + 1 + i ] table . caption_style = \"bold\" table . caption = \" \\n Total Parameters: \" + utils . _format_obj_size ( self , add_padding = False ) return utils . _get_rich_repr ( table ) to_dict ( self , * , private_fields = False , static_fields = True , type_info = False , field_info = False ) inherited to_dict is a wrapper over treeo.to_dict that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True type_info bool If True , type information is included. False field_info bool If True , field information is included. False Returns: Type Description Any A dict representation of the object. Source code in treex/module.py def to_dict ( self , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : \"\"\" `to_dict` is a wrapper over `treeo.to_dict` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. type_info: If `True`, type information is included. field_info: If `True`, field information is included. Returns: A dict representation of the object. \"\"\" return api . to_dict ( self , private_fields = private_fields , static_fields = static_fields , type_info = type_info , field_info = field_info , ) to_string ( self , * , private_fields = False , static_fields = True , color = False ) inherited to_string is a wrapper over treeo.to_string that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True color bool If True , color is included. False Returns: Type Description str A string representation of the object. Source code in treex/module.py def to_string ( self : A , * , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" `to_string` is a wrapper over `treeo.to_string` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. color: If `True`, color is included. Returns: A string representation of the object. \"\"\" return api . to_string ( self , private_fields = private_fields , static_fields = static_fields , color = color , ) train ( self , mode = True , inplace = False ) inherited Creates a new module with the same structure, but with Module.training set to the given value. Parameters: Name Type Description Default mode bool The new training mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module in with the training mode is set to the given value, if inplace is True then self is returned. Source code in treex/module.py def train ( self : T , mode : bool = True , inplace : bool = False ) -> T : \"\"\" Creates a new module with the same structure, but with `Module.training` set to the given value. Arguments: mode: The new training mode. inplace: Whether to update the module inplace. Returns: The new module in with the training mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_training ( tree ): if isinstance ( tree , Treex ) and hasattr ( tree , \"_training\" ): tree . _training = mode return to . apply ( set_training , self , inplace = inplace ) unfreeze ( self , inplace = False ) inherited Creates a new module with .frozen set to False, equivalent to calling freeze(False) . Parameters: Name Type Description Default inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module with .frozen set to False, if inplace is True then self is returned. Source code in treex/module.py def unfreeze ( self : T , inplace : bool = False ) -> T : \"\"\" Creates a new module with `.frozen` set to False, equivalent to calling `freeze(False)`. Arguments: inplace: Whether to update the module inplace. Returns: The new module with `.frozen` set to False, if `inplace` is `True` then `self` is returned. \"\"\" return self . freeze ( False , inplace = inplace )","title":"Module"},{"location":"api/Module/#treexmodule","text":"","title":"treex.Module"},{"location":"api/Module/#treex.module.Module.first_run","text":"Returns: Type Description bool True if its currently the first run of a compact method.","title":"first_run"},{"location":"api/Module/#treex.module.Module.__class__","text":"","title":"__class__"},{"location":"api/Module/#treex.module.Module.__class__.__base__","text":"","title":"__base__"},{"location":"api/Module/#treex.module.Module.__class__.__base__.__base__","text":"Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()).","title":"__base__"},{"location":"api/Module/#treex.module.Module.__class__.__base__.__base__.__instancecheck__","text":"Override for isinstance(instance, cls). Source code in treex/module.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance )","title":"__instancecheck__()"},{"location":"api/Module/#treex.module.Module.__class__.__base__.__base__.__new__","text":"Create and return a new object. See help(type) for accurate signature. Source code in treex/module.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls","title":"__new__()"},{"location":"api/Module/#treex.module.Module.__class__.__base__.__base__.__subclasscheck__","text":"Override for issubclass(subclass, cls). Source code in treex/module.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass )","title":"__subclasscheck__()"},{"location":"api/Module/#treex.module.Module.__class__.__base__.__base__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/module.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/Module/#treex.module.Module.__class__.__base__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/module.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/Module/#treex.module.Module.__class__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/module.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/Module/#treex.module.Module.__init_subclass__","text":"This method is called when a class is subclassed. The default implementation does nothing. It may be overridden to extend subclasses. Source code in treex/module.py def __init_subclass__ ( cls ): if issubclass ( cls , tp . Callable ): orig_call = cls . __call__ @functools . wraps ( cls . __call__ ) def new_call ( self : Module , * args , ** kwargs ): outputs = orig_call ( self , * args , ** kwargs ) if ( contexts . _CONTEXT . call_info is not None and self not in contexts . _CONTEXT . call_info ): inputs = types . Inputs ( * args , ** kwargs ) contexts . _CONTEXT . call_info [ self ] = ( inputs , outputs ) return outputs cls . __call__ = new_call return super () . __init_subclass__ ()","title":"__init_subclass__()"},{"location":"api/Module/#treex.module.Module.apply","text":"apply is a wrapper over treeo.apply that passes self as the second argument. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treex/module.py def apply ( self : A , f : tp . Callable [ ... , None ], * rest : A , inplace : bool = False ) -> A : \"\"\" `apply` is a wrapper over `treeo.apply` that passes `self` as the second argument. Arguments: f: The function to apply. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" return api . apply ( f , self , * rest , inplace = inplace )","title":"apply()"},{"location":"api/Module/#treex.module.Module.batch_stats","text":"Returns a copy of the Module with only tx.BatchStat TreeParts, alias for filter(tx.BatchStat) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/module.py def batch_stats ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.BatchStat TreeParts, alias for `filter(tx.BatchStat)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . BatchStat , * filters )","title":"batch_stats()"},{"location":"api/Module/#treex.module.Module.check_metadata_updates","text":"Checks for new fields, if found, adds them to the metadata. Source code in treex/module.py def check_metadata_updates ( self ): \"\"\" Checks for new fields, if found, adds them to the metadata. \"\"\" with _CONTEXT . update ( flatten_mode = FlattenMode . all_fields ): jax . tree_flatten ( self )","title":"check_metadata_updates()"},{"location":"api/Module/#treex.module.Module.copy","text":"copy is a wrapper over treeo.copy that passes self as the first argument. Source code in treex/module.py def copy ( self : A ) -> A : \"\"\" `copy` is a wrapper over `treeo.copy` that passes `self` as the first argument. \"\"\" return tree_m . copy ( self )","title":"copy()"},{"location":"api/Module/#treex.module.Module.eval","text":"Creates a new module with the training mode set to False, equivalent to calling train(False) . Returns: Type Description ~T The new module with the training mode set to False. Source code in treex/module.py def eval ( self : T , inplace : bool = False ) -> T : \"\"\" Creates a new module with the training mode set to False, equivalent to calling `train(False)`. Returns: The new module with the training mode set to False. \"\"\" return self . train ( False , inplace = inplace )","title":"eval()"},{"location":"api/Module/#treex.module.Module.filter","text":"filter is a wrapper over treeo.filter that passes self as the first argument. Parameters: Name Type Description Default *filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treex/module.py def filter ( self : A , * filters : api . Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ) -> A : \"\"\" `filter` is a wrapper over `treeo.filter` that passes `self` as the first argument. Arguments: *filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" return api . filter ( self , * filters , inplace = inplace , flatten_mode = flatten_mode )","title":"filter()"},{"location":"api/Module/#treex.module.Module.freeze","text":"Creates a new module with the same structure, but with Module.frozen set to the given value. Parameters: Name Type Description Default mode bool The new frozen mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module in with the frozen mode is set to the given value, if inplace is True then self is returned. Source code in treex/module.py def freeze ( self : T , mode : bool = True , inplace : bool = False ) -> T : \"\"\" Creates a new module with the same structure, but with `Module.frozen` set to the given value. Arguments: mode: The new `frozen` mode. inplace: Whether to update the module inplace. Returns: The new module in with the `frozen` mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_frozen ( tree ): if isinstance ( tree , Treex ) and hasattr ( tree , \"_frozen\" ): tree . _frozen = mode return to . apply ( set_frozen , self , inplace = inplace )","title":"freeze()"},{"location":"api/Module/#treex.module.Module.get_field","text":"A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: The field must be declared in the class definition. The method can only be called inside a compact context. Parameters: Name Type Description Default field_name str The name of the field to get. required initializer Callable[[], ~A] The function to initialize the field if it does not exist. required Returns: Type Description ~A The field value. Source code in treex/module.py def get_field ( self , field_name : str , initializer : tp . Callable [[], A ], ) -> A : \"\"\" A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: * The field must be declared in the class definition. * The method can only be called inside a `compact` context. Arguments: field_name: The name of the field to get. initializer: The function to initialize the field if it does not exist. Returns: The field value. \"\"\" value : A if field_name not in self . _field_metadata : raise ValueError ( f \"Metadata for field ' { field_name } ' does not exist.\" ) if field_name in vars ( self ): value = getattr ( self , field_name ) else : if tree_m . _COMPACT_CONTEXT . in_compact and not self . first_run : raise RuntimeError ( f \"Trying to initialize field ' { field_name } ' after the first run of `compact`.\" ) value = initializer () setattr ( self , field_name , value ) return value","title":"get_field()"},{"location":"api/Module/#treex.module.Module.init","text":"Method version of tx.init , it applies self as first argument. init creates a new module with the same structure, but with its fields initialized given a seed key . The following procedure is used: The input key is split and iteratively updated before passing a derived value to any process that requires initialization. Initializer s are called and applied to the module first. Module.rng_init methods are called last. Parameters: Name Type Description Default key Union[int, jax._src.numpy.lax_numpy.ndarray] The seed to use for initialization. required Returns: Type Description ~M The new module with the fields initialized. Source code in treex/module.py def init ( self : M , key : tp . Union [ int , jnp . ndarray ], inputs : types . InputLike = to . MISSING , call_method : str = \"__call__\" , * , inplace : bool = False , _set_initialize : bool = True , ) -> M : \"\"\" Method version of `tx.init`, it applies `self` as first argument. `init` creates a new module with the same structure, but with its fields initialized given a seed `key`. The following procedure is used: 1. The input `key` is split and iteratively updated before passing a derived value to any process that requires initialization. 2. `Initializer`s are called and applied to the module first. 3. `Module.rng_init` methods are called last. Arguments: key: The seed to use for initialization. Returns: The new module with the fields initialized. \"\"\" module = self . copy () if not inplace else self key = utils . Key ( key ) with _INIT_CONTEXT . update ( key = key , initializing = True ): module : M = module . map ( lambda initializer : ( initializer ( next_key ()) if isinstance ( initializer , types . Initializer ) else initializer ), is_leaf = lambda x : isinstance ( x , types . Initializer ), inplace = True , ) def call_rng_init ( module : Module ): if isinstance ( module , Module ) and not module . _initialized : module . rng_init () module = to . apply ( call_rng_init , module , inplace = True ) if inputs is not to . MISSING : inputs = types . Inputs . from_value ( inputs ) method = getattr ( module , call_method ) method ( * inputs . args , ** inputs . kwargs ) if _set_initialize : def set_initialized ( module : Module ): if isinstance ( module , Module ) and not module . _initialized : module . _initialized = True module = to . apply ( set_initialized , module , inplace = True ) return module","title":"init()"},{"location":"api/Module/#treex.module.Module.logs","text":"Returns a copy of the Module with only tx.Log TreeParts, alias for filter(tx.Log) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/module.py def logs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Log TreeParts, alias for `filter(tx.Log)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . Log , * filters )","title":"logs()"},{"location":"api/Module/#treex.module.Module.loss_logs","text":"Returns a copy of the Module with only tx.Loss TreeParts, alias for filter(tx.Loss) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/module.py def loss_logs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Loss TreeParts, alias for `filter(tx.Loss)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . LossLog , * filters )","title":"loss_logs()"},{"location":"api/Module/#treex.module.Module.map","text":"map is a wrapper over treeo.map that passes self as the second argument. Parameters: Name Type Description Default f Callable The function to apply to the leaves. required *filters Filter The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treex/module.py def map ( self : A , f : tp . Callable , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , is_leaf : tp . Callable [[ tp . Any ], bool ] = None , ) -> A : \"\"\" `map` is a wrapper over `treeo.map` that passes `self` as the second argument. Arguments: f: The function to apply to the leaves. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" return api . map ( f , self , * filters , inplace = inplace , flatten_mode = flatten_mode , is_leaf = is_leaf , )","title":"map()"},{"location":"api/Module/#treex.module.Module.merge","text":"merge is a wrapper over treeo.merge that passes self as the first argument. Parameters: Name Type Description Default other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the merged values. If inplace is True , obj is returned. Source code in treex/module.py def merge ( self : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" `merge` is a wrapper over `treeo.merge` that passes `self` as the first argument. Arguments: other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the merged values. If `inplace` is `True`, `obj` is returned. \"\"\" return api . merge ( self , other , * rest , inplace = inplace , flatten_mode = flatten_mode , ignore_static = ignore_static , )","title":"merge()"},{"location":"api/Module/#treex.module.Module.metric_logs","text":"Returns a copy of the Module with only tx.Metric TreeParts, alias for filter(tx.Metric) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/module.py def metric_logs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Metric TreeParts, alias for `filter(tx.Metric)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . MetricLog , * filters )","title":"metric_logs()"},{"location":"api/Module/#treex.module.Module.model_states","text":"Returns a copy of the Module with only tx.ModelState TreeParts, alias for filter(tx.ModelState) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/module.py def model_states ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.ModelState TreeParts, alias for `filter(tx.ModelState)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . ModelState , * filters )","title":"model_states()"},{"location":"api/Module/#treex.module.Module.parameters","text":"Returns a copy of the Module with only tx.Parameter TreeParts, alias for filter(tx.Parameter) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/module.py def parameters ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Parameter TreeParts, alias for `filter(tx.Parameter)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . Parameter , * filters )","title":"parameters()"},{"location":"api/Module/#treex.module.Module.rngs","text":"Returns a copy of the Module with only tx.Rng TreeParts, alias for filter(tx.Rng) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/module.py def rngs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Rng TreeParts, alias for `filter(tx.Rng)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . Rng , * filters )","title":"rngs()"},{"location":"api/Module/#treex.module.Module.states","text":"Returns a copy of the Module with only tx.State TreeParts, alias for filter(tx.State) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/module.py def states ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.State TreeParts, alias for `filter(tx.State)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . State , * filters )","title":"states()"},{"location":"api/Module/#treex.module.Module.tabulate","text":"Returns a tabular representation of the module. Parameters: Name Type Description Default depth int The maximum depth of the representation in terms of nested Modules, -1 means no limit. -1 signature bool Whether to show the signature of the Module. False param_types bool Whether to show the types of the parameters. True Returns: Type Description str A string containing the tabular representation. Source code in treex/module.py def tabulate ( self , inputs : tp . Union [ types . InputLike , to . Missing ] = to . MISSING , depth : int = - 1 , signature : bool = False , param_types : bool = True , ) -> str : \"\"\" Returns a tabular representation of the module. Arguments: depth: The maximum depth of the representation in terms of nested Modules, -1 means no limit. signature: Whether to show the signature of the Module. param_types: Whether to show the types of the parameters. Returns: A string containing the tabular representation. \"\"\" self = to . copy ( self ) if inputs is not to . MISSING : inputs = types . Inputs . from_value ( inputs ) if not isinstance ( self , tp . Callable ): raise TypeError ( \"`inputs` can only be specified if the module is a callable.\" ) with contexts . _Context ( call_info = {}): # call using self to preserve references def eval_call ( args , kwargs ): assert isinstance ( self , tp . Callable ) return self ( * args , ** kwargs ) jax . eval_shape ( eval_call , inputs . args , inputs . kwargs , ) call_info = contexts . _CONTEXT . call_info else : call_info = None with to . add_field_info (): flat : tp . List [ to . FieldInfo ] flat , _ = jax . tree_flatten ( self ) tree_part_types : tp . Tuple [ tp . Type [ types . TreePart ], ... ] = tuple ( { field_info . kind for field_info in flat if utils . _generic_issubclass ( field_info . kind , types . TreePart ) } ) path = () rows = list ( utils . _get_tabulate_rows ( path , self , depth , tree_part_types , signature , param_types ) ) modules = [ row [ 0 ] for row in rows ] rows = [ row [ 1 :] for row in rows ] if call_info is not None : for module , row in zip ( modules , rows ): if module in call_info : inputs , outputs = call_info [ module ] simplified_inputs = ( inputs . args [ 0 ] if len ( inputs . kwargs ) == 0 and len ( inputs . args ) == 1 else inputs . kwargs if len ( inputs . kwargs ) == 0 else inputs . kwargs if len ( inputs . args ) == 0 else ( inputs . args , inputs . kwargs ) ) inputs_repr = utils . _format_param_tree ( simplified_inputs ) outputs_repr = utils . _format_param_tree ( outputs ) else : inputs_repr = \"\" outputs_repr = \"\" row . insert ( 3 , outputs_repr ) row . insert ( 3 , inputs_repr ) n_non_treepart_cols = 2 if call_info is None else 4 rows [ 0 ][ 0 ] = \"*\" rows . append ( [ \"\" ] * n_non_treepart_cols + [ \"Total:\" ] + [ utils . _format_obj_size ( self . filter ( kind ), add_padding = True ) for kind in tree_part_types ] ) utils . _add_padding ( rows ) table = Table ( show_header = True , show_lines = True , show_footer = True , # box=rich.box.HORIZONTALS, ) table . add_column ( \"path\" ) table . add_column ( \"module\" ) table . add_column ( \"params\" ) if call_info is not None : table . add_column ( \"inputs\" ) table . add_column ( \"outputs\" ) for tree_part_type in tree_part_types : type_name = tree_part_type . __name__ if type_name . startswith ( \"_\" ): type_name = type_name [ 1 :] table . add_column ( type_name ) for row in rows [: - 1 ]: table . add_row ( * row ) table . columns [ n_non_treepart_cols ] . footer = Text . from_markup ( rows [ - 1 ][ n_non_treepart_cols ], justify = \"right\" ) for i in range ( len ( tree_part_types )): table . columns [ n_non_treepart_cols + 1 + i ] . footer = rows [ - 1 ][ n_non_treepart_cols + 1 + i ] table . caption_style = \"bold\" table . caption = \" \\n Total Parameters: \" + utils . _format_obj_size ( self , add_padding = False ) return utils . _get_rich_repr ( table )","title":"tabulate()"},{"location":"api/Module/#treex.module.Module.to_dict","text":"to_dict is a wrapper over treeo.to_dict that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True type_info bool If True , type information is included. False field_info bool If True , field information is included. False Returns: Type Description Any A dict representation of the object. Source code in treex/module.py def to_dict ( self , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : \"\"\" `to_dict` is a wrapper over `treeo.to_dict` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. type_info: If `True`, type information is included. field_info: If `True`, field information is included. Returns: A dict representation of the object. \"\"\" return api . to_dict ( self , private_fields = private_fields , static_fields = static_fields , type_info = type_info , field_info = field_info , )","title":"to_dict()"},{"location":"api/Module/#treex.module.Module.to_string","text":"to_string is a wrapper over treeo.to_string that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True color bool If True , color is included. False Returns: Type Description str A string representation of the object. Source code in treex/module.py def to_string ( self : A , * , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" `to_string` is a wrapper over `treeo.to_string` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. color: If `True`, color is included. Returns: A string representation of the object. \"\"\" return api . to_string ( self , private_fields = private_fields , static_fields = static_fields , color = color , )","title":"to_string()"},{"location":"api/Module/#treex.module.Module.train","text":"Creates a new module with the same structure, but with Module.training set to the given value. Parameters: Name Type Description Default mode bool The new training mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module in with the training mode is set to the given value, if inplace is True then self is returned. Source code in treex/module.py def train ( self : T , mode : bool = True , inplace : bool = False ) -> T : \"\"\" Creates a new module with the same structure, but with `Module.training` set to the given value. Arguments: mode: The new training mode. inplace: Whether to update the module inplace. Returns: The new module in with the training mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_training ( tree ): if isinstance ( tree , Treex ) and hasattr ( tree , \"_training\" ): tree . _training = mode return to . apply ( set_training , self , inplace = inplace )","title":"train()"},{"location":"api/Module/#treex.module.Module.unfreeze","text":"Creates a new module with .frozen set to False, equivalent to calling freeze(False) . Parameters: Name Type Description Default inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module with .frozen set to False, if inplace is True then self is returned. Source code in treex/module.py def unfreeze ( self : T , inplace : bool = False ) -> T : \"\"\" Creates a new module with `.frozen` set to False, equivalent to calling `freeze(False)`. Arguments: inplace: Whether to update the module inplace. Returns: The new module with `.frozen` set to False, if `inplace` is `True` then `self` is returned. \"\"\" return self . freeze ( False , inplace = inplace )","title":"unfreeze()"},{"location":"api/ModuleMeta/","text":"treex.ModuleMeta __base__ inherited __base__ inherited Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()). __instancecheck__ ( cls , instance ) special Override for isinstance(instance, cls). Source code in treex/module.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance ) __new__ ( mcls , name , bases , namespace , ** kwargs ) special staticmethod Create and return a new object. See help(type) for accurate signature. Source code in treex/module.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls __subclasscheck__ ( cls , subclass ) special Override for issubclass(subclass, cls). Source code in treex/module.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass ) register ( cls , subclass ) Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/module.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) register ( cls , subclass ) inherited Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/module.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) register ( cls , subclass ) inherited Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/module.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"ModuleMeta"},{"location":"api/ModuleMeta/#treexmodulemeta","text":"","title":"treex.ModuleMeta"},{"location":"api/ModuleMeta/#treex.module.ModuleMeta.__base__","text":"","title":"__base__"},{"location":"api/ModuleMeta/#treex.module.ModuleMeta.__base__.__base__","text":"Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()).","title":"__base__"},{"location":"api/ModuleMeta/#treex.module.ModuleMeta.__base__.__base__.__instancecheck__","text":"Override for isinstance(instance, cls). Source code in treex/module.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance )","title":"__instancecheck__()"},{"location":"api/ModuleMeta/#treex.module.ModuleMeta.__base__.__base__.__new__","text":"Create and return a new object. See help(type) for accurate signature. Source code in treex/module.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls","title":"__new__()"},{"location":"api/ModuleMeta/#treex.module.ModuleMeta.__base__.__base__.__subclasscheck__","text":"Override for issubclass(subclass, cls). Source code in treex/module.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass )","title":"__subclasscheck__()"},{"location":"api/ModuleMeta/#treex.module.ModuleMeta.__base__.__base__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/module.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/ModuleMeta/#treex.module.ModuleMeta.__base__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/module.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/ModuleMeta/#treex.module.ModuleMeta.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/module.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/Named/","text":"treex.Named Named( args, *kwds)","title":"Named"},{"location":"api/Named/#treexnamed","text":"Named( args, *kwds)","title":"treex.Named"},{"location":"api/Nothing/","text":"treex.Nothing","title":"Nothing"},{"location":"api/Nothing/#treexnothing","text":"","title":"treex.Nothing"},{"location":"api/Opaque/","text":"treex.Opaque","title":"Opaque"},{"location":"api/Opaque/#treexopaque","text":"","title":"treex.Opaque"},{"location":"api/OptState/","text":"treex.OptState","title":"OptState"},{"location":"api/OptState/#treexoptstate","text":"","title":"treex.OptState"},{"location":"api/Optimizer/","text":"treex.Optimizer Wraps an optax optimizer and turn it into a Pytree while maintaining a similar API. The main difference with optax is that tx.Optimizer contains its own state, thus, there is no opt_state . Examples: def main (): ... optimizer = tx . Optimizer ( optax . adam ( 1e-3 )) optimizer = optimizer . init ( params ) ... jax . jit def train_step ( model , x , y , optimizer ): ... params = optimizer . update ( grads , params ) ... return model , loss , optimizer Notice that since the optimizer is a Pytree it can naturally pass through jit . Differences with Optax init return a new optimizer instance, there is no opt_state . update doesn't get opt_state as an argument, instead it performs updates to its internal state inplace. update applies the updates to the params and returns them by default, use update=False to to get the param updates instead. Parameters: Name Type Description Default optimizer An optax optimizer. required first_run : bool inherited property readonly Returns: Type Description bool True if its currently the first run of a compact method. __class__ inherited __base__ inherited Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()). __instancecheck__ ( cls , instance ) special Override for isinstance(instance, cls). Source code in treex/optimizer.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance ) __new__ ( mcls , name , bases , namespace , ** kwargs ) special staticmethod Create and return a new object. See help(type) for accurate signature. Source code in treex/optimizer.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls __subclasscheck__ ( cls , subclass ) special Override for issubclass(subclass, cls). Source code in treex/optimizer.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass ) register ( cls , subclass ) Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/optimizer.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) register ( cls , subclass ) inherited Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/optimizer.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) apply ( self , f , * rest , * , inplace = False ) inherited apply is a wrapper over treeo.apply that passes self as the second argument. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treex/optimizer.py def apply ( self : A , f : tp . Callable [ ... , None ], * rest : A , inplace : bool = False ) -> A : \"\"\" `apply` is a wrapper over `treeo.apply` that passes `self` as the second argument. Arguments: f: The function to apply. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" return api . apply ( f , self , * rest , inplace = inplace ) check_metadata_updates ( self ) inherited Checks for new fields, if found, adds them to the metadata. Source code in treex/optimizer.py def check_metadata_updates ( self ): \"\"\" Checks for new fields, if found, adds them to the metadata. \"\"\" with _CONTEXT . update ( flatten_mode = FlattenMode . all_fields ): jax . tree_flatten ( self ) copy ( self ) inherited copy is a wrapper over treeo.copy that passes self as the first argument. Source code in treex/optimizer.py def copy ( self : A ) -> A : \"\"\" `copy` is a wrapper over `treeo.copy` that passes `self` as the first argument. \"\"\" return tree_m . copy ( self ) eval ( self , inplace = False ) inherited Creates a new module with the training mode set to False, equivalent to calling train(False) . Returns: Type Description ~T The new module with the training mode set to False. Source code in treex/optimizer.py def eval ( self : T , inplace : bool = False ) -> T : \"\"\" Creates a new module with the training mode set to False, equivalent to calling `train(False)`. Returns: The new module with the training mode set to False. \"\"\" return self . train ( False , inplace = inplace ) filter ( self , * filters , * , inplace = False , flatten_mode = None ) inherited filter is a wrapper over treeo.filter that passes self as the first argument. Parameters: Name Type Description Default *filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treex/optimizer.py def filter ( self : A , * filters : api . Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ) -> A : \"\"\" `filter` is a wrapper over `treeo.filter` that passes `self` as the first argument. Arguments: *filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" return api . filter ( self , * filters , inplace = inplace , flatten_mode = flatten_mode ) freeze ( self , mode = True , inplace = False ) inherited Creates a new module with the same structure, but with Module.frozen set to the given value. Parameters: Name Type Description Default mode bool The new frozen mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module in with the frozen mode is set to the given value, if inplace is True then self is returned. Source code in treex/optimizer.py def freeze ( self : T , mode : bool = True , inplace : bool = False ) -> T : \"\"\" Creates a new module with the same structure, but with `Module.frozen` set to the given value. Arguments: mode: The new `frozen` mode. inplace: Whether to update the module inplace. Returns: The new module in with the `frozen` mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_frozen ( tree ): if isinstance ( tree , Treex ) and hasattr ( tree , \"_frozen\" ): tree . _frozen = mode return to . apply ( set_frozen , self , inplace = inplace ) get_field ( self , field_name , initializer ) inherited A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: The field must be declared in the class definition. The method can only be called inside a compact context. Parameters: Name Type Description Default field_name str The name of the field to get. required initializer Callable[[], ~A] The function to initialize the field if it does not exist. required Returns: Type Description ~A The field value. Source code in treex/optimizer.py def get_field ( self , field_name : str , initializer : tp . Callable [[], A ], ) -> A : \"\"\" A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: * The field must be declared in the class definition. * The method can only be called inside a `compact` context. Arguments: field_name: The name of the field to get. initializer: The function to initialize the field if it does not exist. Returns: The field value. \"\"\" value : A if field_name not in self . _field_metadata : raise ValueError ( f \"Metadata for field ' { field_name } ' does not exist.\" ) if field_name in vars ( self ): value = getattr ( self , field_name ) else : if tree_m . _COMPACT_CONTEXT . in_compact and not self . first_run : raise RuntimeError ( f \"Trying to initialize field ' { field_name } ' after the first run of `compact`.\" ) value = initializer () setattr ( self , field_name , value ) return value init ( self , params ) Initialize the optimizer from an initial set of parameters. Parameters: Name Type Description Default params Any An initial set of parameters. required Returns: Type Description ~O A new optimizer instance. Source code in treex/optimizer.py def init ( self : O , params : tp . Any ) -> O : \"\"\" Initialize the optimizer from an initial set of parameters. Arguments: params: An initial set of parameters. Returns: A new optimizer instance. \"\"\" module = to . copy ( self ) params = jax . tree_leaves ( params ) module . opt_state = module . optimizer . init ( params ) module . _n_params = len ( params ) module . _initialized = True return module map ( self , f , * filters , * , inplace = False , flatten_mode = None , is_leaf = None ) inherited map is a wrapper over treeo.map that passes self as the second argument. Parameters: Name Type Description Default f Callable The function to apply to the leaves. required *filters Filter The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treex/optimizer.py def map ( self : A , f : tp . Callable , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , is_leaf : tp . Callable [[ tp . Any ], bool ] = None , ) -> A : \"\"\" `map` is a wrapper over `treeo.map` that passes `self` as the second argument. Arguments: f: The function to apply to the leaves. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" return api . map ( f , self , * filters , inplace = inplace , flatten_mode = flatten_mode , is_leaf = is_leaf , ) merge ( self , other , * rest , * , inplace = False , flatten_mode = None , ignore_static = False ) inherited merge is a wrapper over treeo.merge that passes self as the first argument. Parameters: Name Type Description Default other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the merged values. If inplace is True , obj is returned. Source code in treex/optimizer.py def merge ( self : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" `merge` is a wrapper over `treeo.merge` that passes `self` as the first argument. Arguments: other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the merged values. If `inplace` is `True`, `obj` is returned. \"\"\" return api . merge ( self , other , * rest , inplace = inplace , flatten_mode = flatten_mode , ignore_static = ignore_static , ) to_dict ( self , * , private_fields = False , static_fields = True , type_info = False , field_info = False ) inherited to_dict is a wrapper over treeo.to_dict that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True type_info bool If True , type information is included. False field_info bool If True , field information is included. False Returns: Type Description Any A dict representation of the object. Source code in treex/optimizer.py def to_dict ( self , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : \"\"\" `to_dict` is a wrapper over `treeo.to_dict` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. type_info: If `True`, type information is included. field_info: If `True`, field information is included. Returns: A dict representation of the object. \"\"\" return api . to_dict ( self , private_fields = private_fields , static_fields = static_fields , type_info = type_info , field_info = field_info , ) to_string ( self , * , private_fields = False , static_fields = True , color = False ) inherited to_string is a wrapper over treeo.to_string that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True color bool If True , color is included. False Returns: Type Description str A string representation of the object. Source code in treex/optimizer.py def to_string ( self : A , * , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" `to_string` is a wrapper over `treeo.to_string` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. color: If `True`, color is included. Returns: A string representation of the object. \"\"\" return api . to_string ( self , private_fields = private_fields , static_fields = static_fields , color = color , ) train ( self , mode = True , inplace = False ) inherited Creates a new module with the same structure, but with Module.training set to the given value. Parameters: Name Type Description Default mode bool The new training mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module in with the training mode is set to the given value, if inplace is True then self is returned. Source code in treex/optimizer.py def train ( self : T , mode : bool = True , inplace : bool = False ) -> T : \"\"\" Creates a new module with the same structure, but with `Module.training` set to the given value. Arguments: mode: The new training mode. inplace: Whether to update the module inplace. Returns: The new module in with the training mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_training ( tree ): if isinstance ( tree , Treex ) and hasattr ( tree , \"_training\" ): tree . _training = mode return to . apply ( set_training , self , inplace = inplace ) unfreeze ( self , inplace = False ) inherited Creates a new module with .frozen set to False, equivalent to calling freeze(False) . Parameters: Name Type Description Default inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module with .frozen set to False, if inplace is True then self is returned. Source code in treex/optimizer.py def unfreeze ( self : T , inplace : bool = False ) -> T : \"\"\" Creates a new module with `.frozen` set to False, equivalent to calling `freeze(False)`. Arguments: inplace: Whether to update the module inplace. Returns: The new module with `.frozen` set to False, if `inplace` is `True` then `self` is returned. \"\"\" return self . freeze ( False , inplace = inplace ) update ( self , grads , params = None , apply_updates = True ) Applies the parameters updates and updates the optimizers internal state inplace. Parameters: Name Type Description Default grads ~A the gradients to perform the update. required params Optional[~A] the parameters to update. If None then update has to be False . None apply_updates bool if False then the updates are returned instead of being applied. True Returns: Type Description ~A The updated parameters. If apply_updates is False then the updates are returned instead. Source code in treex/optimizer.py def update ( self , grads : A , params : tp . Optional [ A ] = None , apply_updates : bool = True ) -> A : \"\"\" Applies the parameters updates and updates the optimizers internal state inplace. Arguments: grads: the gradients to perform the update. params: the parameters to update. If `None` then `update` has to be `False`. apply_updates: if `False` then the updates are returned instead of being applied. Returns: The updated parameters. If `apply_updates` is `False` then the updates are returned instead. \"\"\" if not self . initialized : raise RuntimeError ( \"Optimizer is not initialized\" ) assert self . opt_state is not None if apply_updates and params is None : raise ValueError ( \"params must be provided if updates are being applied\" ) opt_grads , treedef = jax . tree_flatten ( grads ) opt_params = jax . tree_leaves ( params ) if len ( opt_params ) != self . _n_params : raise ValueError ( f \"params must have length { self . _n_params } , got { len ( opt_params ) } \" ) if len ( opt_grads ) != self . _n_params : raise ValueError ( f \"grads must have length { self . _n_params } , got { len ( opt_grads ) } \" ) param_updates : A param_updates , self . opt_state = self . optimizer . update ( opt_grads , self . opt_state , opt_params , ) output : A if apply_updates : output = optax . apply_updates ( opt_params , param_updates ) else : output = param_updates return jax . tree_unflatten ( treedef , output )","title":"Optimizer"},{"location":"api/Optimizer/#treexoptimizer","text":"Wraps an optax optimizer and turn it into a Pytree while maintaining a similar API. The main difference with optax is that tx.Optimizer contains its own state, thus, there is no opt_state . Examples: def main (): ... optimizer = tx . Optimizer ( optax . adam ( 1e-3 )) optimizer = optimizer . init ( params ) ... jax . jit def train_step ( model , x , y , optimizer ): ... params = optimizer . update ( grads , params ) ... return model , loss , optimizer Notice that since the optimizer is a Pytree it can naturally pass through jit .","title":"treex.Optimizer"},{"location":"api/Optimizer/#treex.optimizer.Optimizer--differences-with-optax","text":"init return a new optimizer instance, there is no opt_state . update doesn't get opt_state as an argument, instead it performs updates to its internal state inplace. update applies the updates to the params and returns them by default, use update=False to to get the param updates instead. Parameters: Name Type Description Default optimizer An optax optimizer. required","title":"Differences with Optax"},{"location":"api/Optimizer/#treex.optimizer.Optimizer.first_run","text":"Returns: Type Description bool True if its currently the first run of a compact method.","title":"first_run"},{"location":"api/Optimizer/#treex.optimizer.Optimizer.__class__","text":"","title":"__class__"},{"location":"api/Optimizer/#treex.optimizer.Optimizer.__class__.__base__","text":"Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()).","title":"__base__"},{"location":"api/Optimizer/#treex.optimizer.Optimizer.__class__.__base__.__instancecheck__","text":"Override for isinstance(instance, cls). Source code in treex/optimizer.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance )","title":"__instancecheck__()"},{"location":"api/Optimizer/#treex.optimizer.Optimizer.__class__.__base__.__new__","text":"Create and return a new object. See help(type) for accurate signature. Source code in treex/optimizer.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls","title":"__new__()"},{"location":"api/Optimizer/#treex.optimizer.Optimizer.__class__.__base__.__subclasscheck__","text":"Override for issubclass(subclass, cls). Source code in treex/optimizer.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass )","title":"__subclasscheck__()"},{"location":"api/Optimizer/#treex.optimizer.Optimizer.__class__.__base__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/optimizer.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/Optimizer/#treex.optimizer.Optimizer.__class__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/optimizer.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/Optimizer/#treex.optimizer.Optimizer.apply","text":"apply is a wrapper over treeo.apply that passes self as the second argument. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treex/optimizer.py def apply ( self : A , f : tp . Callable [ ... , None ], * rest : A , inplace : bool = False ) -> A : \"\"\" `apply` is a wrapper over `treeo.apply` that passes `self` as the second argument. Arguments: f: The function to apply. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" return api . apply ( f , self , * rest , inplace = inplace )","title":"apply()"},{"location":"api/Optimizer/#treex.optimizer.Optimizer.check_metadata_updates","text":"Checks for new fields, if found, adds them to the metadata. Source code in treex/optimizer.py def check_metadata_updates ( self ): \"\"\" Checks for new fields, if found, adds them to the metadata. \"\"\" with _CONTEXT . update ( flatten_mode = FlattenMode . all_fields ): jax . tree_flatten ( self )","title":"check_metadata_updates()"},{"location":"api/Optimizer/#treex.optimizer.Optimizer.copy","text":"copy is a wrapper over treeo.copy that passes self as the first argument. Source code in treex/optimizer.py def copy ( self : A ) -> A : \"\"\" `copy` is a wrapper over `treeo.copy` that passes `self` as the first argument. \"\"\" return tree_m . copy ( self )","title":"copy()"},{"location":"api/Optimizer/#treex.optimizer.Optimizer.eval","text":"Creates a new module with the training mode set to False, equivalent to calling train(False) . Returns: Type Description ~T The new module with the training mode set to False. Source code in treex/optimizer.py def eval ( self : T , inplace : bool = False ) -> T : \"\"\" Creates a new module with the training mode set to False, equivalent to calling `train(False)`. Returns: The new module with the training mode set to False. \"\"\" return self . train ( False , inplace = inplace )","title":"eval()"},{"location":"api/Optimizer/#treex.optimizer.Optimizer.filter","text":"filter is a wrapper over treeo.filter that passes self as the first argument. Parameters: Name Type Description Default *filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treex/optimizer.py def filter ( self : A , * filters : api . Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ) -> A : \"\"\" `filter` is a wrapper over `treeo.filter` that passes `self` as the first argument. Arguments: *filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" return api . filter ( self , * filters , inplace = inplace , flatten_mode = flatten_mode )","title":"filter()"},{"location":"api/Optimizer/#treex.optimizer.Optimizer.freeze","text":"Creates a new module with the same structure, but with Module.frozen set to the given value. Parameters: Name Type Description Default mode bool The new frozen mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module in with the frozen mode is set to the given value, if inplace is True then self is returned. Source code in treex/optimizer.py def freeze ( self : T , mode : bool = True , inplace : bool = False ) -> T : \"\"\" Creates a new module with the same structure, but with `Module.frozen` set to the given value. Arguments: mode: The new `frozen` mode. inplace: Whether to update the module inplace. Returns: The new module in with the `frozen` mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_frozen ( tree ): if isinstance ( tree , Treex ) and hasattr ( tree , \"_frozen\" ): tree . _frozen = mode return to . apply ( set_frozen , self , inplace = inplace )","title":"freeze()"},{"location":"api/Optimizer/#treex.optimizer.Optimizer.get_field","text":"A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: The field must be declared in the class definition. The method can only be called inside a compact context. Parameters: Name Type Description Default field_name str The name of the field to get. required initializer Callable[[], ~A] The function to initialize the field if it does not exist. required Returns: Type Description ~A The field value. Source code in treex/optimizer.py def get_field ( self , field_name : str , initializer : tp . Callable [[], A ], ) -> A : \"\"\" A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: * The field must be declared in the class definition. * The method can only be called inside a `compact` context. Arguments: field_name: The name of the field to get. initializer: The function to initialize the field if it does not exist. Returns: The field value. \"\"\" value : A if field_name not in self . _field_metadata : raise ValueError ( f \"Metadata for field ' { field_name } ' does not exist.\" ) if field_name in vars ( self ): value = getattr ( self , field_name ) else : if tree_m . _COMPACT_CONTEXT . in_compact and not self . first_run : raise RuntimeError ( f \"Trying to initialize field ' { field_name } ' after the first run of `compact`.\" ) value = initializer () setattr ( self , field_name , value ) return value","title":"get_field()"},{"location":"api/Optimizer/#treex.optimizer.Optimizer.init","text":"Initialize the optimizer from an initial set of parameters. Parameters: Name Type Description Default params Any An initial set of parameters. required Returns: Type Description ~O A new optimizer instance. Source code in treex/optimizer.py def init ( self : O , params : tp . Any ) -> O : \"\"\" Initialize the optimizer from an initial set of parameters. Arguments: params: An initial set of parameters. Returns: A new optimizer instance. \"\"\" module = to . copy ( self ) params = jax . tree_leaves ( params ) module . opt_state = module . optimizer . init ( params ) module . _n_params = len ( params ) module . _initialized = True return module","title":"init()"},{"location":"api/Optimizer/#treex.optimizer.Optimizer.map","text":"map is a wrapper over treeo.map that passes self as the second argument. Parameters: Name Type Description Default f Callable The function to apply to the leaves. required *filters Filter The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treex/optimizer.py def map ( self : A , f : tp . Callable , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , is_leaf : tp . Callable [[ tp . Any ], bool ] = None , ) -> A : \"\"\" `map` is a wrapper over `treeo.map` that passes `self` as the second argument. Arguments: f: The function to apply to the leaves. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" return api . map ( f , self , * filters , inplace = inplace , flatten_mode = flatten_mode , is_leaf = is_leaf , )","title":"map()"},{"location":"api/Optimizer/#treex.optimizer.Optimizer.merge","text":"merge is a wrapper over treeo.merge that passes self as the first argument. Parameters: Name Type Description Default other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the merged values. If inplace is True , obj is returned. Source code in treex/optimizer.py def merge ( self : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" `merge` is a wrapper over `treeo.merge` that passes `self` as the first argument. Arguments: other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the merged values. If `inplace` is `True`, `obj` is returned. \"\"\" return api . merge ( self , other , * rest , inplace = inplace , flatten_mode = flatten_mode , ignore_static = ignore_static , )","title":"merge()"},{"location":"api/Optimizer/#treex.optimizer.Optimizer.to_dict","text":"to_dict is a wrapper over treeo.to_dict that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True type_info bool If True , type information is included. False field_info bool If True , field information is included. False Returns: Type Description Any A dict representation of the object. Source code in treex/optimizer.py def to_dict ( self , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : \"\"\" `to_dict` is a wrapper over `treeo.to_dict` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. type_info: If `True`, type information is included. field_info: If `True`, field information is included. Returns: A dict representation of the object. \"\"\" return api . to_dict ( self , private_fields = private_fields , static_fields = static_fields , type_info = type_info , field_info = field_info , )","title":"to_dict()"},{"location":"api/Optimizer/#treex.optimizer.Optimizer.to_string","text":"to_string is a wrapper over treeo.to_string that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True color bool If True , color is included. False Returns: Type Description str A string representation of the object. Source code in treex/optimizer.py def to_string ( self : A , * , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" `to_string` is a wrapper over `treeo.to_string` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. color: If `True`, color is included. Returns: A string representation of the object. \"\"\" return api . to_string ( self , private_fields = private_fields , static_fields = static_fields , color = color , )","title":"to_string()"},{"location":"api/Optimizer/#treex.optimizer.Optimizer.train","text":"Creates a new module with the same structure, but with Module.training set to the given value. Parameters: Name Type Description Default mode bool The new training mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module in with the training mode is set to the given value, if inplace is True then self is returned. Source code in treex/optimizer.py def train ( self : T , mode : bool = True , inplace : bool = False ) -> T : \"\"\" Creates a new module with the same structure, but with `Module.training` set to the given value. Arguments: mode: The new training mode. inplace: Whether to update the module inplace. Returns: The new module in with the training mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_training ( tree ): if isinstance ( tree , Treex ) and hasattr ( tree , \"_training\" ): tree . _training = mode return to . apply ( set_training , self , inplace = inplace )","title":"train()"},{"location":"api/Optimizer/#treex.optimizer.Optimizer.unfreeze","text":"Creates a new module with .frozen set to False, equivalent to calling freeze(False) . Parameters: Name Type Description Default inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module with .frozen set to False, if inplace is True then self is returned. Source code in treex/optimizer.py def unfreeze ( self : T , inplace : bool = False ) -> T : \"\"\" Creates a new module with `.frozen` set to False, equivalent to calling `freeze(False)`. Arguments: inplace: Whether to update the module inplace. Returns: The new module with `.frozen` set to False, if `inplace` is `True` then `self` is returned. \"\"\" return self . freeze ( False , inplace = inplace )","title":"unfreeze()"},{"location":"api/Optimizer/#treex.optimizer.Optimizer.update","text":"Applies the parameters updates and updates the optimizers internal state inplace. Parameters: Name Type Description Default grads ~A the gradients to perform the update. required params Optional[~A] the parameters to update. If None then update has to be False . None apply_updates bool if False then the updates are returned instead of being applied. True Returns: Type Description ~A The updated parameters. If apply_updates is False then the updates are returned instead. Source code in treex/optimizer.py def update ( self , grads : A , params : tp . Optional [ A ] = None , apply_updates : bool = True ) -> A : \"\"\" Applies the parameters updates and updates the optimizers internal state inplace. Arguments: grads: the gradients to perform the update. params: the parameters to update. If `None` then `update` has to be `False`. apply_updates: if `False` then the updates are returned instead of being applied. Returns: The updated parameters. If `apply_updates` is `False` then the updates are returned instead. \"\"\" if not self . initialized : raise RuntimeError ( \"Optimizer is not initialized\" ) assert self . opt_state is not None if apply_updates and params is None : raise ValueError ( \"params must be provided if updates are being applied\" ) opt_grads , treedef = jax . tree_flatten ( grads ) opt_params = jax . tree_leaves ( params ) if len ( opt_params ) != self . _n_params : raise ValueError ( f \"params must have length { self . _n_params } , got { len ( opt_params ) } \" ) if len ( opt_grads ) != self . _n_params : raise ValueError ( f \"grads must have length { self . _n_params } , got { len ( opt_grads ) } \" ) param_updates : A param_updates , self . opt_state = self . optimizer . update ( opt_grads , self . opt_state , opt_params , ) output : A if apply_updates : output = optax . apply_updates ( opt_params , param_updates ) else : output = param_updates return jax . tree_unflatten ( treedef , output )","title":"update()"},{"location":"api/Parameter/","text":"treex.Parameter","title":"Parameter"},{"location":"api/Parameter/#treexparameter","text":"","title":"treex.Parameter"},{"location":"api/Repr/","text":"treex.Repr Mixin that adds a __repr__ method to the class. __repr__ ( self ) special Uses treeo.to_string to generate a string representation of the object. Source code in treeo/mixins.py def __repr__ ( self ) -> tp . Any : \"\"\" Uses `treeo.to_string` to generate a string representation of the object. \"\"\" return api . to_string ( self , private_fields = False , static_fields = True , color = False , )","title":"Repr"},{"location":"api/Repr/#treexrepr","text":"Mixin that adds a __repr__ method to the class.","title":"treex.Repr"},{"location":"api/Repr/#treeo.mixins.Repr.__repr__","text":"Uses treeo.to_string to generate a string representation of the object. Source code in treeo/mixins.py def __repr__ ( self ) -> tp . Any : \"\"\" Uses `treeo.to_string` to generate a string representation of the object. \"\"\" return api . to_string ( self , private_fields = False , static_fields = True , color = False , )","title":"__repr__()"},{"location":"api/Rng/","text":"treex.Rng","title":"Rng"},{"location":"api/Rng/#treexrng","text":"","title":"treex.Rng"},{"location":"api/Sequential/","text":"treex.Sequential A Module that applies a sequence of Modules or functions in order. Examples: mlp = tx . Sequential ( tx . Linear ( 2 , 32 ), jax . nn . relu , tx . Linear ( 32 , 8 ), jax . nn . relu , tx . Linear ( 8 , 4 ), ) . init ( 42 ) x = np . random . uniform ( size = ( 10 , 2 )) y = mlp ( x ) assert y . shape == ( 10 , 4 ) first_run : bool inherited property readonly Returns: Type Description bool True if its currently the first run of a compact method. __class__ inherited __base__ inherited __base__ inherited Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()). __instancecheck__ ( cls , instance ) special Override for isinstance(instance, cls). Source code in treex/nn/sequential.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance ) __new__ ( mcls , name , bases , namespace , ** kwargs ) special staticmethod Create and return a new object. See help(type) for accurate signature. Source code in treex/nn/sequential.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls __subclasscheck__ ( cls , subclass ) special Override for issubclass(subclass, cls). Source code in treex/nn/sequential.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass ) register ( cls , subclass ) Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/sequential.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) register ( cls , subclass ) inherited Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/sequential.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) register ( cls , subclass ) inherited Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/sequential.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) __init__ ( self , * layers ) special Parameters: Name Type Description Default *layers Union[Callable[..., jax._src.numpy.lax_numpy.ndarray], Callable[[jax._src.numpy.lax_numpy.ndarray], jax._src.numpy.lax_numpy.ndarray]] A list of layers or callables to apply to apply in sequence. () Source code in treex/nn/sequential.py def __init__ ( self , * layers : tp . Union [ CallableModule , tp . Callable [[ jnp . ndarray ], jnp . ndarray ]] ): \"\"\" Arguments: *layers: A list of layers or callables to apply to apply in sequence. \"\"\" self . layers = [ layer if isinstance ( layer , Module ) else Lambda ( layer ) for layer in layers ] apply ( self , f , * rest , * , inplace = False ) inherited apply is a wrapper over treeo.apply that passes self as the second argument. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treex/nn/sequential.py def apply ( self : A , f : tp . Callable [ ... , None ], * rest : A , inplace : bool = False ) -> A : \"\"\" `apply` is a wrapper over `treeo.apply` that passes `self` as the second argument. Arguments: f: The function to apply. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" return api . apply ( f , self , * rest , inplace = inplace ) batch_stats ( self , * filters ) inherited Returns a copy of the Module with only tx.BatchStat TreeParts, alias for filter(tx.BatchStat) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/sequential.py def batch_stats ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.BatchStat TreeParts, alias for `filter(tx.BatchStat)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . BatchStat , * filters ) check_metadata_updates ( self ) inherited Checks for new fields, if found, adds them to the metadata. Source code in treex/nn/sequential.py def check_metadata_updates ( self ): \"\"\" Checks for new fields, if found, adds them to the metadata. \"\"\" with _CONTEXT . update ( flatten_mode = FlattenMode . all_fields ): jax . tree_flatten ( self ) copy ( self ) inherited copy is a wrapper over treeo.copy that passes self as the first argument. Source code in treex/nn/sequential.py def copy ( self : A ) -> A : \"\"\" `copy` is a wrapper over `treeo.copy` that passes `self` as the first argument. \"\"\" return tree_m . copy ( self ) eval ( self , inplace = False ) inherited Creates a new module with the training mode set to False, equivalent to calling train(False) . Returns: Type Description ~T The new module with the training mode set to False. Source code in treex/nn/sequential.py def eval ( self : T , inplace : bool = False ) -> T : \"\"\" Creates a new module with the training mode set to False, equivalent to calling `train(False)`. Returns: The new module with the training mode set to False. \"\"\" return self . train ( False , inplace = inplace ) filter ( self , * filters , * , inplace = False , flatten_mode = None ) inherited filter is a wrapper over treeo.filter that passes self as the first argument. Parameters: Name Type Description Default *filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treex/nn/sequential.py def filter ( self : A , * filters : api . Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ) -> A : \"\"\" `filter` is a wrapper over `treeo.filter` that passes `self` as the first argument. Arguments: *filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" return api . filter ( self , * filters , inplace = inplace , flatten_mode = flatten_mode ) freeze ( self , mode = True , inplace = False ) inherited Creates a new module with the same structure, but with Module.frozen set to the given value. Parameters: Name Type Description Default mode bool The new frozen mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module in with the frozen mode is set to the given value, if inplace is True then self is returned. Source code in treex/nn/sequential.py def freeze ( self : T , mode : bool = True , inplace : bool = False ) -> T : \"\"\" Creates a new module with the same structure, but with `Module.frozen` set to the given value. Arguments: mode: The new `frozen` mode. inplace: Whether to update the module inplace. Returns: The new module in with the `frozen` mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_frozen ( tree ): if isinstance ( tree , Treex ) and hasattr ( tree , \"_frozen\" ): tree . _frozen = mode return to . apply ( set_frozen , self , inplace = inplace ) get_field ( self , field_name , initializer ) inherited A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: The field must be declared in the class definition. The method can only be called inside a compact context. Parameters: Name Type Description Default field_name str The name of the field to get. required initializer Callable[[], ~A] The function to initialize the field if it does not exist. required Returns: Type Description ~A The field value. Source code in treex/nn/sequential.py def get_field ( self , field_name : str , initializer : tp . Callable [[], A ], ) -> A : \"\"\" A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: * The field must be declared in the class definition. * The method can only be called inside a `compact` context. Arguments: field_name: The name of the field to get. initializer: The function to initialize the field if it does not exist. Returns: The field value. \"\"\" value : A if field_name not in self . _field_metadata : raise ValueError ( f \"Metadata for field ' { field_name } ' does not exist.\" ) if field_name in vars ( self ): value = getattr ( self , field_name ) else : if tree_m . _COMPACT_CONTEXT . in_compact and not self . first_run : raise RuntimeError ( f \"Trying to initialize field ' { field_name } ' after the first run of `compact`.\" ) value = initializer () setattr ( self , field_name , value ) return value init ( self , key , inputs =< treeo . types . Missing object at 0x7f29ce5c9220 > , call_method = '__call__' , * , inplace = False , _set_initialize = True ) inherited Method version of tx.init , it applies self as first argument. init creates a new module with the same structure, but with its fields initialized given a seed key . The following procedure is used: The input key is split and iteratively updated before passing a derived value to any process that requires initialization. Initializer s are called and applied to the module first. Module.rng_init methods are called last. Parameters: Name Type Description Default key Union[int, jax._src.numpy.lax_numpy.ndarray] The seed to use for initialization. required Returns: Type Description ~M The new module with the fields initialized. Source code in treex/nn/sequential.py def init ( self : M , key : tp . Union [ int , jnp . ndarray ], inputs : types . InputLike = to . MISSING , call_method : str = \"__call__\" , * , inplace : bool = False , _set_initialize : bool = True , ) -> M : \"\"\" Method version of `tx.init`, it applies `self` as first argument. `init` creates a new module with the same structure, but with its fields initialized given a seed `key`. The following procedure is used: 1. The input `key` is split and iteratively updated before passing a derived value to any process that requires initialization. 2. `Initializer`s are called and applied to the module first. 3. `Module.rng_init` methods are called last. Arguments: key: The seed to use for initialization. Returns: The new module with the fields initialized. \"\"\" module = self . copy () if not inplace else self key = utils . Key ( key ) with _INIT_CONTEXT . update ( key = key , initializing = True ): module : M = module . map ( lambda initializer : ( initializer ( next_key ()) if isinstance ( initializer , types . Initializer ) else initializer ), is_leaf = lambda x : isinstance ( x , types . Initializer ), inplace = True , ) def call_rng_init ( module : Module ): if isinstance ( module , Module ) and not module . _initialized : module . rng_init () module = to . apply ( call_rng_init , module , inplace = True ) if inputs is not to . MISSING : inputs = types . Inputs . from_value ( inputs ) method = getattr ( module , call_method ) method ( * inputs . args , ** inputs . kwargs ) if _set_initialize : def set_initialized ( module : Module ): if isinstance ( module , Module ) and not module . _initialized : module . _initialized = True module = to . apply ( set_initialized , module , inplace = True ) return module logs ( self , * filters ) inherited Returns a copy of the Module with only tx.Log TreeParts, alias for filter(tx.Log) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/sequential.py def logs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Log TreeParts, alias for `filter(tx.Log)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . Log , * filters ) loss_logs ( self , * filters ) inherited Returns a copy of the Module with only tx.Loss TreeParts, alias for filter(tx.Loss) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/sequential.py def loss_logs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Loss TreeParts, alias for `filter(tx.Loss)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . LossLog , * filters ) map ( self , f , * filters , * , inplace = False , flatten_mode = None , is_leaf = None ) inherited map is a wrapper over treeo.map that passes self as the second argument. Parameters: Name Type Description Default f Callable The function to apply to the leaves. required *filters Filter The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treex/nn/sequential.py def map ( self : A , f : tp . Callable , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , is_leaf : tp . Callable [[ tp . Any ], bool ] = None , ) -> A : \"\"\" `map` is a wrapper over `treeo.map` that passes `self` as the second argument. Arguments: f: The function to apply to the leaves. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" return api . map ( f , self , * filters , inplace = inplace , flatten_mode = flatten_mode , is_leaf = is_leaf , ) merge ( self , other , * rest , * , inplace = False , flatten_mode = None , ignore_static = False ) inherited merge is a wrapper over treeo.merge that passes self as the first argument. Parameters: Name Type Description Default other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the merged values. If inplace is True , obj is returned. Source code in treex/nn/sequential.py def merge ( self : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" `merge` is a wrapper over `treeo.merge` that passes `self` as the first argument. Arguments: other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the merged values. If `inplace` is `True`, `obj` is returned. \"\"\" return api . merge ( self , other , * rest , inplace = inplace , flatten_mode = flatten_mode , ignore_static = ignore_static , ) metric_logs ( self , * filters ) inherited Returns a copy of the Module with only tx.Metric TreeParts, alias for filter(tx.Metric) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/sequential.py def metric_logs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Metric TreeParts, alias for `filter(tx.Metric)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . MetricLog , * filters ) model_states ( self , * filters ) inherited Returns a copy of the Module with only tx.ModelState TreeParts, alias for filter(tx.ModelState) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/sequential.py def model_states ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.ModelState TreeParts, alias for `filter(tx.ModelState)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . ModelState , * filters ) parameters ( self , * filters ) inherited Returns a copy of the Module with only tx.Parameter TreeParts, alias for filter(tx.Parameter) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/sequential.py def parameters ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Parameter TreeParts, alias for `filter(tx.Parameter)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . Parameter , * filters ) rngs ( self , * filters ) inherited Returns a copy of the Module with only tx.Rng TreeParts, alias for filter(tx.Rng) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/sequential.py def rngs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Rng TreeParts, alias for `filter(tx.Rng)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . Rng , * filters ) states ( self , * filters ) inherited Returns a copy of the Module with only tx.State TreeParts, alias for filter(tx.State) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/sequential.py def states ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.State TreeParts, alias for `filter(tx.State)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . State , * filters ) tabulate ( self , inputs =< treeo . types . Missing object at 0x7f29ce5c9220 > , depth =- 1 , signature = False , param_types = True ) inherited Returns a tabular representation of the module. Parameters: Name Type Description Default depth int The maximum depth of the representation in terms of nested Modules, -1 means no limit. -1 signature bool Whether to show the signature of the Module. False param_types bool Whether to show the types of the parameters. True Returns: Type Description str A string containing the tabular representation. Source code in treex/nn/sequential.py def tabulate ( self , inputs : tp . Union [ types . InputLike , to . Missing ] = to . MISSING , depth : int = - 1 , signature : bool = False , param_types : bool = True , ) -> str : \"\"\" Returns a tabular representation of the module. Arguments: depth: The maximum depth of the representation in terms of nested Modules, -1 means no limit. signature: Whether to show the signature of the Module. param_types: Whether to show the types of the parameters. Returns: A string containing the tabular representation. \"\"\" self = to . copy ( self ) if inputs is not to . MISSING : inputs = types . Inputs . from_value ( inputs ) if not isinstance ( self , tp . Callable ): raise TypeError ( \"`inputs` can only be specified if the module is a callable.\" ) with contexts . _Context ( call_info = {}): # call using self to preserve references def eval_call ( args , kwargs ): assert isinstance ( self , tp . Callable ) return self ( * args , ** kwargs ) jax . eval_shape ( eval_call , inputs . args , inputs . kwargs , ) call_info = contexts . _CONTEXT . call_info else : call_info = None with to . add_field_info (): flat : tp . List [ to . FieldInfo ] flat , _ = jax . tree_flatten ( self ) tree_part_types : tp . Tuple [ tp . Type [ types . TreePart ], ... ] = tuple ( { field_info . kind for field_info in flat if utils . _generic_issubclass ( field_info . kind , types . TreePart ) } ) path = () rows = list ( utils . _get_tabulate_rows ( path , self , depth , tree_part_types , signature , param_types ) ) modules = [ row [ 0 ] for row in rows ] rows = [ row [ 1 :] for row in rows ] if call_info is not None : for module , row in zip ( modules , rows ): if module in call_info : inputs , outputs = call_info [ module ] simplified_inputs = ( inputs . args [ 0 ] if len ( inputs . kwargs ) == 0 and len ( inputs . args ) == 1 else inputs . kwargs if len ( inputs . kwargs ) == 0 else inputs . kwargs if len ( inputs . args ) == 0 else ( inputs . args , inputs . kwargs ) ) inputs_repr = utils . _format_param_tree ( simplified_inputs ) outputs_repr = utils . _format_param_tree ( outputs ) else : inputs_repr = \"\" outputs_repr = \"\" row . insert ( 3 , outputs_repr ) row . insert ( 3 , inputs_repr ) n_non_treepart_cols = 2 if call_info is None else 4 rows [ 0 ][ 0 ] = \"*\" rows . append ( [ \"\" ] * n_non_treepart_cols + [ \"Total:\" ] + [ utils . _format_obj_size ( self . filter ( kind ), add_padding = True ) for kind in tree_part_types ] ) utils . _add_padding ( rows ) table = Table ( show_header = True , show_lines = True , show_footer = True , # box=rich.box.HORIZONTALS, ) table . add_column ( \"path\" ) table . add_column ( \"module\" ) table . add_column ( \"params\" ) if call_info is not None : table . add_column ( \"inputs\" ) table . add_column ( \"outputs\" ) for tree_part_type in tree_part_types : type_name = tree_part_type . __name__ if type_name . startswith ( \"_\" ): type_name = type_name [ 1 :] table . add_column ( type_name ) for row in rows [: - 1 ]: table . add_row ( * row ) table . columns [ n_non_treepart_cols ] . footer = Text . from_markup ( rows [ - 1 ][ n_non_treepart_cols ], justify = \"right\" ) for i in range ( len ( tree_part_types )): table . columns [ n_non_treepart_cols + 1 + i ] . footer = rows [ - 1 ][ n_non_treepart_cols + 1 + i ] table . caption_style = \"bold\" table . caption = \" \\n Total Parameters: \" + utils . _format_obj_size ( self , add_padding = False ) return utils . _get_rich_repr ( table ) to_dict ( self , * , private_fields = False , static_fields = True , type_info = False , field_info = False ) inherited to_dict is a wrapper over treeo.to_dict that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True type_info bool If True , type information is included. False field_info bool If True , field information is included. False Returns: Type Description Any A dict representation of the object. Source code in treex/nn/sequential.py def to_dict ( self , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : \"\"\" `to_dict` is a wrapper over `treeo.to_dict` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. type_info: If `True`, type information is included. field_info: If `True`, field information is included. Returns: A dict representation of the object. \"\"\" return api . to_dict ( self , private_fields = private_fields , static_fields = static_fields , type_info = type_info , field_info = field_info , ) to_string ( self , * , private_fields = False , static_fields = True , color = False ) inherited to_string is a wrapper over treeo.to_string that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True color bool If True , color is included. False Returns: Type Description str A string representation of the object. Source code in treex/nn/sequential.py def to_string ( self : A , * , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" `to_string` is a wrapper over `treeo.to_string` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. color: If `True`, color is included. Returns: A string representation of the object. \"\"\" return api . to_string ( self , private_fields = private_fields , static_fields = static_fields , color = color , ) train ( self , mode = True , inplace = False ) inherited Creates a new module with the same structure, but with Module.training set to the given value. Parameters: Name Type Description Default mode bool The new training mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module in with the training mode is set to the given value, if inplace is True then self is returned. Source code in treex/nn/sequential.py def train ( self : T , mode : bool = True , inplace : bool = False ) -> T : \"\"\" Creates a new module with the same structure, but with `Module.training` set to the given value. Arguments: mode: The new training mode. inplace: Whether to update the module inplace. Returns: The new module in with the training mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_training ( tree ): if isinstance ( tree , Treex ) and hasattr ( tree , \"_training\" ): tree . _training = mode return to . apply ( set_training , self , inplace = inplace ) unfreeze ( self , inplace = False ) inherited Creates a new module with .frozen set to False, equivalent to calling freeze(False) . Parameters: Name Type Description Default inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module with .frozen set to False, if inplace is True then self is returned. Source code in treex/nn/sequential.py def unfreeze ( self : T , inplace : bool = False ) -> T : \"\"\" Creates a new module with `.frozen` set to False, equivalent to calling `freeze(False)`. Arguments: inplace: Whether to update the module inplace. Returns: The new module with `.frozen` set to False, if `inplace` is `True` then `self` is returned. \"\"\" return self . freeze ( False , inplace = inplace )","title":"Sequential"},{"location":"api/Sequential/#treexsequential","text":"A Module that applies a sequence of Modules or functions in order. Examples: mlp = tx . Sequential ( tx . Linear ( 2 , 32 ), jax . nn . relu , tx . Linear ( 32 , 8 ), jax . nn . relu , tx . Linear ( 8 , 4 ), ) . init ( 42 ) x = np . random . uniform ( size = ( 10 , 2 )) y = mlp ( x ) assert y . shape == ( 10 , 4 )","title":"treex.Sequential"},{"location":"api/Sequential/#treex.nn.sequential.Sequential.first_run","text":"Returns: Type Description bool True if its currently the first run of a compact method.","title":"first_run"},{"location":"api/Sequential/#treex.nn.sequential.Sequential.__class__","text":"","title":"__class__"},{"location":"api/Sequential/#treex.nn.sequential.Sequential.__class__.__base__","text":"","title":"__base__"},{"location":"api/Sequential/#treex.nn.sequential.Sequential.__class__.__base__.__base__","text":"Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()).","title":"__base__"},{"location":"api/Sequential/#treex.nn.sequential.Sequential.__class__.__base__.__base__.__instancecheck__","text":"Override for isinstance(instance, cls). Source code in treex/nn/sequential.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance )","title":"__instancecheck__()"},{"location":"api/Sequential/#treex.nn.sequential.Sequential.__class__.__base__.__base__.__new__","text":"Create and return a new object. See help(type) for accurate signature. Source code in treex/nn/sequential.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls","title":"__new__()"},{"location":"api/Sequential/#treex.nn.sequential.Sequential.__class__.__base__.__base__.__subclasscheck__","text":"Override for issubclass(subclass, cls). Source code in treex/nn/sequential.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass )","title":"__subclasscheck__()"},{"location":"api/Sequential/#treex.nn.sequential.Sequential.__class__.__base__.__base__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/sequential.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/Sequential/#treex.nn.sequential.Sequential.__class__.__base__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/sequential.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/Sequential/#treex.nn.sequential.Sequential.__class__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/nn/sequential.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/Sequential/#treex.nn.sequential.Sequential.__init__","text":"Parameters: Name Type Description Default *layers Union[Callable[..., jax._src.numpy.lax_numpy.ndarray], Callable[[jax._src.numpy.lax_numpy.ndarray], jax._src.numpy.lax_numpy.ndarray]] A list of layers or callables to apply to apply in sequence. () Source code in treex/nn/sequential.py def __init__ ( self , * layers : tp . Union [ CallableModule , tp . Callable [[ jnp . ndarray ], jnp . ndarray ]] ): \"\"\" Arguments: *layers: A list of layers or callables to apply to apply in sequence. \"\"\" self . layers = [ layer if isinstance ( layer , Module ) else Lambda ( layer ) for layer in layers ]","title":"__init__()"},{"location":"api/Sequential/#treex.nn.sequential.Sequential.apply","text":"apply is a wrapper over treeo.apply that passes self as the second argument. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treex/nn/sequential.py def apply ( self : A , f : tp . Callable [ ... , None ], * rest : A , inplace : bool = False ) -> A : \"\"\" `apply` is a wrapper over `treeo.apply` that passes `self` as the second argument. Arguments: f: The function to apply. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" return api . apply ( f , self , * rest , inplace = inplace )","title":"apply()"},{"location":"api/Sequential/#treex.nn.sequential.Sequential.batch_stats","text":"Returns a copy of the Module with only tx.BatchStat TreeParts, alias for filter(tx.BatchStat) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/sequential.py def batch_stats ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.BatchStat TreeParts, alias for `filter(tx.BatchStat)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . BatchStat , * filters )","title":"batch_stats()"},{"location":"api/Sequential/#treex.nn.sequential.Sequential.check_metadata_updates","text":"Checks for new fields, if found, adds them to the metadata. Source code in treex/nn/sequential.py def check_metadata_updates ( self ): \"\"\" Checks for new fields, if found, adds them to the metadata. \"\"\" with _CONTEXT . update ( flatten_mode = FlattenMode . all_fields ): jax . tree_flatten ( self )","title":"check_metadata_updates()"},{"location":"api/Sequential/#treex.nn.sequential.Sequential.copy","text":"copy is a wrapper over treeo.copy that passes self as the first argument. Source code in treex/nn/sequential.py def copy ( self : A ) -> A : \"\"\" `copy` is a wrapper over `treeo.copy` that passes `self` as the first argument. \"\"\" return tree_m . copy ( self )","title":"copy()"},{"location":"api/Sequential/#treex.nn.sequential.Sequential.eval","text":"Creates a new module with the training mode set to False, equivalent to calling train(False) . Returns: Type Description ~T The new module with the training mode set to False. Source code in treex/nn/sequential.py def eval ( self : T , inplace : bool = False ) -> T : \"\"\" Creates a new module with the training mode set to False, equivalent to calling `train(False)`. Returns: The new module with the training mode set to False. \"\"\" return self . train ( False , inplace = inplace )","title":"eval()"},{"location":"api/Sequential/#treex.nn.sequential.Sequential.filter","text":"filter is a wrapper over treeo.filter that passes self as the first argument. Parameters: Name Type Description Default *filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treex/nn/sequential.py def filter ( self : A , * filters : api . Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ) -> A : \"\"\" `filter` is a wrapper over `treeo.filter` that passes `self` as the first argument. Arguments: *filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" return api . filter ( self , * filters , inplace = inplace , flatten_mode = flatten_mode )","title":"filter()"},{"location":"api/Sequential/#treex.nn.sequential.Sequential.freeze","text":"Creates a new module with the same structure, but with Module.frozen set to the given value. Parameters: Name Type Description Default mode bool The new frozen mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module in with the frozen mode is set to the given value, if inplace is True then self is returned. Source code in treex/nn/sequential.py def freeze ( self : T , mode : bool = True , inplace : bool = False ) -> T : \"\"\" Creates a new module with the same structure, but with `Module.frozen` set to the given value. Arguments: mode: The new `frozen` mode. inplace: Whether to update the module inplace. Returns: The new module in with the `frozen` mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_frozen ( tree ): if isinstance ( tree , Treex ) and hasattr ( tree , \"_frozen\" ): tree . _frozen = mode return to . apply ( set_frozen , self , inplace = inplace )","title":"freeze()"},{"location":"api/Sequential/#treex.nn.sequential.Sequential.get_field","text":"A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: The field must be declared in the class definition. The method can only be called inside a compact context. Parameters: Name Type Description Default field_name str The name of the field to get. required initializer Callable[[], ~A] The function to initialize the field if it does not exist. required Returns: Type Description ~A The field value. Source code in treex/nn/sequential.py def get_field ( self , field_name : str , initializer : tp . Callable [[], A ], ) -> A : \"\"\" A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: * The field must be declared in the class definition. * The method can only be called inside a `compact` context. Arguments: field_name: The name of the field to get. initializer: The function to initialize the field if it does not exist. Returns: The field value. \"\"\" value : A if field_name not in self . _field_metadata : raise ValueError ( f \"Metadata for field ' { field_name } ' does not exist.\" ) if field_name in vars ( self ): value = getattr ( self , field_name ) else : if tree_m . _COMPACT_CONTEXT . in_compact and not self . first_run : raise RuntimeError ( f \"Trying to initialize field ' { field_name } ' after the first run of `compact`.\" ) value = initializer () setattr ( self , field_name , value ) return value","title":"get_field()"},{"location":"api/Sequential/#treex.nn.sequential.Sequential.init","text":"Method version of tx.init , it applies self as first argument. init creates a new module with the same structure, but with its fields initialized given a seed key . The following procedure is used: The input key is split and iteratively updated before passing a derived value to any process that requires initialization. Initializer s are called and applied to the module first. Module.rng_init methods are called last. Parameters: Name Type Description Default key Union[int, jax._src.numpy.lax_numpy.ndarray] The seed to use for initialization. required Returns: Type Description ~M The new module with the fields initialized. Source code in treex/nn/sequential.py def init ( self : M , key : tp . Union [ int , jnp . ndarray ], inputs : types . InputLike = to . MISSING , call_method : str = \"__call__\" , * , inplace : bool = False , _set_initialize : bool = True , ) -> M : \"\"\" Method version of `tx.init`, it applies `self` as first argument. `init` creates a new module with the same structure, but with its fields initialized given a seed `key`. The following procedure is used: 1. The input `key` is split and iteratively updated before passing a derived value to any process that requires initialization. 2. `Initializer`s are called and applied to the module first. 3. `Module.rng_init` methods are called last. Arguments: key: The seed to use for initialization. Returns: The new module with the fields initialized. \"\"\" module = self . copy () if not inplace else self key = utils . Key ( key ) with _INIT_CONTEXT . update ( key = key , initializing = True ): module : M = module . map ( lambda initializer : ( initializer ( next_key ()) if isinstance ( initializer , types . Initializer ) else initializer ), is_leaf = lambda x : isinstance ( x , types . Initializer ), inplace = True , ) def call_rng_init ( module : Module ): if isinstance ( module , Module ) and not module . _initialized : module . rng_init () module = to . apply ( call_rng_init , module , inplace = True ) if inputs is not to . MISSING : inputs = types . Inputs . from_value ( inputs ) method = getattr ( module , call_method ) method ( * inputs . args , ** inputs . kwargs ) if _set_initialize : def set_initialized ( module : Module ): if isinstance ( module , Module ) and not module . _initialized : module . _initialized = True module = to . apply ( set_initialized , module , inplace = True ) return module","title":"init()"},{"location":"api/Sequential/#treex.nn.sequential.Sequential.logs","text":"Returns a copy of the Module with only tx.Log TreeParts, alias for filter(tx.Log) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/sequential.py def logs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Log TreeParts, alias for `filter(tx.Log)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . Log , * filters )","title":"logs()"},{"location":"api/Sequential/#treex.nn.sequential.Sequential.loss_logs","text":"Returns a copy of the Module with only tx.Loss TreeParts, alias for filter(tx.Loss) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/sequential.py def loss_logs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Loss TreeParts, alias for `filter(tx.Loss)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . LossLog , * filters )","title":"loss_logs()"},{"location":"api/Sequential/#treex.nn.sequential.Sequential.map","text":"map is a wrapper over treeo.map that passes self as the second argument. Parameters: Name Type Description Default f Callable The function to apply to the leaves. required *filters Filter The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treex/nn/sequential.py def map ( self : A , f : tp . Callable , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , is_leaf : tp . Callable [[ tp . Any ], bool ] = None , ) -> A : \"\"\" `map` is a wrapper over `treeo.map` that passes `self` as the second argument. Arguments: f: The function to apply to the leaves. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" return api . map ( f , self , * filters , inplace = inplace , flatten_mode = flatten_mode , is_leaf = is_leaf , )","title":"map()"},{"location":"api/Sequential/#treex.nn.sequential.Sequential.merge","text":"merge is a wrapper over treeo.merge that passes self as the first argument. Parameters: Name Type Description Default other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the merged values. If inplace is True , obj is returned. Source code in treex/nn/sequential.py def merge ( self : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" `merge` is a wrapper over `treeo.merge` that passes `self` as the first argument. Arguments: other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the merged values. If `inplace` is `True`, `obj` is returned. \"\"\" return api . merge ( self , other , * rest , inplace = inplace , flatten_mode = flatten_mode , ignore_static = ignore_static , )","title":"merge()"},{"location":"api/Sequential/#treex.nn.sequential.Sequential.metric_logs","text":"Returns a copy of the Module with only tx.Metric TreeParts, alias for filter(tx.Metric) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/sequential.py def metric_logs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Metric TreeParts, alias for `filter(tx.Metric)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . MetricLog , * filters )","title":"metric_logs()"},{"location":"api/Sequential/#treex.nn.sequential.Sequential.model_states","text":"Returns a copy of the Module with only tx.ModelState TreeParts, alias for filter(tx.ModelState) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/sequential.py def model_states ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.ModelState TreeParts, alias for `filter(tx.ModelState)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . ModelState , * filters )","title":"model_states()"},{"location":"api/Sequential/#treex.nn.sequential.Sequential.parameters","text":"Returns a copy of the Module with only tx.Parameter TreeParts, alias for filter(tx.Parameter) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/sequential.py def parameters ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Parameter TreeParts, alias for `filter(tx.Parameter)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . Parameter , * filters )","title":"parameters()"},{"location":"api/Sequential/#treex.nn.sequential.Sequential.rngs","text":"Returns a copy of the Module with only tx.Rng TreeParts, alias for filter(tx.Rng) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/sequential.py def rngs ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.Rng TreeParts, alias for `filter(tx.Rng)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . Rng , * filters )","title":"rngs()"},{"location":"api/Sequential/#treex.nn.sequential.Sequential.states","text":"Returns a copy of the Module with only tx.State TreeParts, alias for filter(tx.State) . Parameters: Name Type Description Default filters Union[Type[Type[Any]], Callable[[treeo.tree.FieldInfo], bool]] additional filters passed to filter . () Source code in treex/nn/sequential.py def states ( self : A , * filters : Filter ) -> A : \"\"\" Returns a copy of the Module with only tx.State TreeParts, alias for `filter(tx.State)`. Arguments: filters: additional filters passed to `filter`. \"\"\" return to . filter ( self , types . State , * filters )","title":"states()"},{"location":"api/Sequential/#treex.nn.sequential.Sequential.tabulate","text":"Returns a tabular representation of the module. Parameters: Name Type Description Default depth int The maximum depth of the representation in terms of nested Modules, -1 means no limit. -1 signature bool Whether to show the signature of the Module. False param_types bool Whether to show the types of the parameters. True Returns: Type Description str A string containing the tabular representation. Source code in treex/nn/sequential.py def tabulate ( self , inputs : tp . Union [ types . InputLike , to . Missing ] = to . MISSING , depth : int = - 1 , signature : bool = False , param_types : bool = True , ) -> str : \"\"\" Returns a tabular representation of the module. Arguments: depth: The maximum depth of the representation in terms of nested Modules, -1 means no limit. signature: Whether to show the signature of the Module. param_types: Whether to show the types of the parameters. Returns: A string containing the tabular representation. \"\"\" self = to . copy ( self ) if inputs is not to . MISSING : inputs = types . Inputs . from_value ( inputs ) if not isinstance ( self , tp . Callable ): raise TypeError ( \"`inputs` can only be specified if the module is a callable.\" ) with contexts . _Context ( call_info = {}): # call using self to preserve references def eval_call ( args , kwargs ): assert isinstance ( self , tp . Callable ) return self ( * args , ** kwargs ) jax . eval_shape ( eval_call , inputs . args , inputs . kwargs , ) call_info = contexts . _CONTEXT . call_info else : call_info = None with to . add_field_info (): flat : tp . List [ to . FieldInfo ] flat , _ = jax . tree_flatten ( self ) tree_part_types : tp . Tuple [ tp . Type [ types . TreePart ], ... ] = tuple ( { field_info . kind for field_info in flat if utils . _generic_issubclass ( field_info . kind , types . TreePart ) } ) path = () rows = list ( utils . _get_tabulate_rows ( path , self , depth , tree_part_types , signature , param_types ) ) modules = [ row [ 0 ] for row in rows ] rows = [ row [ 1 :] for row in rows ] if call_info is not None : for module , row in zip ( modules , rows ): if module in call_info : inputs , outputs = call_info [ module ] simplified_inputs = ( inputs . args [ 0 ] if len ( inputs . kwargs ) == 0 and len ( inputs . args ) == 1 else inputs . kwargs if len ( inputs . kwargs ) == 0 else inputs . kwargs if len ( inputs . args ) == 0 else ( inputs . args , inputs . kwargs ) ) inputs_repr = utils . _format_param_tree ( simplified_inputs ) outputs_repr = utils . _format_param_tree ( outputs ) else : inputs_repr = \"\" outputs_repr = \"\" row . insert ( 3 , outputs_repr ) row . insert ( 3 , inputs_repr ) n_non_treepart_cols = 2 if call_info is None else 4 rows [ 0 ][ 0 ] = \"*\" rows . append ( [ \"\" ] * n_non_treepart_cols + [ \"Total:\" ] + [ utils . _format_obj_size ( self . filter ( kind ), add_padding = True ) for kind in tree_part_types ] ) utils . _add_padding ( rows ) table = Table ( show_header = True , show_lines = True , show_footer = True , # box=rich.box.HORIZONTALS, ) table . add_column ( \"path\" ) table . add_column ( \"module\" ) table . add_column ( \"params\" ) if call_info is not None : table . add_column ( \"inputs\" ) table . add_column ( \"outputs\" ) for tree_part_type in tree_part_types : type_name = tree_part_type . __name__ if type_name . startswith ( \"_\" ): type_name = type_name [ 1 :] table . add_column ( type_name ) for row in rows [: - 1 ]: table . add_row ( * row ) table . columns [ n_non_treepart_cols ] . footer = Text . from_markup ( rows [ - 1 ][ n_non_treepart_cols ], justify = \"right\" ) for i in range ( len ( tree_part_types )): table . columns [ n_non_treepart_cols + 1 + i ] . footer = rows [ - 1 ][ n_non_treepart_cols + 1 + i ] table . caption_style = \"bold\" table . caption = \" \\n Total Parameters: \" + utils . _format_obj_size ( self , add_padding = False ) return utils . _get_rich_repr ( table )","title":"tabulate()"},{"location":"api/Sequential/#treex.nn.sequential.Sequential.to_dict","text":"to_dict is a wrapper over treeo.to_dict that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True type_info bool If True , type information is included. False field_info bool If True , field information is included. False Returns: Type Description Any A dict representation of the object. Source code in treex/nn/sequential.py def to_dict ( self , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : \"\"\" `to_dict` is a wrapper over `treeo.to_dict` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. type_info: If `True`, type information is included. field_info: If `True`, field information is included. Returns: A dict representation of the object. \"\"\" return api . to_dict ( self , private_fields = private_fields , static_fields = static_fields , type_info = type_info , field_info = field_info , )","title":"to_dict()"},{"location":"api/Sequential/#treex.nn.sequential.Sequential.to_string","text":"to_string is a wrapper over treeo.to_string that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True color bool If True , color is included. False Returns: Type Description str A string representation of the object. Source code in treex/nn/sequential.py def to_string ( self : A , * , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" `to_string` is a wrapper over `treeo.to_string` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. color: If `True`, color is included. Returns: A string representation of the object. \"\"\" return api . to_string ( self , private_fields = private_fields , static_fields = static_fields , color = color , )","title":"to_string()"},{"location":"api/Sequential/#treex.nn.sequential.Sequential.train","text":"Creates a new module with the same structure, but with Module.training set to the given value. Parameters: Name Type Description Default mode bool The new training mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module in with the training mode is set to the given value, if inplace is True then self is returned. Source code in treex/nn/sequential.py def train ( self : T , mode : bool = True , inplace : bool = False ) -> T : \"\"\" Creates a new module with the same structure, but with `Module.training` set to the given value. Arguments: mode: The new training mode. inplace: Whether to update the module inplace. Returns: The new module in with the training mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_training ( tree ): if isinstance ( tree , Treex ) and hasattr ( tree , \"_training\" ): tree . _training = mode return to . apply ( set_training , self , inplace = inplace )","title":"train()"},{"location":"api/Sequential/#treex.nn.sequential.Sequential.unfreeze","text":"Creates a new module with .frozen set to False, equivalent to calling freeze(False) . Parameters: Name Type Description Default inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module with .frozen set to False, if inplace is True then self is returned. Source code in treex/nn/sequential.py def unfreeze ( self : T , inplace : bool = False ) -> T : \"\"\" Creates a new module with `.frozen` set to False, equivalent to calling `freeze(False)`. Arguments: inplace: Whether to update the module inplace. Returns: The new module with `.frozen` set to False, if `inplace` is `True` then `self` is returned. \"\"\" return self . freeze ( False , inplace = inplace )","title":"unfreeze()"},{"location":"api/State/","text":"treex.State","title":"State"},{"location":"api/State/#treexstate","text":"","title":"treex.State"},{"location":"api/ToDict/","text":"treex.ToDict Mixin that adds a .to_dict() method to the class. to_dict ( self , * , private_fields = False , static_fields = True , type_info = False , field_info = False ) to_dict is a wrapper over treeo.to_dict that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True type_info bool If True , type information is included. False field_info bool If True , field information is included. False Returns: Type Description Any A dict representation of the object. Source code in treeo/mixins.py def to_dict ( self , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : \"\"\" `to_dict` is a wrapper over `treeo.to_dict` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. type_info: If `True`, type information is included. field_info: If `True`, field information is included. Returns: A dict representation of the object. \"\"\" return api . to_dict ( self , private_fields = private_fields , static_fields = static_fields , type_info = type_info , field_info = field_info , )","title":"ToDict"},{"location":"api/ToDict/#treextodict","text":"Mixin that adds a .to_dict() method to the class.","title":"treex.ToDict"},{"location":"api/ToDict/#treeo.mixins.ToDict.to_dict","text":"to_dict is a wrapper over treeo.to_dict that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True type_info bool If True , type information is included. False field_info bool If True , field information is included. False Returns: Type Description Any A dict representation of the object. Source code in treeo/mixins.py def to_dict ( self , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : \"\"\" `to_dict` is a wrapper over `treeo.to_dict` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. type_info: If `True`, type information is included. field_info: If `True`, field information is included. Returns: A dict representation of the object. \"\"\" return api . to_dict ( self , private_fields = private_fields , static_fields = static_fields , type_info = type_info , field_info = field_info , )","title":"to_dict()"},{"location":"api/ToString/","text":"treex.ToString Mixin that adds a .to_string() method to the class. to_string ( self , * , private_fields = False , static_fields = True , color = False ) to_string is a wrapper over treeo.to_string that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True color bool If True , color is included. False Returns: Type Description str A string representation of the object. Source code in treeo/mixins.py def to_string ( self : A , * , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" `to_string` is a wrapper over `treeo.to_string` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. color: If `True`, color is included. Returns: A string representation of the object. \"\"\" return api . to_string ( self , private_fields = private_fields , static_fields = static_fields , color = color , )","title":"ToString"},{"location":"api/ToString/#treextostring","text":"Mixin that adds a .to_string() method to the class.","title":"treex.ToString"},{"location":"api/ToString/#treeo.mixins.ToString.to_string","text":"to_string is a wrapper over treeo.to_string that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True color bool If True , color is included. False Returns: Type Description str A string representation of the object. Source code in treeo/mixins.py def to_string ( self : A , * , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" `to_string` is a wrapper over `treeo.to_string` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. color: If `True`, color is included. Returns: A string representation of the object. \"\"\" return api . to_string ( self , private_fields = private_fields , static_fields = static_fields , color = color , )","title":"to_string()"},{"location":"api/Tree/","text":"treex.Tree __class__ inherited __base__ inherited Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()). __instancecheck__ ( cls , instance ) special Override for isinstance(instance, cls). Source code in treeo/tree.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance ) __new__ ( mcls , name , bases , namespace , ** kwargs ) special staticmethod Create and return a new object. See help(type) for accurate signature. Source code in treeo/tree.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls __subclasscheck__ ( cls , subclass ) special Override for issubclass(subclass, cls). Source code in treeo/tree.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass ) register ( cls , subclass ) Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treeo/tree.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) register ( cls , subclass ) inherited Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treeo/tree.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) __init_subclass__ () classmethod special This method is called when a class is subclassed. The default implementation does nothing. It may be overridden to extend subclasses. Source code in treeo/tree.py def __init_subclass__ ( cls ): jax . tree_util . register_pytree_node_class ( cls ) # Restore the signature sig = inspect . signature ( cls . __init__ ) parameters = tuple ( sig . parameters . values ()) cls . __signature__ = sig . replace ( parameters = parameters [ 1 :]) annotations = utils . _get_all_annotations ( cls ) class_vars = utils . _get_all_vars ( cls ) # init class variables cls . _field_metadata = {} cls . _factory_fields = {} cls . _default_field_values = {} cls . _subtrees = None for field , value in class_vars . items (): if isinstance ( value , dataclasses . Field ): # save defaults if value . default is not dataclasses . MISSING : cls . _default_field_values [ field ] = value . default elif value . default_factory is not dataclasses . MISSING : cls . _factory_fields [ field ] = value . default_factory # extract metadata if value . metadata is not None and \"node\" in value . metadata : cls . _field_metadata [ field ] = types . FieldMetadata ( node = value . metadata [ \"node\" ], kind = value . metadata [ \"kind\" ], opaque = value . metadata [ \"opaque\" ], ) for field , value in annotations . items (): if field not in cls . _field_metadata : is_node = any ( issubclass ( t , Tree ) for t in utils . _all_types ( value )) cls . _field_metadata [ field ] = types . FieldMetadata ( node = is_node , kind = type ( None ), opaque = False , ) check_metadata_updates ( self ) Checks for new fields, if found, adds them to the metadata. Source code in treeo/tree.py def check_metadata_updates ( self ): \"\"\" Checks for new fields, if found, adds them to the metadata. \"\"\" with _CONTEXT . update ( flatten_mode = FlattenMode . all_fields ): jax . tree_flatten ( self )","title":"Tree"},{"location":"api/Tree/#treextree","text":"","title":"treex.Tree"},{"location":"api/Tree/#treeo.tree.Tree.__class__","text":"","title":"__class__"},{"location":"api/Tree/#treeo.tree.Tree.__class__.__base__","text":"Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()).","title":"__base__"},{"location":"api/Tree/#treeo.tree.Tree.__class__.__base__.__instancecheck__","text":"Override for isinstance(instance, cls). Source code in treeo/tree.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance )","title":"__instancecheck__()"},{"location":"api/Tree/#treeo.tree.Tree.__class__.__base__.__new__","text":"Create and return a new object. See help(type) for accurate signature. Source code in treeo/tree.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls","title":"__new__()"},{"location":"api/Tree/#treeo.tree.Tree.__class__.__base__.__subclasscheck__","text":"Override for issubclass(subclass, cls). Source code in treeo/tree.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass )","title":"__subclasscheck__()"},{"location":"api/Tree/#treeo.tree.Tree.__class__.__base__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treeo/tree.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/Tree/#treeo.tree.Tree.__class__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treeo/tree.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/Tree/#treeo.tree.Tree.__init_subclass__","text":"This method is called when a class is subclassed. The default implementation does nothing. It may be overridden to extend subclasses. Source code in treeo/tree.py def __init_subclass__ ( cls ): jax . tree_util . register_pytree_node_class ( cls ) # Restore the signature sig = inspect . signature ( cls . __init__ ) parameters = tuple ( sig . parameters . values ()) cls . __signature__ = sig . replace ( parameters = parameters [ 1 :]) annotations = utils . _get_all_annotations ( cls ) class_vars = utils . _get_all_vars ( cls ) # init class variables cls . _field_metadata = {} cls . _factory_fields = {} cls . _default_field_values = {} cls . _subtrees = None for field , value in class_vars . items (): if isinstance ( value , dataclasses . Field ): # save defaults if value . default is not dataclasses . MISSING : cls . _default_field_values [ field ] = value . default elif value . default_factory is not dataclasses . MISSING : cls . _factory_fields [ field ] = value . default_factory # extract metadata if value . metadata is not None and \"node\" in value . metadata : cls . _field_metadata [ field ] = types . FieldMetadata ( node = value . metadata [ \"node\" ], kind = value . metadata [ \"kind\" ], opaque = value . metadata [ \"opaque\" ], ) for field , value in annotations . items (): if field not in cls . _field_metadata : is_node = any ( issubclass ( t , Tree ) for t in utils . _all_types ( value )) cls . _field_metadata [ field ] = types . FieldMetadata ( node = is_node , kind = type ( None ), opaque = False , )","title":"__init_subclass__()"},{"location":"api/Tree/#treeo.tree.Tree.check_metadata_updates","text":"Checks for new fields, if found, adds them to the metadata. Source code in treeo/tree.py def check_metadata_updates ( self ): \"\"\" Checks for new fields, if found, adds them to the metadata. \"\"\" with _CONTEXT . update ( flatten_mode = FlattenMode . all_fields ): jax . tree_flatten ( self )","title":"check_metadata_updates()"},{"location":"api/TreeMeta/","text":"treex.TreeMeta __base__ inherited Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()). __instancecheck__ ( cls , instance ) special Override for isinstance(instance, cls). Source code in treeo/tree.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance ) __new__ ( mcls , name , bases , namespace , ** kwargs ) special staticmethod Create and return a new object. See help(type) for accurate signature. Source code in treeo/tree.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls __subclasscheck__ ( cls , subclass ) special Override for issubclass(subclass, cls). Source code in treeo/tree.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass ) register ( cls , subclass ) Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treeo/tree.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) register ( cls , subclass ) inherited Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treeo/tree.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"TreeMeta"},{"location":"api/TreeMeta/#treextreemeta","text":"","title":"treex.TreeMeta"},{"location":"api/TreeMeta/#treeo.tree.TreeMeta.__base__","text":"Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()).","title":"__base__"},{"location":"api/TreeMeta/#treeo.tree.TreeMeta.__base__.__instancecheck__","text":"Override for isinstance(instance, cls). Source code in treeo/tree.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance )","title":"__instancecheck__()"},{"location":"api/TreeMeta/#treeo.tree.TreeMeta.__base__.__new__","text":"Create and return a new object. See help(type) for accurate signature. Source code in treeo/tree.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls","title":"__new__()"},{"location":"api/TreeMeta/#treeo.tree.TreeMeta.__base__.__subclasscheck__","text":"Override for issubclass(subclass, cls). Source code in treeo/tree.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass )","title":"__subclasscheck__()"},{"location":"api/TreeMeta/#treeo.tree.TreeMeta.__base__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treeo/tree.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/TreeMeta/#treeo.tree.TreeMeta.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treeo/tree.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/TreePart/","text":"treex.TreePart","title":"TreePart"},{"location":"api/TreePart/#treextreepart","text":"","title":"treex.TreePart"},{"location":"api/Treex/","text":"treex.Treex A Tree class with all Mixin Extensions. Base class for all Treex classes. first_run : bool inherited property readonly Returns: Type Description bool True if its currently the first run of a compact method. __class__ inherited __base__ inherited Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()). __instancecheck__ ( cls , instance ) special Override for isinstance(instance, cls). Source code in treex/treex.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance ) __new__ ( mcls , name , bases , namespace , ** kwargs ) special staticmethod Create and return a new object. See help(type) for accurate signature. Source code in treex/treex.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls __subclasscheck__ ( cls , subclass ) special Override for issubclass(subclass, cls). Source code in treex/treex.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass ) register ( cls , subclass ) Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/treex.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) register ( cls , subclass ) inherited Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/treex.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) __repr__ ( self ) inherited special Uses treeo.to_string to generate a string representation of the object. Source code in treex/treex.py def __repr__ ( self ) -> tp . Any : \"\"\" Uses `treeo.to_string` to generate a string representation of the object. \"\"\" return api . to_string ( self , private_fields = False , static_fields = True , color = False , ) apply ( self , f , * rest , * , inplace = False ) inherited apply is a wrapper over treeo.apply that passes self as the second argument. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treex/treex.py def apply ( self : A , f : tp . Callable [ ... , None ], * rest : A , inplace : bool = False ) -> A : \"\"\" `apply` is a wrapper over `treeo.apply` that passes `self` as the second argument. Arguments: f: The function to apply. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" return api . apply ( f , self , * rest , inplace = inplace ) check_metadata_updates ( self ) inherited Checks for new fields, if found, adds them to the metadata. Source code in treex/treex.py def check_metadata_updates ( self ): \"\"\" Checks for new fields, if found, adds them to the metadata. \"\"\" with _CONTEXT . update ( flatten_mode = FlattenMode . all_fields ): jax . tree_flatten ( self ) copy ( self ) inherited copy is a wrapper over treeo.copy that passes self as the first argument. Source code in treex/treex.py def copy ( self : A ) -> A : \"\"\" `copy` is a wrapper over `treeo.copy` that passes `self` as the first argument. \"\"\" return tree_m . copy ( self ) eval ( self , inplace = False ) Creates a new module with the training mode set to False, equivalent to calling train(False) . Returns: Type Description ~T The new module with the training mode set to False. Source code in treex/treex.py def eval ( self : T , inplace : bool = False ) -> T : \"\"\" Creates a new module with the training mode set to False, equivalent to calling `train(False)`. Returns: The new module with the training mode set to False. \"\"\" return self . train ( False , inplace = inplace ) filter ( self , * filters , * , inplace = False , flatten_mode = None ) inherited filter is a wrapper over treeo.filter that passes self as the first argument. Parameters: Name Type Description Default *filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treex/treex.py def filter ( self : A , * filters : api . Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ) -> A : \"\"\" `filter` is a wrapper over `treeo.filter` that passes `self` as the first argument. Arguments: *filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" return api . filter ( self , * filters , inplace = inplace , flatten_mode = flatten_mode ) freeze ( self , mode = True , inplace = False ) Creates a new module with the same structure, but with Module.frozen set to the given value. Parameters: Name Type Description Default mode bool The new frozen mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module in with the frozen mode is set to the given value, if inplace is True then self is returned. Source code in treex/treex.py def freeze ( self : T , mode : bool = True , inplace : bool = False ) -> T : \"\"\" Creates a new module with the same structure, but with `Module.frozen` set to the given value. Arguments: mode: The new `frozen` mode. inplace: Whether to update the module inplace. Returns: The new module in with the `frozen` mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_frozen ( tree ): if isinstance ( tree , Treex ) and hasattr ( tree , \"_frozen\" ): tree . _frozen = mode return to . apply ( set_frozen , self , inplace = inplace ) get_field ( self , field_name , initializer ) inherited A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: The field must be declared in the class definition. The method can only be called inside a compact context. Parameters: Name Type Description Default field_name str The name of the field to get. required initializer Callable[[], ~A] The function to initialize the field if it does not exist. required Returns: Type Description ~A The field value. Source code in treex/treex.py def get_field ( self , field_name : str , initializer : tp . Callable [[], A ], ) -> A : \"\"\" A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: * The field must be declared in the class definition. * The method can only be called inside a `compact` context. Arguments: field_name: The name of the field to get. initializer: The function to initialize the field if it does not exist. Returns: The field value. \"\"\" value : A if field_name not in self . _field_metadata : raise ValueError ( f \"Metadata for field ' { field_name } ' does not exist.\" ) if field_name in vars ( self ): value = getattr ( self , field_name ) else : if tree_m . _COMPACT_CONTEXT . in_compact and not self . first_run : raise RuntimeError ( f \"Trying to initialize field ' { field_name } ' after the first run of `compact`.\" ) value = initializer () setattr ( self , field_name , value ) return value map ( self , f , * filters , * , inplace = False , flatten_mode = None , is_leaf = None ) inherited map is a wrapper over treeo.map that passes self as the second argument. Parameters: Name Type Description Default f Callable The function to apply to the leaves. required *filters Filter The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treex/treex.py def map ( self : A , f : tp . Callable , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , is_leaf : tp . Callable [[ tp . Any ], bool ] = None , ) -> A : \"\"\" `map` is a wrapper over `treeo.map` that passes `self` as the second argument. Arguments: f: The function to apply to the leaves. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" return api . map ( f , self , * filters , inplace = inplace , flatten_mode = flatten_mode , is_leaf = is_leaf , ) merge ( self , other , * rest , * , inplace = False , flatten_mode = None , ignore_static = False ) inherited merge is a wrapper over treeo.merge that passes self as the first argument. Parameters: Name Type Description Default other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the merged values. If inplace is True , obj is returned. Source code in treex/treex.py def merge ( self : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" `merge` is a wrapper over `treeo.merge` that passes `self` as the first argument. Arguments: other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the merged values. If `inplace` is `True`, `obj` is returned. \"\"\" return api . merge ( self , other , * rest , inplace = inplace , flatten_mode = flatten_mode , ignore_static = ignore_static , ) to_dict ( self , * , private_fields = False , static_fields = True , type_info = False , field_info = False ) inherited to_dict is a wrapper over treeo.to_dict that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True type_info bool If True , type information is included. False field_info bool If True , field information is included. False Returns: Type Description Any A dict representation of the object. Source code in treex/treex.py def to_dict ( self , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : \"\"\" `to_dict` is a wrapper over `treeo.to_dict` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. type_info: If `True`, type information is included. field_info: If `True`, field information is included. Returns: A dict representation of the object. \"\"\" return api . to_dict ( self , private_fields = private_fields , static_fields = static_fields , type_info = type_info , field_info = field_info , ) to_string ( self , * , private_fields = False , static_fields = True , color = False ) inherited to_string is a wrapper over treeo.to_string that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True color bool If True , color is included. False Returns: Type Description str A string representation of the object. Source code in treex/treex.py def to_string ( self : A , * , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" `to_string` is a wrapper over `treeo.to_string` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. color: If `True`, color is included. Returns: A string representation of the object. \"\"\" return api . to_string ( self , private_fields = private_fields , static_fields = static_fields , color = color , ) train ( self , mode = True , inplace = False ) Creates a new module with the same structure, but with Module.training set to the given value. Parameters: Name Type Description Default mode bool The new training mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module in with the training mode is set to the given value, if inplace is True then self is returned. Source code in treex/treex.py def train ( self : T , mode : bool = True , inplace : bool = False ) -> T : \"\"\" Creates a new module with the same structure, but with `Module.training` set to the given value. Arguments: mode: The new training mode. inplace: Whether to update the module inplace. Returns: The new module in with the training mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_training ( tree ): if isinstance ( tree , Treex ) and hasattr ( tree , \"_training\" ): tree . _training = mode return to . apply ( set_training , self , inplace = inplace ) unfreeze ( self , inplace = False ) Creates a new module with .frozen set to False, equivalent to calling freeze(False) . Parameters: Name Type Description Default inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module with .frozen set to False, if inplace is True then self is returned. Source code in treex/treex.py def unfreeze ( self : T , inplace : bool = False ) -> T : \"\"\" Creates a new module with `.frozen` set to False, equivalent to calling `freeze(False)`. Arguments: inplace: Whether to update the module inplace. Returns: The new module with `.frozen` set to False, if `inplace` is `True` then `self` is returned. \"\"\" return self . freeze ( False , inplace = inplace )","title":"Treex"},{"location":"api/Treex/#treextreex","text":"A Tree class with all Mixin Extensions. Base class for all Treex classes.","title":"treex.Treex"},{"location":"api/Treex/#treex.treex.Treex.first_run","text":"Returns: Type Description bool True if its currently the first run of a compact method.","title":"first_run"},{"location":"api/Treex/#treex.treex.Treex.__class__","text":"","title":"__class__"},{"location":"api/Treex/#treex.treex.Treex.__class__.__base__","text":"Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()).","title":"__base__"},{"location":"api/Treex/#treex.treex.Treex.__class__.__base__.__instancecheck__","text":"Override for isinstance(instance, cls). Source code in treex/treex.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance )","title":"__instancecheck__()"},{"location":"api/Treex/#treex.treex.Treex.__class__.__base__.__new__","text":"Create and return a new object. See help(type) for accurate signature. Source code in treex/treex.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls","title":"__new__()"},{"location":"api/Treex/#treex.treex.Treex.__class__.__base__.__subclasscheck__","text":"Override for issubclass(subclass, cls). Source code in treex/treex.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass )","title":"__subclasscheck__()"},{"location":"api/Treex/#treex.treex.Treex.__class__.__base__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/treex.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/Treex/#treex.treex.Treex.__class__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treex/treex.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/Treex/#treex.treex.Treex.__repr__","text":"Uses treeo.to_string to generate a string representation of the object. Source code in treex/treex.py def __repr__ ( self ) -> tp . Any : \"\"\" Uses `treeo.to_string` to generate a string representation of the object. \"\"\" return api . to_string ( self , private_fields = False , static_fields = True , color = False , )","title":"__repr__()"},{"location":"api/Treex/#treex.treex.Treex.apply","text":"apply is a wrapper over treeo.apply that passes self as the second argument. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treex/treex.py def apply ( self : A , f : tp . Callable [ ... , None ], * rest : A , inplace : bool = False ) -> A : \"\"\" `apply` is a wrapper over `treeo.apply` that passes `self` as the second argument. Arguments: f: The function to apply. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" return api . apply ( f , self , * rest , inplace = inplace )","title":"apply()"},{"location":"api/Treex/#treex.treex.Treex.check_metadata_updates","text":"Checks for new fields, if found, adds them to the metadata. Source code in treex/treex.py def check_metadata_updates ( self ): \"\"\" Checks for new fields, if found, adds them to the metadata. \"\"\" with _CONTEXT . update ( flatten_mode = FlattenMode . all_fields ): jax . tree_flatten ( self )","title":"check_metadata_updates()"},{"location":"api/Treex/#treex.treex.Treex.copy","text":"copy is a wrapper over treeo.copy that passes self as the first argument. Source code in treex/treex.py def copy ( self : A ) -> A : \"\"\" `copy` is a wrapper over `treeo.copy` that passes `self` as the first argument. \"\"\" return tree_m . copy ( self )","title":"copy()"},{"location":"api/Treex/#treex.treex.Treex.eval","text":"Creates a new module with the training mode set to False, equivalent to calling train(False) . Returns: Type Description ~T The new module with the training mode set to False. Source code in treex/treex.py def eval ( self : T , inplace : bool = False ) -> T : \"\"\" Creates a new module with the training mode set to False, equivalent to calling `train(False)`. Returns: The new module with the training mode set to False. \"\"\" return self . train ( False , inplace = inplace )","title":"eval()"},{"location":"api/Treex/#treex.treex.Treex.filter","text":"filter is a wrapper over treeo.filter that passes self as the first argument. Parameters: Name Type Description Default *filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treex/treex.py def filter ( self : A , * filters : api . Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ) -> A : \"\"\" `filter` is a wrapper over `treeo.filter` that passes `self` as the first argument. Arguments: *filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" return api . filter ( self , * filters , inplace = inplace , flatten_mode = flatten_mode )","title":"filter()"},{"location":"api/Treex/#treex.treex.Treex.freeze","text":"Creates a new module with the same structure, but with Module.frozen set to the given value. Parameters: Name Type Description Default mode bool The new frozen mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module in with the frozen mode is set to the given value, if inplace is True then self is returned. Source code in treex/treex.py def freeze ( self : T , mode : bool = True , inplace : bool = False ) -> T : \"\"\" Creates a new module with the same structure, but with `Module.frozen` set to the given value. Arguments: mode: The new `frozen` mode. inplace: Whether to update the module inplace. Returns: The new module in with the `frozen` mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_frozen ( tree ): if isinstance ( tree , Treex ) and hasattr ( tree , \"_frozen\" ): tree . _frozen = mode return to . apply ( set_frozen , self , inplace = inplace )","title":"freeze()"},{"location":"api/Treex/#treex.treex.Treex.get_field","text":"A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: The field must be declared in the class definition. The method can only be called inside a compact context. Parameters: Name Type Description Default field_name str The name of the field to get. required initializer Callable[[], ~A] The function to initialize the field if it does not exist. required Returns: Type Description ~A The field value. Source code in treex/treex.py def get_field ( self , field_name : str , initializer : tp . Callable [[], A ], ) -> A : \"\"\" A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: * The field must be declared in the class definition. * The method can only be called inside a `compact` context. Arguments: field_name: The name of the field to get. initializer: The function to initialize the field if it does not exist. Returns: The field value. \"\"\" value : A if field_name not in self . _field_metadata : raise ValueError ( f \"Metadata for field ' { field_name } ' does not exist.\" ) if field_name in vars ( self ): value = getattr ( self , field_name ) else : if tree_m . _COMPACT_CONTEXT . in_compact and not self . first_run : raise RuntimeError ( f \"Trying to initialize field ' { field_name } ' after the first run of `compact`.\" ) value = initializer () setattr ( self , field_name , value ) return value","title":"get_field()"},{"location":"api/Treex/#treex.treex.Treex.map","text":"map is a wrapper over treeo.map that passes self as the second argument. Parameters: Name Type Description Default f Callable The function to apply to the leaves. required *filters Filter The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treex/treex.py def map ( self : A , f : tp . Callable , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , is_leaf : tp . Callable [[ tp . Any ], bool ] = None , ) -> A : \"\"\" `map` is a wrapper over `treeo.map` that passes `self` as the second argument. Arguments: f: The function to apply to the leaves. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" return api . map ( f , self , * filters , inplace = inplace , flatten_mode = flatten_mode , is_leaf = is_leaf , )","title":"map()"},{"location":"api/Treex/#treex.treex.Treex.merge","text":"merge is a wrapper over treeo.merge that passes self as the first argument. Parameters: Name Type Description Default other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the merged values. If inplace is True , obj is returned. Source code in treex/treex.py def merge ( self : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" `merge` is a wrapper over `treeo.merge` that passes `self` as the first argument. Arguments: other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the merged values. If `inplace` is `True`, `obj` is returned. \"\"\" return api . merge ( self , other , * rest , inplace = inplace , flatten_mode = flatten_mode , ignore_static = ignore_static , )","title":"merge()"},{"location":"api/Treex/#treex.treex.Treex.to_dict","text":"to_dict is a wrapper over treeo.to_dict that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True type_info bool If True , type information is included. False field_info bool If True , field information is included. False Returns: Type Description Any A dict representation of the object. Source code in treex/treex.py def to_dict ( self , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : \"\"\" `to_dict` is a wrapper over `treeo.to_dict` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. type_info: If `True`, type information is included. field_info: If `True`, field information is included. Returns: A dict representation of the object. \"\"\" return api . to_dict ( self , private_fields = private_fields , static_fields = static_fields , type_info = type_info , field_info = field_info , )","title":"to_dict()"},{"location":"api/Treex/#treex.treex.Treex.to_string","text":"to_string is a wrapper over treeo.to_string that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True color bool If True , color is included. False Returns: Type Description str A string representation of the object. Source code in treex/treex.py def to_string ( self : A , * , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" `to_string` is a wrapper over `treeo.to_string` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. color: If `True`, color is included. Returns: A string representation of the object. \"\"\" return api . to_string ( self , private_fields = private_fields , static_fields = static_fields , color = color , )","title":"to_string()"},{"location":"api/Treex/#treex.treex.Treex.train","text":"Creates a new module with the same structure, but with Module.training set to the given value. Parameters: Name Type Description Default mode bool The new training mode. True inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module in with the training mode is set to the given value, if inplace is True then self is returned. Source code in treex/treex.py def train ( self : T , mode : bool = True , inplace : bool = False ) -> T : \"\"\" Creates a new module with the same structure, but with `Module.training` set to the given value. Arguments: mode: The new training mode. inplace: Whether to update the module inplace. Returns: The new module in with the training mode is set to the given value, if `inplace` is `True` then `self` is returned. \"\"\" def set_training ( tree ): if isinstance ( tree , Treex ) and hasattr ( tree , \"_training\" ): tree . _training = mode return to . apply ( set_training , self , inplace = inplace )","title":"train()"},{"location":"api/Treex/#treex.treex.Treex.unfreeze","text":"Creates a new module with .frozen set to False, equivalent to calling freeze(False) . Parameters: Name Type Description Default inplace bool Whether to update the module inplace. False Returns: Type Description ~T The new module with .frozen set to False, if inplace is True then self is returned. Source code in treex/treex.py def unfreeze ( self : T , inplace : bool = False ) -> T : \"\"\" Creates a new module with `.frozen` set to False, equivalent to calling `freeze(False)`. Arguments: inplace: Whether to update the module inplace. Returns: The new module with `.frozen` set to False, if `inplace` is `True` then `self` is returned. \"\"\" return self . freeze ( False , inplace = inplace )","title":"unfreeze()"},{"location":"api/add_field_info/","text":"treex.add_field_info A context manager that makes Tree s produce leaves as FieldInfo when flattening. Source code in treeo/api.py @contextmanager def add_field_info (): \"\"\" A context manager that makes `Tree`s produce leaves as `FieldInfo` when flattening. \"\"\" with tree_m . _CONTEXT . update ( add_field_info = True ): yield","title":"add_field_info"},{"location":"api/add_field_info/#treexadd_field_info","text":"A context manager that makes Tree s produce leaves as FieldInfo when flattening. Source code in treeo/api.py @contextmanager def add_field_info (): \"\"\" A context manager that makes `Tree`s produce leaves as `FieldInfo` when flattening. \"\"\" with tree_m . _CONTEXT . update ( add_field_info = True ): yield","title":"treex.add_field_info"},{"location":"api/apply/","text":"treex.apply Applies a function to all to.Tree s in a Pytree. Works very similar to jax.tree_map , but its values are to.Tree s instead of leaves, also f should apply the changes inplace to Tree object. If inplace is False , a copy of the first object is returned with the changes applied. The rest of the objects are always copied. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required obj ~A a pytree possibly containing Trees. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treeo/api.py def apply ( f : tp . Callable [ ... , None ], obj : A , * rest : A , inplace : bool = False ) -> A : \"\"\" Applies a function to all `to.Tree`s in a Pytree. Works very similar to `jax.tree_map`, but its values are `to.Tree`s instead of leaves, also `f` should apply the changes inplace to Tree object. If `inplace` is `False`, a copy of the first object is returned with the changes applied. The `rest` of the objects are always copied. Arguments: f: The function to apply. obj: a pytree possibly containing Trees. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" rest = tree_m . copy ( rest ) if not inplace : obj = tree_m . copy ( obj ) objs = ( obj ,) + rest def nested_fn ( obj , * rest ): if isinstance ( obj , Tree ): apply ( f , obj , * rest , inplace = True ) jax . tree_map ( nested_fn , * objs , is_leaf = lambda x : isinstance ( x , Tree ) and not x in objs , ) if isinstance ( obj , Tree ): f ( obj , * rest ) return obj","title":"apply"},{"location":"api/apply/#treexapply","text":"Applies a function to all to.Tree s in a Pytree. Works very similar to jax.tree_map , but its values are to.Tree s instead of leaves, also f should apply the changes inplace to Tree object. If inplace is False , a copy of the first object is returned with the changes applied. The rest of the objects are always copied. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required obj ~A a pytree possibly containing Trees. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treeo/api.py def apply ( f : tp . Callable [ ... , None ], obj : A , * rest : A , inplace : bool = False ) -> A : \"\"\" Applies a function to all `to.Tree`s in a Pytree. Works very similar to `jax.tree_map`, but its values are `to.Tree`s instead of leaves, also `f` should apply the changes inplace to Tree object. If `inplace` is `False`, a copy of the first object is returned with the changes applied. The `rest` of the objects are always copied. Arguments: f: The function to apply. obj: a pytree possibly containing Trees. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" rest = tree_m . copy ( rest ) if not inplace : obj = tree_m . copy ( obj ) objs = ( obj ,) + rest def nested_fn ( obj , * rest ): if isinstance ( obj , Tree ): apply ( f , obj , * rest , inplace = True ) jax . tree_map ( nested_fn , * objs , is_leaf = lambda x : isinstance ( x , Tree ) and not x in objs , ) if isinstance ( obj , Tree ): f ( obj , * rest ) return obj","title":"treex.apply"},{"location":"api/compact/","text":"treex.compact A decorator that enable the definition of Tree subnodes at runtime. Source code in treeo/api.py def compact ( f ): \"\"\" A decorator that enable the definition of Tree subnodes at runtime. \"\"\" @functools . wraps ( f ) def wrapper ( tree , * args , ** kwargs ): with tree_m . _COMPACT_CONTEXT . compact ( f , tree ): return f ( tree , * args , ** kwargs ) wrapper . _treeo_compact = True return wrapper","title":"compact"},{"location":"api/compact/#treexcompact","text":"A decorator that enable the definition of Tree subnodes at runtime. Source code in treeo/api.py def compact ( f ): \"\"\" A decorator that enable the definition of Tree subnodes at runtime. \"\"\" @functools . wraps ( f ) def wrapper ( tree , * args , ** kwargs ): with tree_m . _COMPACT_CONTEXT . compact ( f , tree ): return f ( tree , * args , ** kwargs ) wrapper . _treeo_compact = True return wrapper","title":"treex.compact"},{"location":"api/compact_module/","text":"treex.compact_module A decorator that enable the definition of functional Modules Source code in treex/module.py def compact_module ( f ) -> type : \"\"\" A decorator that enable the definition of functional Modules \"\"\" name = utils . _get_name ( f ) @functools . wraps ( f ) @to . compact def __call__ ( self , * args , ** kwargs ): return f ( * args , ** kwargs ) module_class = type ( name , ( Module ,), dict ( __call__ = __call__ , ), ) return module_class","title":"compact_module"},{"location":"api/compact_module/#treexcompact_module","text":"A decorator that enable the definition of functional Modules Source code in treex/module.py def compact_module ( f ) -> type : \"\"\" A decorator that enable the definition of functional Modules \"\"\" name = utils . _get_name ( f ) @functools . wraps ( f ) @to . compact def __call__ ( self , * args , ** kwargs ): return f ( * args , ** kwargs ) module_class = type ( name , ( Module ,), dict ( __call__ = __call__ , ), ) return module_class","title":"treex.compact_module"},{"location":"api/field/","text":"treex.field Source code in treeo/utils.py def field ( default : tp . Any = dataclasses . MISSING , * , node : bool , kind : type = type ( None ), default_factory : tp . Optional [ tp . Callable [[], tp . Any ]] = None , init : bool = True , repr : bool = True , hash : tp . Optional [ bool ] = None , compare : bool = True , opaque : tp . Union [ bool , OpaquePredicate ] = False , ) -> tp . Any : return dataclasses . field ( default = default , metadata = { \"node\" : node , \"kind\" : kind , \"opaque\" : opaque , }, default_factory = default_factory if default_factory is not None else dataclasses . MISSING , init = init , repr = repr , hash = hash , compare = compare , )","title":"field"},{"location":"api/field/#treexfield","text":"Source code in treeo/utils.py def field ( default : tp . Any = dataclasses . MISSING , * , node : bool , kind : type = type ( None ), default_factory : tp . Optional [ tp . Callable [[], tp . Any ]] = None , init : bool = True , repr : bool = True , hash : tp . Optional [ bool ] = None , compare : bool = True , opaque : tp . Union [ bool , OpaquePredicate ] = False , ) -> tp . Any : return dataclasses . field ( default = default , metadata = { \"node\" : node , \"kind\" : kind , \"opaque\" : opaque , }, default_factory = default_factory if default_factory is not None else dataclasses . MISSING , init = init , repr = repr , hash = hash , compare = compare , )","title":"treex.field"},{"location":"api/filter/","text":"treex.filter The filter function allows you to select a subtree by filtering based on a predicate or kind type, leaves that pass all filters are kept, the rest are set to Nothing . For more information see filter's user guide . Parameters: Name Type Description Default obj ~A A pytree (possibly containing to.Tree s) to be filtered. required *filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treeo/api.py def filter ( obj : A , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ FlattenMode , str , None ] = None , ) -> A : \"\"\" The `filter` function allows you to select a subtree by filtering based on a predicate or `kind` type, leaves that pass all filters are kept, the rest are set to `Nothing`. For more information see [filter's user guide](https://cgarciae.github.io/treeo/user-guide/api/filter). Arguments: obj: A pytree (possibly containing `to.Tree`s) to be filtered. *filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" if inplace and not hasattr ( obj , \"__dict__\" ): raise ValueError ( f \"Cannot filter inplace on objects with no __dict__ property, got { obj } \" ) input_obj = obj filters = tuple ( _get_kind_filter ( f ) if isinstance ( f , tp . Type ) else f for f in filters ) def apply_filters ( info : tp . Any ) -> tp . Any : if not isinstance ( info , FieldInfo ): info = FieldInfo ( name = None , value = info , kind = type ( None ), module = None , ) assert isinstance ( info , FieldInfo ) return info . value if all ( f ( info ) for f in filters ) else types . NOTHING with tree_m . _CONTEXT . update ( add_field_info = True ), _flatten_context ( flatten_mode ): obj = jax . tree_map ( apply_filters , obj ) if inplace : input_obj . __dict__ . update ( obj . __dict__ ) return input_obj else : return obj","title":"filter"},{"location":"api/filter/#treexfilter","text":"The filter function allows you to select a subtree by filtering based on a predicate or kind type, leaves that pass all filters are kept, the rest are set to Nothing . For more information see filter's user guide . Parameters: Name Type Description Default obj ~A A pytree (possibly containing to.Tree s) to be filtered. required *filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treeo/api.py def filter ( obj : A , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ FlattenMode , str , None ] = None , ) -> A : \"\"\" The `filter` function allows you to select a subtree by filtering based on a predicate or `kind` type, leaves that pass all filters are kept, the rest are set to `Nothing`. For more information see [filter's user guide](https://cgarciae.github.io/treeo/user-guide/api/filter). Arguments: obj: A pytree (possibly containing `to.Tree`s) to be filtered. *filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" if inplace and not hasattr ( obj , \"__dict__\" ): raise ValueError ( f \"Cannot filter inplace on objects with no __dict__ property, got { obj } \" ) input_obj = obj filters = tuple ( _get_kind_filter ( f ) if isinstance ( f , tp . Type ) else f for f in filters ) def apply_filters ( info : tp . Any ) -> tp . Any : if not isinstance ( info , FieldInfo ): info = FieldInfo ( name = None , value = info , kind = type ( None ), module = None , ) assert isinstance ( info , FieldInfo ) return info . value if all ( f ( info ) for f in filters ) else types . NOTHING with tree_m . _CONTEXT . update ( add_field_info = True ), _flatten_context ( flatten_mode ): obj = jax . tree_map ( apply_filters , obj ) if inplace : input_obj . __dict__ . update ( obj . __dict__ ) return input_obj else : return obj","title":"treex.filter"},{"location":"api/iter_split/","text":"treex.iter_split Source code in treex/utils.py def iter_split ( key : tp . Any , num : int = 2 ) -> tp . Tuple [ tp . Any , ... ]: splits = jax . random . split ( key , num ) return tuple ( splits [ i ] for i in range ( num ))","title":"iter_split"},{"location":"api/iter_split/#treexiter_split","text":"Source code in treex/utils.py def iter_split ( key : tp . Any , num : int = 2 ) -> tp . Tuple [ tp . Any , ... ]: splits = jax . random . split ( key , num ) return tuple ( splits [ i ] for i in range ( num ))","title":"treex.iter_split"},{"location":"api/map/","text":"treex.map Applies a function to all leaves in a pytree using jax.tree_map , if filters are given then the function will be applied only to the subset of leaves that match the filters. For more information see map's user guide . Parameters: Name Type Description Default f Callable The function to apply to the leaves. required obj ~A a pytree possibly containing to.Tree s. required *filters Union[Type[Any], Callable[[FieldInfo], bool]] The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treeo/api.py def map ( f : tp . Callable , obj : A , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ FlattenMode , str , None ] = None , is_leaf : tp . Callable [[ tp . Any ], bool ] = None , ) -> A : \"\"\" Applies a function to all leaves in a pytree using `jax.tree_map`, if `filters` are given then the function will be applied only to the subset of leaves that match the filters. For more information see [map's user guide](https://cgarciae.github.io/treeo/user-guide/api/map). Arguments: f: The function to apply to the leaves. obj: a pytree possibly containing `to.Tree`s. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" if inplace and not hasattr ( obj , \"__dict__\" ): raise ValueError ( f \"Cannot map inplace on objects with no __dict__ property, got { obj } \" ) input_obj = obj has_filters = len ( filters ) > 0 with _flatten_context ( flatten_mode ): if has_filters : new_obj = filter ( obj , * filters ) else : new_obj = obj new_obj : A = jax . tree_map ( f , new_obj , is_leaf = is_leaf ) if has_filters : new_obj = merge ( obj , new_obj ) if inplace : input_obj . __dict__ . update ( new_obj . __dict__ ) return input_obj else : return new_obj","title":"map"},{"location":"api/map/#treexmap","text":"Applies a function to all leaves in a pytree using jax.tree_map , if filters are given then the function will be applied only to the subset of leaves that match the filters. For more information see map's user guide . Parameters: Name Type Description Default f Callable The function to apply to the leaves. required obj ~A a pytree possibly containing to.Tree s. required *filters Union[Type[Any], Callable[[FieldInfo], bool]] The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treeo/api.py def map ( f : tp . Callable , obj : A , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ FlattenMode , str , None ] = None , is_leaf : tp . Callable [[ tp . Any ], bool ] = None , ) -> A : \"\"\" Applies a function to all leaves in a pytree using `jax.tree_map`, if `filters` are given then the function will be applied only to the subset of leaves that match the filters. For more information see [map's user guide](https://cgarciae.github.io/treeo/user-guide/api/map). Arguments: f: The function to apply to the leaves. obj: a pytree possibly containing `to.Tree`s. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" if inplace and not hasattr ( obj , \"__dict__\" ): raise ValueError ( f \"Cannot map inplace on objects with no __dict__ property, got { obj } \" ) input_obj = obj has_filters = len ( filters ) > 0 with _flatten_context ( flatten_mode ): if has_filters : new_obj = filter ( obj , * filters ) else : new_obj = obj new_obj : A = jax . tree_map ( f , new_obj , is_leaf = is_leaf ) if has_filters : new_obj = merge ( obj , new_obj ) if inplace : input_obj . __dict__ . update ( new_obj . __dict__ ) return input_obj else : return new_obj","title":"treex.map"},{"location":"api/merge/","text":"treex.merge Creates a new Tree with the same structure but its values merged based on the values from the incoming Trees. For more information see merge's user guide . Parameters: Name Type Description Default obj ~A Main pytree to merge. required other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the updated values. If inplace is True , obj is returned. Source code in treeo/api.py def merge ( obj : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" Creates a new Tree with the same structure but its values merged based on the values from the incoming Trees. For more information see [merge's user guide](https://cgarciae.github.io/treeo/user-guide/api/merge). Arguments: obj: Main pytree to merge. other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the updated values. If `inplace` is `True`, `obj` is returned. \"\"\" if inplace and not hasattr ( obj , \"__dict__\" ): raise TypeError ( f \"Cannot update inplace on objects with no __dict__ property, got { obj } \" ) if flatten_mode is None and tree_m . _CONTEXT . flatten_mode is None : flatten_mode = FlattenMode . all_fields input_obj = obj def merge_fn ( * xs ): for x in reversed ( xs ): if not isinstance ( x , types . Nothing ): return x return types . NOTHING tree_map_fn = _looser_tree_map if ignore_static else jax . tree_map with _flatten_context ( flatten_mode ): obj = tree_map_fn ( merge_fn , obj , other , * rest , is_leaf = lambda x : isinstance ( x , LEAF_TYPES ), ) if inplace : input_obj . __dict__ . update ( obj . __dict__ ) return input_obj else : return obj","title":"merge"},{"location":"api/merge/#treexmerge","text":"Creates a new Tree with the same structure but its values merged based on the values from the incoming Trees. For more information see merge's user guide . Parameters: Name Type Description Default obj ~A Main pytree to merge. required other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the updated values. If inplace is True , obj is returned. Source code in treeo/api.py def merge ( obj : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" Creates a new Tree with the same structure but its values merged based on the values from the incoming Trees. For more information see [merge's user guide](https://cgarciae.github.io/treeo/user-guide/api/merge). Arguments: obj: Main pytree to merge. other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the updated values. If `inplace` is `True`, `obj` is returned. \"\"\" if inplace and not hasattr ( obj , \"__dict__\" ): raise TypeError ( f \"Cannot update inplace on objects with no __dict__ property, got { obj } \" ) if flatten_mode is None and tree_m . _CONTEXT . flatten_mode is None : flatten_mode = FlattenMode . all_fields input_obj = obj def merge_fn ( * xs ): for x in reversed ( xs ): if not isinstance ( x , types . Nothing ): return x return types . NOTHING tree_map_fn = _looser_tree_map if ignore_static else jax . tree_map with _flatten_context ( flatten_mode ): obj = tree_map_fn ( merge_fn , obj , other , * rest , is_leaf = lambda x : isinstance ( x , LEAF_TYPES ), ) if inplace : input_obj . __dict__ . update ( obj . __dict__ ) return input_obj else : return obj","title":"treex.merge"},{"location":"api/next_key/","text":"treex.next_key Returns the next key. Returns: Type Description ndarray The next key. Source code in treex/module.py def next_key () -> jnp . ndarray : \"\"\" Returns the next key. Returns: The next key. \"\"\" if _INIT_CONTEXT . key is None : raise RuntimeError ( \"RNG key not set, you are either calling an uninitialized Module outside `.init` or forgot to call `rng_key` context manager.\" ) key , _INIT_CONTEXT . key = utils . iter_split ( _INIT_CONTEXT . key ) return key","title":"next_key"},{"location":"api/next_key/#treexnext_key","text":"Returns the next key. Returns: Type Description ndarray The next key. Source code in treex/module.py def next_key () -> jnp . ndarray : \"\"\" Returns the next key. Returns: The next key. \"\"\" if _INIT_CONTEXT . key is None : raise RuntimeError ( \"RNG key not set, you are either calling an uninitialized Module outside `.init` or forgot to call `rng_key` context manager.\" ) key , _INIT_CONTEXT . key = utils . iter_split ( _INIT_CONTEXT . key ) return key","title":"treex.next_key"},{"location":"api/node/","text":"treex.node Source code in treeo/utils.py def node ( default = dataclasses . MISSING , * , kind : type = type ( None ), default_factory : tp . Optional [ tp . Callable [[], tp . Any ]] = None , init : bool = True , repr : bool = True , hash : tp . Optional [ bool ] = None , compare : bool = True , opaque : tp . Union [ bool , OpaquePredicate ] = False , ) -> tp . Any : return field ( default = default , node = True , kind = kind , default_factory = default_factory , init = init , repr = repr , hash = hash , compare = compare , opaque = opaque , )","title":"node"},{"location":"api/node/#treexnode","text":"Source code in treeo/utils.py def node ( default = dataclasses . MISSING , * , kind : type = type ( None ), default_factory : tp . Optional [ tp . Callable [[], tp . Any ]] = None , init : bool = True , repr : bool = True , hash : tp . Optional [ bool ] = None , compare : bool = True , opaque : tp . Union [ bool , OpaquePredicate ] = False , ) -> tp . Any : return field ( default = default , node = True , kind = kind , default_factory = default_factory , init = init , repr = repr , hash = hash , compare = compare , opaque = opaque , )","title":"treex.node"},{"location":"api/rng_key/","text":"treex.rng_key Source code in treex/module.py @contextmanager def rng_key ( key : types . KeyLike ): key = utils . Key ( key ) with _INIT_CONTEXT . update ( key = key ): yield","title":"rng_key"},{"location":"api/rng_key/#treexrng_key","text":"Source code in treex/module.py @contextmanager def rng_key ( key : types . KeyLike ): key = utils . Key ( key ) with _INIT_CONTEXT . update ( key = key ): yield","title":"treex.rng_key"},{"location":"api/sequence/","text":"treex.sequence Creates a function that applies a sequence of callables to an input. Examples: class Block ( tx . Module ): linear : tx . Linear batch_norm : tx . BatchNorm dropout : tx . Dropout ... def __call__ ( self , x : jnp . ndarray ) -> jnp . ndarray : return tx . sequence ( self . linear , self . batch_norm , self . dropout , jax . nn . relu , )( x ) Parameters: Name Type Description Default *layers Callable[..., jax._src.numpy.lax_numpy.ndarray] A sequence of callables to apply. () Source code in treex/nn/sequential.py def sequence ( * layers : CallableModule ) -> CallableModule : \"\"\" Creates a function that applies a sequence of callables to an input. Example: ```python class Block(tx.Module): linear: tx.Linear batch_norm: tx.BatchNorm dropout: tx.Dropout ... def __call__(self, x: jnp.ndarray) -> jnp.ndarray: return tx.sequence( self.linear, self.batch_norm, self.dropout, jax.nn.relu, )(x) ``` Arguments: *layers: A sequence of callables to apply. \"\"\" def _sequence ( x : jnp . ndarray ) -> jnp . ndarray : for layer in layers : x = layer ( x ) return x return _sequence","title":"sequence"},{"location":"api/sequence/#treexsequence","text":"Creates a function that applies a sequence of callables to an input. Examples: class Block ( tx . Module ): linear : tx . Linear batch_norm : tx . BatchNorm dropout : tx . Dropout ... def __call__ ( self , x : jnp . ndarray ) -> jnp . ndarray : return tx . sequence ( self . linear , self . batch_norm , self . dropout , jax . nn . relu , )( x ) Parameters: Name Type Description Default *layers Callable[..., jax._src.numpy.lax_numpy.ndarray] A sequence of callables to apply. () Source code in treex/nn/sequential.py def sequence ( * layers : CallableModule ) -> CallableModule : \"\"\" Creates a function that applies a sequence of callables to an input. Example: ```python class Block(tx.Module): linear: tx.Linear batch_norm: tx.BatchNorm dropout: tx.Dropout ... def __call__(self, x: jnp.ndarray) -> jnp.ndarray: return tx.sequence( self.linear, self.batch_norm, self.dropout, jax.nn.relu, )(x) ``` Arguments: *layers: A sequence of callables to apply. \"\"\" def _sequence ( x : jnp . ndarray ) -> jnp . ndarray : for layer in layers : x = layer ( x ) return x return _sequence","title":"treex.sequence"},{"location":"api/static/","text":"treex.static Source code in treeo/utils.py def static ( default = dataclasses . MISSING , * , kind : type = type ( None ), default_factory : tp . Optional [ tp . Callable [[], tp . Any ]] = None , init : bool = True , repr : bool = True , hash : tp . Optional [ bool ] = None , compare : bool = True , opaque : tp . Union [ bool , OpaquePredicate ] = False , ) -> tp . Any : return field ( default , node = False , kind = kind , default_factory = default_factory , init = init , repr = repr , hash = hash , compare = compare , opaque = opaque , )","title":"static"},{"location":"api/static/#treexstatic","text":"Source code in treeo/utils.py def static ( default = dataclasses . MISSING , * , kind : type = type ( None ), default_factory : tp . Optional [ tp . Callable [[], tp . Any ]] = None , init : bool = True , repr : bool = True , hash : tp . Optional [ bool ] = None , compare : bool = True , opaque : tp . Union [ bool , OpaquePredicate ] = False , ) -> tp . Any : return field ( default , node = False , kind = kind , default_factory = default_factory , init = init , repr = repr , hash = hash , compare = compare , opaque = opaque , )","title":"treex.static"},{"location":"api/to_dict/","text":"treex.to_dict Source code in treeo/api.py def to_dict ( obj : tp . Any , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : if field_info : with add_field_info (), flatten_mode ( FlattenMode . all_fields ): flat , treedef = jax . tree_flatten ( obj ) obj = jax . tree_unflatten ( treedef , flat ) obj = apply ( _remove_field_info_from_metadata , obj ) return _to_dict ( obj , private_fields , static_fields , type_info )","title":"to_dict"},{"location":"api/to_dict/#treexto_dict","text":"Source code in treeo/api.py def to_dict ( obj : tp . Any , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : if field_info : with add_field_info (), flatten_mode ( FlattenMode . all_fields ): flat , treedef = jax . tree_flatten ( obj ) obj = jax . tree_unflatten ( treedef , flat ) obj = apply ( _remove_field_info_from_metadata , obj ) return _to_dict ( obj , private_fields , static_fields , type_info )","title":"treex.to_dict"},{"location":"api/to_string/","text":"treex.to_string Converts a pytree to a string representation. Parameters: Name Type Description Default obj Any The pytree to convert. required private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True Returns: Type Description str A string representation of the pytree. Source code in treeo/api.py def to_string ( obj : tp . Any , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" Converts a pytree to a string representation. Arguments: obj: The pytree to convert. private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. Returns: A string representation of the pytree. \"\"\" dict_ = to_dict ( obj , private_fields = private_fields , static_fields = static_fields , type_info = True , field_info = True , ) global RICH_WARNING_COUNT rep = _to_string ( dict_ , level = 0 , inline = False , color = color , space = \" \" ) rep = _add_padding ( rep ) if color : if Console is None or Text is None : if RICH_WARNING_COUNT < 1 : RICH_WARNING_COUNT += 1 logging . warning ( f \"'rich' library not available, install `rich` to get colors.\" ) else : rep = _get_rich_repr ( Text . from_markup ( rep )) return rep","title":"to_string"},{"location":"api/to_string/#treexto_string","text":"Converts a pytree to a string representation. Parameters: Name Type Description Default obj Any The pytree to convert. required private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True Returns: Type Description str A string representation of the pytree. Source code in treeo/api.py def to_string ( obj : tp . Any , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" Converts a pytree to a string representation. Arguments: obj: The pytree to convert. private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. Returns: A string representation of the pytree. \"\"\" dict_ = to_dict ( obj , private_fields = private_fields , static_fields = static_fields , type_info = True , field_info = True , ) global RICH_WARNING_COUNT rep = _to_string ( dict_ , level = 0 , inline = False , color = color , space = \" \" ) rep = _add_padding ( rep ) if color : if Console is None or Text is None : if RICH_WARNING_COUNT < 1 : RICH_WARNING_COUNT += 1 logging . warning ( f \"'rich' library not available, install `rich` to get colors.\" ) else : rep = _get_rich_repr ( Text . from_markup ( rep )) return rep","title":"treex.to_string"},{"location":"user-guide/defining-modules/","text":"Basic Modules Modules in Treex usually follow this recipe: They inherit from tx.Module . Parameter-like fields are declared with a tx.TreePart subclass kind e.g. tx.Parameter.node() Hyper-parameters fields usually don't contain a declaration so they are static. Modules can be defined as dataclasses or regular classes without any limitations. While not mandatory, they usually perform shape inference. For example, a basic Module will tend to look like this: import treex as tx class Linear ( tx . Module ): # use Treeo's API to define Parameter nodes w : jnp . ndarray = tx . Parameter . node () b : jnp . ndarray = tx . Parameter . node () def __init__ ( self , features_out : int ): self . features_out = features_out def __call__ ( self , x : jnp . ndarray ) -> jnp . ndarray : # init will call forward, we can know if we are inside it if self . initializing (): # `next_key` only available during `init` key = tx . next_key () # leverage shape inference self . w = jax . random . uniform ( key , shape = [ x . shape [ - 1 ], self . features_out ] ) self . b = jnp . zeros ( shape = [ self . features_out ]) # linear forward return jnp . dot ( x , self . w ) + self . b model = Linear ( 10 ) . init ( key = 42 , inputs = x ) Composite Modules Composite modules have the following characteristics: Their submodule fields are usually not declared, they are usually detected by their runtime value. Submodules are either created during __init__ or directly in __call__ when using @compact . class MLP ( tx . Module ): def __init__ ( self , features : Sequence [ int ]): self . features = features @tx . compact def __call__ ( self , x : jnp . ndarray ) -> jnp . ndarray : for units in self . features [: - 1 ]: x = Linear ( units )( x ) x = jax . nn . relu ( x ) return Linear ( self . features [ - 1 ])( x ) model = MLP ([ 32 , 10 ]) . init ( key = 42 , inputs = x ) If you don't want to use compact, you can create a list of Linear modules during __init__ and use them in __call__ . While in Pytorch you would create a ModuleList or ModuleDict to do this, in Treex you just need to use a (possibly generic) type annotation on the class field that contains a Module type (e.g. Linear ). class MLP ( tx . Module ): layers : List [ Linear ] # mandatory: registers field as a node def __init__ ( self , features : Sequence [ int ]): self . layers = [ Linear ( units ) for units in features ] @tx . compact def __call__ ( self , x : jnp . ndarray ) -> jnp . ndarray : for layer in self . layers [: - 1 ]: x = layer ( x ) x = jax . nn . relu ( x ) return self . layers [ - 1 ]( x ) model = MLP ([ 32 , 10 ]) . init ( key = 42 , inputs = x ) For more information check out Treeo's Node Policy .","title":"Defining Modules"},{"location":"user-guide/defining-modules/#basic-modules","text":"Modules in Treex usually follow this recipe: They inherit from tx.Module . Parameter-like fields are declared with a tx.TreePart subclass kind e.g. tx.Parameter.node() Hyper-parameters fields usually don't contain a declaration so they are static. Modules can be defined as dataclasses or regular classes without any limitations. While not mandatory, they usually perform shape inference. For example, a basic Module will tend to look like this: import treex as tx class Linear ( tx . Module ): # use Treeo's API to define Parameter nodes w : jnp . ndarray = tx . Parameter . node () b : jnp . ndarray = tx . Parameter . node () def __init__ ( self , features_out : int ): self . features_out = features_out def __call__ ( self , x : jnp . ndarray ) -> jnp . ndarray : # init will call forward, we can know if we are inside it if self . initializing (): # `next_key` only available during `init` key = tx . next_key () # leverage shape inference self . w = jax . random . uniform ( key , shape = [ x . shape [ - 1 ], self . features_out ] ) self . b = jnp . zeros ( shape = [ self . features_out ]) # linear forward return jnp . dot ( x , self . w ) + self . b model = Linear ( 10 ) . init ( key = 42 , inputs = x )","title":"Basic Modules"},{"location":"user-guide/defining-modules/#composite-modules","text":"Composite modules have the following characteristics: Their submodule fields are usually not declared, they are usually detected by their runtime value. Submodules are either created during __init__ or directly in __call__ when using @compact . class MLP ( tx . Module ): def __init__ ( self , features : Sequence [ int ]): self . features = features @tx . compact def __call__ ( self , x : jnp . ndarray ) -> jnp . ndarray : for units in self . features [: - 1 ]: x = Linear ( units )( x ) x = jax . nn . relu ( x ) return Linear ( self . features [ - 1 ])( x ) model = MLP ([ 32 , 10 ]) . init ( key = 42 , inputs = x ) If you don't want to use compact, you can create a list of Linear modules during __init__ and use them in __call__ . While in Pytorch you would create a ModuleList or ModuleDict to do this, in Treex you just need to use a (possibly generic) type annotation on the class field that contains a Module type (e.g. Linear ). class MLP ( tx . Module ): layers : List [ Linear ] # mandatory: registers field as a node def __init__ ( self , features : Sequence [ int ]): self . layers = [ Linear ( units ) for units in features ] @tx . compact def __call__ ( self , x : jnp . ndarray ) -> jnp . ndarray : for layer in self . layers [: - 1 ]: x = layer ( x ) x = jax . nn . relu ( x ) return self . layers [ - 1 ]( x ) model = MLP ([ 32 , 10 ]) . init ( key = 42 , inputs = x ) For more information check out Treeo's Node Policy .","title":"Composite Modules"},{"location":"user-guide/freezing-modules/","text":"Freezing Modules Module s have a .frozen property that specifies whether the module is frozen or not, Modules such as Dropout and BatchNorm which will behave differently based on its value. To switch between modes, use the .freeze() and .unfreeze() methods, they return a new Module whose frozen state and the state of all of its submodules (recursively) are set to the desired value. class ConvBlock ( tx . Module ): ... model = tx . Sequential ( ConvBlock ( 3 , 32 ), ConvBlock ( 32 , 64 ), ConvBlock ( 64 , 128 ), ... ) # train model ... # freeze some layers for layer in model . layers [: - 1 ]: layer . freeze ( inplace = True ) # fine-tune the model ... In this example we can leveraged the fact that Sequential has its submodules in .layers to freeze all but the last layers. Freezing modules is useful for tasks such as Transfer Learning where you want to keep most of the weights in a model unchange and train only a few of them on a new dataset. If you have a backbone you can just freeze the entire model. backbone = get_pretrained_model () backbone = backbone . freeze () model = tx . Sequential ( backbone , tx . Linear ( backbone . output_features , 10 ) ) . init ( 42 ) ... @jax . jit def train_step ( model , x , y , optimizer ): # only differentiate w.r.t. parameters whose module is not frozen params = model . filter ( tx . Parameter , lambda field : not field . module . frozen , ) ( loss , model ), grads = loss_fn ( params , model , x , y ) ... Notice that here we used a custom callback to filter to select only parameters from Modules that are not frozen.","title":"Freezing Modules"},{"location":"user-guide/freezing-modules/#freezing-modules","text":"Module s have a .frozen property that specifies whether the module is frozen or not, Modules such as Dropout and BatchNorm which will behave differently based on its value. To switch between modes, use the .freeze() and .unfreeze() methods, they return a new Module whose frozen state and the state of all of its submodules (recursively) are set to the desired value. class ConvBlock ( tx . Module ): ... model = tx . Sequential ( ConvBlock ( 3 , 32 ), ConvBlock ( 32 , 64 ), ConvBlock ( 64 , 128 ), ... ) # train model ... # freeze some layers for layer in model . layers [: - 1 ]: layer . freeze ( inplace = True ) # fine-tune the model ... In this example we can leveraged the fact that Sequential has its submodules in .layers to freeze all but the last layers. Freezing modules is useful for tasks such as Transfer Learning where you want to keep most of the weights in a model unchange and train only a few of them on a new dataset. If you have a backbone you can just freeze the entire model. backbone = get_pretrained_model () backbone = backbone . freeze () model = tx . Sequential ( backbone , tx . Linear ( backbone . output_features , 10 ) ) . init ( 42 ) ... @jax . jit def train_step ( model , x , y , optimizer ): # only differentiate w.r.t. parameters whose module is not frozen params = model . filter ( tx . Parameter , lambda field : not field . module . frozen , ) ( loss , model ), grads = loss_fn ( params , model , x , y ) ... Notice that here we used a custom callback to filter to select only parameters from Modules that are not frozen.","title":"Freezing Modules"},{"location":"user-guide/initialization/","text":"Initialization Initialization is performed by calling the Module.init method, init returns a new Module with all fields initialized. There are three initialization mechanisms for Modules in Treex: Using Module.initializing inside __call__ . Using a field Initializer object. Defining the rng_init method. Module.initializing During the forward pass you can check if the Module is initialized by calling self.initializing() and assign the fields that need to be initialized then and there. If you need access to a RNG key, you can use tx.next_key() inside a self.initializing() block ONLY, this will use the key passed during init . def __call__ ( self , x : jnp . ndarray ) -> jnp . ndarray : if self . initializing (): self . w = jax . random . uniform ( key = tx . next_key (), shape = [ x . shape [ - 1 ], self . features_out ] ) The benefit of this approach is that you can leverage the shape of the input to initialize the parameters. This method is used by most core layers provided by Treex. Field Initializer Initializer s contain a function that take a key and return an initial value, init will replace leaves with Initializer objects with the initial value their function outputs for the given key: class MyModule ( tx . Module ): a : Union [ tx . Initializer , jnp . ndarray ] = tx . Parameter . node () def __init__ ( self ): self . a = tx . Initializer ( lambda key : jax . random . uniform ( key , shape = ( 1 ,)) ) module = MyModule () . init ( 42 ) # > MyModule(a=array([0.034...])) This method is use for fields who's intialization doesn't require shape inference and doesn't depend on information of other fields. rng_init If you Module doesn't require shape inference but Initializer is not enough, you can override the rng_init method. class MyModule ( tx . Module ): a : Optional [ jnp . ndarray ] = tx . Parameter . node () b : Optional [ jnp . ndarray ] = tx . Parameter . node () def __init__ ( self ): self . a = None self . b = None def rng_init ( self ): self . a = jax . random . uniform ( tx . next_key (), shape = ( 1 ,))) self . b = 10.0 * self . a + jax . random . normal ( key , shape = ( 1 ,)) module = MyModule () . init ( 42 ) module # MyModule(a=array([0.3...]), b=array([3.2...])) Intialization order The order of initialization is: First all field Initializers are called. Second all rng_init methods are called. Lastly the __call__ method is called.","title":"Initialization"},{"location":"user-guide/initialization/#initialization","text":"Initialization is performed by calling the Module.init method, init returns a new Module with all fields initialized. There are three initialization mechanisms for Modules in Treex: Using Module.initializing inside __call__ . Using a field Initializer object. Defining the rng_init method.","title":"Initialization"},{"location":"user-guide/initialization/#moduleinitializing","text":"During the forward pass you can check if the Module is initialized by calling self.initializing() and assign the fields that need to be initialized then and there. If you need access to a RNG key, you can use tx.next_key() inside a self.initializing() block ONLY, this will use the key passed during init . def __call__ ( self , x : jnp . ndarray ) -> jnp . ndarray : if self . initializing (): self . w = jax . random . uniform ( key = tx . next_key (), shape = [ x . shape [ - 1 ], self . features_out ] ) The benefit of this approach is that you can leverage the shape of the input to initialize the parameters. This method is used by most core layers provided by Treex.","title":"Module.initializing"},{"location":"user-guide/initialization/#field-initializer","text":"Initializer s contain a function that take a key and return an initial value, init will replace leaves with Initializer objects with the initial value their function outputs for the given key: class MyModule ( tx . Module ): a : Union [ tx . Initializer , jnp . ndarray ] = tx . Parameter . node () def __init__ ( self ): self . a = tx . Initializer ( lambda key : jax . random . uniform ( key , shape = ( 1 ,)) ) module = MyModule () . init ( 42 ) # > MyModule(a=array([0.034...])) This method is use for fields who's intialization doesn't require shape inference and doesn't depend on information of other fields.","title":"Field Initializer"},{"location":"user-guide/initialization/#rng_init","text":"If you Module doesn't require shape inference but Initializer is not enough, you can override the rng_init method. class MyModule ( tx . Module ): a : Optional [ jnp . ndarray ] = tx . Parameter . node () b : Optional [ jnp . ndarray ] = tx . Parameter . node () def __init__ ( self ): self . a = None self . b = None def rng_init ( self ): self . a = jax . random . uniform ( tx . next_key (), shape = ( 1 ,))) self . b = 10.0 * self . a + jax . random . normal ( key , shape = ( 1 ,)) module = MyModule () . init ( 42 ) module # MyModule(a=array([0.3...]), b=array([3.2...]))","title":"rng_init"},{"location":"user-guide/initialization/#intialization-order","text":"The order of initialization is: First all field Initializers are called. Second all rng_init methods are called. Lastly the __call__ method is called.","title":"Intialization order"},{"location":"user-guide/intro/","text":"User Guide Module is the main construct in Treex, it inherits from treeo.Tree and adds a couple of convenient methods. We recommend that you review the core concepts of Treeo but we will provide a brief overview. Terminology These are the core concepts from Treeo: Type Annotation : ( type hints ) types you set while defining a variable after the : symbol. Field Declaration : default values for class variables that are set using the field function. Node Field : A field that is declared as a node, that is, its content is part of the tree leaves. Static Field : A field that is declared as a static, that is, its content is not part of the leaves. Field Kind : An associated type, separate from the type annotation, that gives semantic meaning to the field. In code these terms map to the following: class MyModule ( tx . Module ): # field annotation ------------declaration--------------- # v v v v some_field : jnp . ndarray = to . field ( node = True , kind = tx . Parameter ) # ^ ^ # node status field kind Here if node=False it would mean that the field is static, else is a node. The previous is written more compactly as: class MyModule ( tx . Module ): some_field : jnp . ndarray = tx . Parameter . node ()","title":"User Guide"},{"location":"user-guide/intro/#user-guide","text":"Module is the main construct in Treex, it inherits from treeo.Tree and adds a couple of convenient methods. We recommend that you review the core concepts of Treeo but we will provide a brief overview.","title":"User Guide"},{"location":"user-guide/intro/#terminology","text":"These are the core concepts from Treeo: Type Annotation : ( type hints ) types you set while defining a variable after the : symbol. Field Declaration : default values for class variables that are set using the field function. Node Field : A field that is declared as a node, that is, its content is part of the tree leaves. Static Field : A field that is declared as a static, that is, its content is not part of the leaves. Field Kind : An associated type, separate from the type annotation, that gives semantic meaning to the field. In code these terms map to the following: class MyModule ( tx . Module ): # field annotation ------------declaration--------------- # v v v v some_field : jnp . ndarray = to . field ( node = True , kind = tx . Parameter ) # ^ ^ # node status field kind Here if node=False it would mean that the field is static, else is a node. The previous is written more compactly as: class MyModule ( tx . Module ): some_field : jnp . ndarray = tx . Parameter . node ()","title":"Terminology"},{"location":"user-guide/optimizer/","text":"Optimizer Optax is an amazing library however, its optimizers are not pytrees, this means that their state and computation are separate and you cannot jit them. To solve this Treex provides a Optimizer class which inherits from treeo.Tree and can wrap any Optax optimizer. Optimizer follows a similar API as optax.GradientTransformation except that: There is no separate opt_state , the Optimizer contains the state. update by default applies the update the parameters, if you want the gradient updates instead you can set apply_updates=False . update also updates the internal state of the Optimizer in-place. While in Optax you would define something like this: def main (): ... optimizer = optax . adam ( 1e-3 ) opt_state = optimizer . init ( params ) ... @partial ( jax . jit , static_argnums = ( 4 ,)) def train_step ( model , x , y , opt_state , optimizer ): # optimizer has to be static ... updates , opt_state = optimizer . update ( grads , opt_state , params ) params = optax . apply_updates ( params , updates ) ... return model , loss , opt_state With tx.Optimizer you it can be simplified to: def main (): ... optimizer = tx . Optimizer ( optax . adam ( 1e-3 )) . init ( params ) ... jax . jit # no static_argnums needed def train_step ( model , x , y , optimizer ): ... params = optimizer . update ( grads , params ) ... return model , loss , optimizer Notice that since tx.Optimizer is a Pytree it was passed through jit naturally without the need to specify static_argnums .","title":"Optimizer"},{"location":"user-guide/optimizer/#optimizer","text":"Optax is an amazing library however, its optimizers are not pytrees, this means that their state and computation are separate and you cannot jit them. To solve this Treex provides a Optimizer class which inherits from treeo.Tree and can wrap any Optax optimizer. Optimizer follows a similar API as optax.GradientTransformation except that: There is no separate opt_state , the Optimizer contains the state. update by default applies the update the parameters, if you want the gradient updates instead you can set apply_updates=False . update also updates the internal state of the Optimizer in-place. While in Optax you would define something like this: def main (): ... optimizer = optax . adam ( 1e-3 ) opt_state = optimizer . init ( params ) ... @partial ( jax . jit , static_argnums = ( 4 ,)) def train_step ( model , x , y , opt_state , optimizer ): # optimizer has to be static ... updates , opt_state = optimizer . update ( grads , opt_state , params ) params = optax . apply_updates ( params , updates ) ... return model , loss , opt_state With tx.Optimizer you it can be simplified to: def main (): ... optimizer = tx . Optimizer ( optax . adam ( 1e-3 )) . init ( params ) ... jax . jit # no static_argnums needed def train_step ( model , x , y , optimizer ): ... params = optimizer . update ( grads , params ) ... return model , loss , optimizer Notice that since tx.Optimizer is a Pytree it was passed through jit naturally without the need to specify static_argnums .","title":"Optimizer"},{"location":"user-guide/pytrees/","text":"","title":"Pytrees"},{"location":"user-guide/state-management/","text":"State Management Treex takes a \"direct\" approach to state management, i.e., state is updated in-place by the Module whenever it needs to. For example, this module will calculate the running average of its input: class Average ( tx . Module ): count : jnp . ndarray = tx . State . node () total : jnp . ndarray = tx . State . node () def __init__ ( self ): self . count = jnp . array ( 0 ) self . total = jnp . array ( 0.0 ) def __call__ ( self , x ): self . count += np . prod ( x . shape ) self . total += jnp . sum ( x ) return self . total / self . count Treex Modules that require random state will often keep a rng key internally and update it in-place when needed: class Dropout ( tx . Module ): key : jnp . ndarray = tx . Rng . node () def __init__ ( self , key : jnp . ndarray ): self . key = key ... def __call__ ( self , x ): key , self . key = jax . random . split ( self . key ) ... Finally Optimizer also performs inplace updates inside the update method, here is a sketch of how it works: class Optimizer ( tx . Module ): opt_state : Any = tx . OptState . node () optimizer : optax . GradientTransformation def update ( self , grads , params ): ... updates , self . opt_state = self . optimizer . update ( grads , self . opt_state , params ) ... As you the the opt_state contains the Optax's optimizer state and is update inplace on every call to update . What is the catch? State management is one of the most challenging things in JAX because of its functional nature, however here it seems effortless. What is the catch? As always there are trade-offs to consider: The Pytree approach requires the user to be aware that if a Module is stateful it should propagate its state by having mutated object be outputs of jitted functions, on the other hand implementation and usage if very simple. Frameworks like Flax and Haiku are more explicit as to when state is updated but introduce a lot of complexity to do so. A standard solution to this problem is: always output the Module to update its state . For example, a typical loss function that contains a stateful model would look like this: @partial ( jax . value_and_grad , has_aux = True ) def loss_fn ( params , model , x , y ): model = model . update ( params ) preds = model ( x ) loss = jnp . mean (( preds - y ) ** 2 ) return loss , model params = model . parameters () ( loss , model ), grads = loss_fn ( params , model , x , y ) ... Here model is returned along with the loss through value_and_grad to update model on the outside thus persisting any changes to the state performed on the inside.","title":"State Management"},{"location":"user-guide/state-management/#state-management","text":"Treex takes a \"direct\" approach to state management, i.e., state is updated in-place by the Module whenever it needs to. For example, this module will calculate the running average of its input: class Average ( tx . Module ): count : jnp . ndarray = tx . State . node () total : jnp . ndarray = tx . State . node () def __init__ ( self ): self . count = jnp . array ( 0 ) self . total = jnp . array ( 0.0 ) def __call__ ( self , x ): self . count += np . prod ( x . shape ) self . total += jnp . sum ( x ) return self . total / self . count Treex Modules that require random state will often keep a rng key internally and update it in-place when needed: class Dropout ( tx . Module ): key : jnp . ndarray = tx . Rng . node () def __init__ ( self , key : jnp . ndarray ): self . key = key ... def __call__ ( self , x ): key , self . key = jax . random . split ( self . key ) ... Finally Optimizer also performs inplace updates inside the update method, here is a sketch of how it works: class Optimizer ( tx . Module ): opt_state : Any = tx . OptState . node () optimizer : optax . GradientTransformation def update ( self , grads , params ): ... updates , self . opt_state = self . optimizer . update ( grads , self . opt_state , params ) ... As you the the opt_state contains the Optax's optimizer state and is update inplace on every call to update .","title":"State Management"},{"location":"user-guide/state-management/#what-is-the-catch","text":"State management is one of the most challenging things in JAX because of its functional nature, however here it seems effortless. What is the catch? As always there are trade-offs to consider: The Pytree approach requires the user to be aware that if a Module is stateful it should propagate its state by having mutated object be outputs of jitted functions, on the other hand implementation and usage if very simple. Frameworks like Flax and Haiku are more explicit as to when state is updated but introduce a lot of complexity to do so. A standard solution to this problem is: always output the Module to update its state . For example, a typical loss function that contains a stateful model would look like this: @partial ( jax . value_and_grad , has_aux = True ) def loss_fn ( params , model , x , y ): model = model . update ( params ) preds = model ( x ) loss = jnp . mean (( preds - y ) ** 2 ) return loss , model params = model . parameters () ( loss , model ), grads = loss_fn ( params , model , x , y ) ... Here model is returned along with the loss through value_and_grad to update model on the outside thus persisting any changes to the state performed on the inside.","title":"What is the catch?"},{"location":"user-guide/training-state/","text":"Training State Modules have a training: bool property that specifies whether the module is in training mode or not. This property conditions the behavior of Modules such as Dropout and BatchNorm , which behave differently between training and evaluation. # training loop for step in range ( 1000 ): loss , model , opt_state = train_step ( model , x , y , opt_state ) # prepare for evaluation model = model . eval () # make predictions preds = model ( X_test ) To switch between modes, use the .train() and .eval() methods, they return a new Module whose training state and the state of all of its submodules (recursively) are set to the desired value.","title":"Training State"},{"location":"user-guide/training-state/#training-state","text":"Modules have a training: bool property that specifies whether the module is in training mode or not. This property conditions the behavior of Modules such as Dropout and BatchNorm , which behave differently between training and evaluation. # training loop for step in range ( 1000 ): loss , model , opt_state = train_step ( model , x , y , opt_state ) # prepare for evaluation model = model . eval () # make predictions preds = model ( X_test ) To switch between modes, use the .train() and .eval() methods, they return a new Module whose training state and the state of all of its submodules (recursively) are set to the desired value.","title":"Training State"},{"location":"user-guide/api/filter/","text":"Filter The filter method allows you to select a subtree by filtering based on a kind , all leaves whose field kind is a subclass of such type are kept, the rest are set to a special Nothing value. tree = MyModule ( a = 1 , b = 2 ) module . filter ( Parameter ) # MyModule(a=1, b=Nothing) module . filter ( BatchStat ) # MyModule(a=Nothing, b=2) Since Nothing is an empty Pytree it gets ignored by tree operations, this effectively allows you to easily operate on a subset of the fields: negative = lambda x : - x jax . tree_map ( negative , module . filter ( Parameter )) # MyModule(a=-1, b=Nothing) jax . tree_map ( negative , module . filter ( BatchStat )) # MyModule(a=Nothing, b=-2) Shortcuts As simple filters using the standard TreePart types are used often, some shortcuts are provided: Shortcut Equivalence .parameters() .filter(tx.Parameter) .batch_stats() .filter(tx.BatchStat) .rngs() .filter(tx.RNG) .model_states() .filter(tx.ModelState) .states() .filter(tx.State) .metrics() .filter(tx.Metric) .losses() .filter(tx.Loss) .logs() .filter(tx.Log) Based on this the first example can be written as: module . parameters () # MyModule(a=1, b=Nothing) module . batch_stats () # MyModule(a=Nothing, b=2) filter predicates If you need to do more complex filtering, you can pass callables with the signature FieldInfo -> bool instead of types: # all Parameters whose field name is \"kernel\" module . filter ( lambda field : issubclass ( field . kind , Parameter ) and field . name == \"kernel\" ) # MyModule(a=Nothing, b=Nothing) multiple filters You can some queries by using multiple filters as *args . For a field to be kept it will required that all filters pass . Since passing types by themselves are \"kind filters\", one of the previous examples could be written as: # all Parameters whose field name is \"kernel\" module . filter ( Parameter , lambda field : field . name == \"kernel\" ) # MyModule(a=Nothing, b=Nothing) inplace If inplace is True , the input obj is mutated and returned. You can only update inplace if the input obj has a __dict__ attribute, else a TypeError is raised.","title":"Filter"},{"location":"user-guide/api/filter/#filter","text":"The filter method allows you to select a subtree by filtering based on a kind , all leaves whose field kind is a subclass of such type are kept, the rest are set to a special Nothing value. tree = MyModule ( a = 1 , b = 2 ) module . filter ( Parameter ) # MyModule(a=1, b=Nothing) module . filter ( BatchStat ) # MyModule(a=Nothing, b=2) Since Nothing is an empty Pytree it gets ignored by tree operations, this effectively allows you to easily operate on a subset of the fields: negative = lambda x : - x jax . tree_map ( negative , module . filter ( Parameter )) # MyModule(a=-1, b=Nothing) jax . tree_map ( negative , module . filter ( BatchStat )) # MyModule(a=Nothing, b=-2)","title":"Filter"},{"location":"user-guide/api/filter/#shortcuts","text":"As simple filters using the standard TreePart types are used often, some shortcuts are provided: Shortcut Equivalence .parameters() .filter(tx.Parameter) .batch_stats() .filter(tx.BatchStat) .rngs() .filter(tx.RNG) .model_states() .filter(tx.ModelState) .states() .filter(tx.State) .metrics() .filter(tx.Metric) .losses() .filter(tx.Loss) .logs() .filter(tx.Log) Based on this the first example can be written as: module . parameters () # MyModule(a=1, b=Nothing) module . batch_stats () # MyModule(a=Nothing, b=2)","title":"Shortcuts"},{"location":"user-guide/api/filter/#filter-predicates","text":"If you need to do more complex filtering, you can pass callables with the signature FieldInfo -> bool instead of types: # all Parameters whose field name is \"kernel\" module . filter ( lambda field : issubclass ( field . kind , Parameter ) and field . name == \"kernel\" ) # MyModule(a=Nothing, b=Nothing)","title":"filter predicates"},{"location":"user-guide/api/filter/#multiple-filters","text":"You can some queries by using multiple filters as *args . For a field to be kept it will required that all filters pass . Since passing types by themselves are \"kind filters\", one of the previous examples could be written as: # all Parameters whose field name is \"kernel\" module . filter ( Parameter , lambda field : field . name == \"kernel\" ) # MyModule(a=Nothing, b=Nothing)","title":"multiple filters"},{"location":"user-guide/api/filter/#inplace","text":"If inplace is True , the input obj is mutated and returned. You can only update inplace if the input obj has a __dict__ attribute, else a TypeError is raised.","title":"inplace"},{"location":"user-guide/api/map/","text":"Map Applies a function to all leaves in the Module using jax.tree_map . If filters are given then the function will be applied only to the subset of leaves that match the filters. For example, if we want to zero all batch stats we can do: Example: @dataclass class MyModule ( x . Module ): a : int = tx . Parameter . node () b : int = tx . BatchStat . node () module = MyModule ( a = 1 , b = 2 ) module . map ( lambda _ : 0 , tx . BatchStat ) # MyTree(a=1, b=0) map is equivalent to filter -> tree_map -> merge in sequence. If inplace is True , the input obj is mutated and returned. You can only update inplace if the input obj has a __dict__ attribute, else a TypeError is raised.","title":"Map"},{"location":"user-guide/api/map/#map","text":"Applies a function to all leaves in the Module using jax.tree_map . If filters are given then the function will be applied only to the subset of leaves that match the filters. For example, if we want to zero all batch stats we can do: Example: @dataclass class MyModule ( x . Module ): a : int = tx . Parameter . node () b : int = tx . BatchStat . node () module = MyModule ( a = 1 , b = 2 ) module . map ( lambda _ : 0 , tx . BatchStat ) # MyTree(a=1, b=0) map is equivalent to filter -> tree_map -> merge in sequence. If inplace is True , the input obj is mutated and returned. You can only update inplace if the input obj has a __dict__ attribute, else a TypeError is raised.","title":"Map"},{"location":"user-guide/api/merge/","text":"Merge Creates a new Module with the same structure but its values merged based on the values from the incoming Modules. @dataclass class MyModule ( tx . Module ): a : int = tx . field ( node = True , kind = Parameter ) b : int = tx . field ( node = True , kind = BatchStat ) m1 = MyModule ( x = Nothing , y = 2 , z = 3 ) m2 = MyModule ( x = 1 , y = Nothing , z = 4 ) m1 . merge ( m2 ) # MyModule(x=1, y=2, z=4) Updates are performed using the following rules: For a list of equivalent leaves l1, l2, ..., ln , it returns the first non- Nothing leaf from right to left. If no flatten_mode() context manager is active and flatten_mode is not given, all fields will be updated. If flatten_mode=\"normal\" is set then static fields won't be updated and the output will have the exact same static components as the first input ( obj ). When using merge with multiple Modules the following equivalence holds: m1.merge(m2, m3) = m1.merge(m2.merge(m3)) If you want to merge the current module instead of creating a new one use inplace=True . This is useful when applying transformation inside a method where reassigning self is not possible: def double_params ( self ): # this is not doing what you expect self = jax . tree_map ( lambda x : 2 * x , self ) Instead do this: def double_params ( self ): doubled = jax . tree_map ( lambda x : 2 * x , self ) self . merge ( doubled , inplace = True ) If inplace is True , the input obj is mutated and returned. You can only merge inplace if the input obj has a __dict__ attribute, else a TypeError is raised. If ignore_static is True , static fields (according to the flattening mode) will be bypassed during the merge process, the final output will have the same static components as the first input ( obj ). This strategy is a bit less safe in general as it will flatten all trees using jax.tree_leaves instead of PyTreeDef.flatten_up_to , this skips some checks so it effectively ignores their static components, the only requirement is that the flattened struture of all trees matches.","title":"Merge"},{"location":"user-guide/api/merge/#merge","text":"Creates a new Module with the same structure but its values merged based on the values from the incoming Modules. @dataclass class MyModule ( tx . Module ): a : int = tx . field ( node = True , kind = Parameter ) b : int = tx . field ( node = True , kind = BatchStat ) m1 = MyModule ( x = Nothing , y = 2 , z = 3 ) m2 = MyModule ( x = 1 , y = Nothing , z = 4 ) m1 . merge ( m2 ) # MyModule(x=1, y=2, z=4) Updates are performed using the following rules: For a list of equivalent leaves l1, l2, ..., ln , it returns the first non- Nothing leaf from right to left. If no flatten_mode() context manager is active and flatten_mode is not given, all fields will be updated. If flatten_mode=\"normal\" is set then static fields won't be updated and the output will have the exact same static components as the first input ( obj ). When using merge with multiple Modules the following equivalence holds: m1.merge(m2, m3) = m1.merge(m2.merge(m3)) If you want to merge the current module instead of creating a new one use inplace=True . This is useful when applying transformation inside a method where reassigning self is not possible: def double_params ( self ): # this is not doing what you expect self = jax . tree_map ( lambda x : 2 * x , self ) Instead do this: def double_params ( self ): doubled = jax . tree_map ( lambda x : 2 * x , self ) self . merge ( doubled , inplace = True ) If inplace is True , the input obj is mutated and returned. You can only merge inplace if the input obj has a __dict__ attribute, else a TypeError is raised. If ignore_static is True , static fields (according to the flattening mode) will be bypassed during the merge process, the final output will have the same static components as the first input ( obj ). This strategy is a bit less safe in general as it will flatten all trees using jax.tree_leaves instead of PyTreeDef.flatten_up_to , this skips some checks so it effectively ignores their static components, the only requirement is that the flattened struture of all trees matches.","title":"Merge"}]}